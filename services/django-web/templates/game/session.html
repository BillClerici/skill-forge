{% extends 'base.html' %}
{% load static %}

{% block title %}Game Session - {{ campaign.title }}{% endblock %}

{% block extra_css %}
<style>
    /* ===================================
       Global Game Layout Styles
       =================================== */
    *, *::before, *::after {
        box-sizing: border-box;
    }

    body {
        margin: 0;
        padding: 0;
        overflow: hidden;
    }

    /* Override base.html container for full-screen game */
    main {
        padding: 0 !important;
    }

    main > .container {
        padding: 0 !important;
        margin: 0 !important;
        width: 100% !important;
        max-width: 100% !important;
    }

    .game-wrapper {
        display: flex;
        flex-direction: column;
        height: calc(100vh - 64px); /* Subtract nav height */
        width: 100vw;
        overflow: hidden;
        position: fixed;
        top: 64px; /* Position below nav bar */
        left: 0;
        z-index: 1;
    }

    /* ===================================
       Header - Rounded and spanning main content
       =================================== */
    .game-header {
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        color: white;
        flex-shrink: 0;
        z-index: 100;
        box-shadow: 0 4px 6px rgba(0,0,0,0.1);
        transition: margin 0.3s ease-in-out, width 0.3s ease-in-out;
        border-radius: 8px;
        margin: 0.5rem;
        width: calc(100% - 1rem);
    }

    .game-header.left-condensed {
        margin-left: calc(320px + 1rem);
        width: calc(100% - 320px - 2rem);
    }

    .game-header.right-condensed {
        margin-right: calc(320px + 1rem);
        width: calc(100% - 320px - 2rem);
    }

    .game-header.both-condensed {
        margin-left: calc(320px + 1rem);
        margin-right: calc(320px + 1rem);
        width: calc(100% - 640px - 2rem);
    }

    /* When both right drawers are anchored */
    .game-header.both-right-condensed {
        margin-right: calc(640px + 1rem);
        width: calc(100% - 640px - 2rem);
    }

    /* When left drawer + both right drawers are anchored */
    .game-header.left-condensed.both-right-condensed {
        margin-left: calc(320px + 1rem);
        margin-right: calc(640px + 1rem);
        width: calc(100% - 960px - 2rem);
    }

    .campaign-info-row {
        display: flex;
        align-items: center;
        gap: 0.5rem;
        padding: 0.4rem 0.6rem;
        border-bottom: 1px solid rgba(255,255,255,0.2);
    }

    .campaign-thumbnail {
        width: 40px;
        height: 40px;
        object-fit: cover;
        border-radius: 4px;
        border: 2px solid rgba(255,255,255,0.3);
        flex-shrink: 0;
    }

    .campaign-details {
        flex: 1;
    }

    .campaign-details h1 {
        margin: 0 0 0.1rem 0;
        font-size: 1rem;
    }

    .campaign-details .description {
        margin: 0;
        opacity: 0.9;
        font-size: 0.7rem;
        line-height: 1.2;
    }

    .game-status-row {
        display: grid;
        grid-template-columns: repeat(4, 1fr);
        gap: 0.4rem;
        padding: 0.4rem 0.6rem;
        background: rgba(0,0,0,0.1);
    }

    .status-item {
        display: flex;
        flex-direction: column;
        gap: 0.1rem;
    }

    .status-label {
        font-size: 0.65rem;
        opacity: 0.8;
        text-transform: uppercase;
        letter-spacing: 0.3px;
    }

    .status-value {
        font-size: 0.8rem;
        font-weight: bold;
    }

    /* ===================================
       Main Game Container
       =================================== */
    .game-container {
        display: flex;
        flex: 1;
        overflow: hidden;
        position: relative;
    }

    /* ===================================
       Slide-out Drawers - RPG Fantasy Theme
       =================================== */
    .drawer {
        background: linear-gradient(180deg, #16213e 0%, #1a1a2e 100%); /* RPG dark gradient */
        color: #e0e0e0; /* Light text */
        box-shadow: 4px 0 12px rgba(0, 0, 0, 0.5);
        transition: transform 0.3s ease-in-out;
        z-index: 110; /* Above header */
        display: flex;
        flex-direction: column;
        overflow: hidden;
    }

    .drawer-left {
        position: fixed;
        left: 0;
        top: 64px; /* Below main nav */
        bottom: 0;
        width: 320px;
        transform: translateX(-100%);
        border-right: 2px solid rgba(212, 175, 55, 0.2); /* RPG gold border */
    }

    .drawer-left.open {
        transform: translateX(0);
    }

    .drawer-left.anchored {
        position: fixed; /* Keep fixed, don't make it part of flex layout */
        transform: translateX(0);
        top: 64px; /* Below main nav */
    }

    .drawer-right {
        position: fixed;
        right: 0;
        top: 64px; /* Below main nav */
        bottom: 0;
        width: 320px;
        transform: translateX(100%);
        border-left: 2px solid rgba(212, 175, 55, 0.2); /* RPG gold border */
    }

    .drawer-right.open {
        transform: translateX(0);
    }

    .drawer-right.anchored {
        position: fixed; /* Keep fixed, don't make it part of flex layout */
        transform: translateX(0);
        top: 64px; /* Below main nav */
    }

    /* Second Right Drawer (Campaign Progress) */
    .drawer-right-progress {
        position: fixed;
        right: 0;
        top: 64px; /* Below main nav */
        bottom: 0;
        width: 320px;
        transform: translateX(100%);
        border-left: 2px solid rgba(212, 175, 55, 0.2); /* RPG gold border */
    }

    .drawer-right-progress.open {
        transform: translateX(0);
    }

    .drawer-right-progress.anchored {
        position: fixed;
        transform: translateX(0);
        top: 64px;
    }

    /* When Journey drawer is also anchored, offset Progress drawer to the left */
    .drawer-right.anchored ~ .drawer-right-progress.anchored {
        right: 320px; /* Position to the left of Journey drawer */
    }

    .drawer-right-progress .drawer-header {
        background: linear-gradient(135deg, #2d1b69 0%, #1a1a2e 100%);
    }

    .drawer-header {
        background: linear-gradient(135deg, #2d1b69 0%, #1a1a2e 100%); /* RPG purple gradient */
        color: white;
        padding: 0.6rem 0.8rem;
        display: flex;
        justify-content: space-between;
        align-items: center;
        flex-shrink: 0;
        border-bottom: 2px solid #d4af37; /* RPG gold border */
        box-shadow: 0 2px 8px rgba(212, 175, 55, 0.3);
    }

    .drawer-left .drawer-header {
        background: linear-gradient(135deg, #2d1b69 0%, #1a1a2e 100%); /* RPG purple gradient */
    }

    .drawer-right .drawer-header {
        background: linear-gradient(135deg, #2d1b69 0%, #1a1a2e 100%); /* RPG purple gradient */
    }

    .drawer-header h3 {
        margin: 0;
        font-size: 0.95rem;
        color: #d4af37; /* RPG gold */
        text-shadow: 0 0 10px rgba(212, 175, 55, 0.5);
        font-weight: 700;
        letter-spacing: 0.5px;
    }

    .drawer-controls {
        display: flex;
        gap: 0.5rem;
    }

    .drawer-btn {
        background: rgba(255, 255, 255, 0.2);
        border: 1px solid rgba(255, 255, 255, 0.3);
        color: white;
        cursor: pointer;
        padding: 0.25rem 0.5rem;
        border-radius: 4px;
        font-size: 1rem;
        transition: all 0.2s;
    }

    .drawer-btn:hover {
        background: rgba(255, 255, 255, 0.3);
    }

    .drawer-content {
        flex: 1;
        overflow-y: auto;
        padding: 0.6rem;
        background: linear-gradient(180deg, #16213e 0%, #1a1a2e 100%); /* RPG dark gradient */
    }

    .drawer-content h3 {
        color: #d4af37; /* RPG gold */
        font-size: 1rem;
        font-weight: bold;
        margin: 0 0 0.6rem 0;
        text-shadow: 0 0 10px rgba(212, 175, 55, 0.3);
    }

    .drawer-content h4 {
        color: #c0c0c0; /* RPG silver */
        font-size: 0.85rem;
        font-weight: bold;
        margin: 0.6rem 0 0.3rem 0;
        letter-spacing: 0.3px;
    }

    .drawer-content p {
        color: #b8b8d1;
    }

    .drawer-content hr {
        border-color: rgba(212, 175, 55, 0.2); /* RPG gold border */
    }

    /* Drawer content scrollbar - RPG themed */
    .drawer-content::-webkit-scrollbar {
        width: 12px;
    }

    .drawer-content::-webkit-scrollbar-track {
        background: #0f0f1e; /* RPG darker */
    }

    .drawer-content::-webkit-scrollbar-thumb {
        background: linear-gradient(180deg, #d4af37 0%, #cd7f32 100%); /* Gold to bronze */
        border-radius: 6px;
        border: 2px solid #0f0f1e;
    }

    .drawer-content::-webkit-scrollbar-thumb:hover {
        background: #d4af37; /* Pure gold on hover */
    }

    /* ===================================
       Drawer Toggle Buttons
       =================================== */
    .drawer-toggle {
        position: fixed;
        top: 50%;
        transform: translateY(-50%);
        background: #667eea;
        color: white;
        border: none;
        padding: 1rem 0.5rem;
        cursor: pointer;
        z-index: 85;
        border-radius: 0 8px 8px 0;
        font-size: 1rem;
        transition: all 0.2s;
        box-shadow: 2px 0 8px rgba(0,0,0,0.2);
    }

    .drawer-toggle:hover {
        background: #5a67d8;
        transform: translateY(-50%) scale(1.05);
    }

    .drawer-toggle-left {
        left: 0;
    }

    .drawer-toggle-left.hidden {
        left: 320px;
    }

    .drawer-toggle-right {
        right: 0;
        border-radius: 8px 0 0 8px;
        box-shadow: -2px 0 8px rgba(0,0,0,0.2);
    }

    .drawer-toggle-right.hidden {
        right: 320px;
    }

    /* Stack right drawer toggles vertically */
    .drawer-toggle-right-journey {
        right: 0;
        border-radius: 8px 0 0 8px;
        box-shadow: -2px 0 8px rgba(0,0,0,0.2);
        top: calc(50% - 60px); /* Offset up */
        z-index: 150; /* Above drawers (drawers are z-index: 110) */
    }

    .drawer-toggle-right-journey.hidden {
        right: 320px;
    }

    .drawer-toggle-right-progress {
        right: 0;
        border-radius: 8px 0 0 8px;
        box-shadow: -2px 0 8px rgba(0,0,0,0.2);
        top: calc(50% + 10px); /* Offset down */
        z-index: 150; /* Above drawers (drawers are z-index: 110) */
    }

    .drawer-toggle-right-progress.hidden {
        right: 320px;
    }

    /* ===================================
       Tile-Based Grid System
       =================================== */
    .game-grid {
        flex: 1;
        display: grid;
        grid-template-columns: 9fr 11fr;
        grid-template-rows: 1fr;
        gap: 0.75rem;
        padding: 0.75rem 0.75rem 1rem 0.75rem;
        overflow: hidden;
        transition: margin 0.3s ease-in-out, width 0.3s ease-in-out;
        box-sizing: border-box;
        max-width: 100%;
        height: 100%;
        min-height: 0;
    }

    .game-grid.left-anchored {
        margin-left: 320px;
        width: calc(100% - 320px);
    }

    .game-grid.right-anchored {
        margin-right: 320px;
        width: calc(100% - 320px);
    }

    /* Grid Tiles */
    .grid-tile {
        background: white;
        border-radius: 8px;
        box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        overflow: hidden;
        display: flex;
        flex-direction: column;
        min-width: 0; /* Allow content to shrink */
        min-height: 0; /* Allow content to shrink */
        box-sizing: border-box;
    }

    /* Chat Section - Left Side (40% width, 100% height) */
    .tile-chat {
        grid-column: 1;
        grid-row: 1 / -1;
        min-width: 0;
        overflow: hidden;
        border: 2px solid #e2e8f0;
    }

    /* Right Column Container */
    .right-column {
        grid-column: 2;
        grid-row: 1;
        display: grid;
        grid-template-rows: 50% 50%;
        gap: 0.75rem;
        min-width: 0;
        min-height: 0;
        overflow: hidden;
        height: 100%;
    }

    /* Map/Images Section - Right Side Bottom (50% height) */
    .tile-map {
        grid-row: 2;
        min-width: 0;
        overflow: hidden;
        background: white;
        border: 2px solid #e2e8f0;
        border-radius: 8px;
    }

    /* Info Sections Container */
    .info-sections {
        grid-row: 1;
        display: flex;
        height: 100%;
        overflow: hidden;
    }

    /* Info Panel (Tabbed Section) */
    .tile-info {
        width: 100%;
        height: 100%;
    }

    .info-panel {
        display: flex;
        flex-direction: column;
        height: 100%;
        background: white;
        border-radius: 8px;
        border: 2px solid #e2e8f0;
        box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        overflow: hidden;
        box-sizing: border-box;
    }

    .info-header {
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        color: white;
        padding: 0.5rem 0.75rem;
        font-weight: bold;
        font-size: 0.85rem;
        flex-shrink: 0;
        border-bottom: 2px solid rgba(212, 175, 55, 0.3);
        display: flex;
        align-items: center;
        justify-content: space-between;
    }

    .info-header span {
        overflow: hidden;
        text-overflow: ellipsis;
    }

    .info-toolbar {
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        display: flex;
        flex-direction: row;
        gap: 0.25rem;
        padding: 0.5rem 0.5rem 0 0.5rem;
        flex-shrink: 0;
    }

    .info-toolbar-btn {
        background: rgba(255, 255, 255, 0.15);
        border: none;
        border-bottom: 3px solid transparent;
        color: rgba(255, 255, 255, 0.7);
        padding: 0.6rem 1.2rem;
        border-radius: 0;
        font-size: 0.85rem;
        font-weight: 600;
        cursor: pointer;
        transition: all 0.2s ease;
        text-align: center;
        white-space: nowrap;
        position: relative;
    }

    .info-toolbar-btn:hover {
        background: rgba(255, 255, 255, 0.25);
        color: rgba(255, 255, 255, 0.95);
    }

    .info-toolbar-btn.active {
        background: #f7fafc;
        color: #4a5568;
        border-bottom: 3px solid #d4af37;
        font-weight: 700;
    }

    .tab-count {
        font-size: 0.75rem;
        opacity: 0.7;
        margin-left: 4px;
    }

    .info-content {
        flex: 1;
        overflow: visible;
        position: relative;
        background: #f7fafc;
        min-height: 0;
    }

    .info-tab {
        display: none;
        height: 100%;
    }

    .info-tab.active {
        display: flex;
        flex-direction: column;
        height: 100%;
        overflow: visible;
    }

    .info-tab-content {
        flex: 1;
        overflow-y: auto;
        padding: 0.6rem;
        font-size: 0.85rem;
        color: #4a5568;
        text-align: left;
    }

    /* When both drawers anchored, adjust main content */
    .game-grid.both-anchored {
        margin-left: 320px;
        margin-right: 320px;
        width: calc(100% - 640px);
    }

    /* When both right drawers are anchored */
    .game-grid.both-right-anchored {
        margin-right: 640px;
        width: calc(100% - 640px);
    }

    /* When left drawer + both right drawers are anchored */
    .game-grid.left-anchored.both-right-anchored {
        margin-left: 320px;
        margin-right: 640px;
        width: calc(100% - 960px);
    }

    /* ===================================
       Map/Images Panel
       =================================== */
    .map-panel {
        display: flex;
        flex-direction: column;
        height: 100%;
        width: 100%;
        overflow: hidden;
        color: white;
        box-sizing: border-box;
    }

    .map-header {
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        color: white;
        padding: 0.5rem 0.75rem;
        font-weight: bold;
        font-size: 0.85rem;
        flex-shrink: 0;
        display: flex;
        align-items: center;
        justify-content: space-between;
        border-bottom: 2px solid rgba(212, 175, 55, 0.3);
        border-top-left-radius: 8px;
        border-top-right-radius: 8px;
        box-sizing: border-box;
        overflow: hidden;
        white-space: nowrap;
        text-overflow: ellipsis;
    }

    .map-toolbar {
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        display: flex;
        flex-direction: row;
        gap: 0.5rem;
        padding: 0.5rem 0.75rem;
        border-bottom: 2px solid rgba(212, 175, 55, 0.3);
        flex-shrink: 0;
    }

    .map-toolbar-btn {
        background: rgba(255, 255, 255, 0.2);
        border: 2px solid rgba(255, 255, 255, 0.3);
        color: white;
        padding: 0.4rem 0.75rem;
        border-radius: 4px;
        cursor: pointer;
        font-size: 0.75rem;
        font-weight: 600;
        transition: all 0.2s;
        text-align: center;
        white-space: nowrap;
    }

    .map-toolbar-btn:hover {
        background: rgba(255, 255, 255, 0.35);
        transform: translateY(-2px);
    }

    .map-toolbar-btn.active {
        background: rgba(255, 255, 255, 0.4);
        border-color: #d4af37;
        box-shadow: 0 0 10px rgba(212, 175, 55, 0.5);
    }

    .map-content {
        flex: 1;
        overflow: auto;
        padding: 1rem;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        background: #f7fafc;
        border-bottom-left-radius: 8px;
        border-bottom-right-radius: 8px;
    }

    .map-placeholder {
        width: 100%;
        height: 100%;
        display: flex;
        align-items: center;
        justify-content: center;
        flex-direction: column;
        gap: 1rem;
        color: #a0aec0;
        font-size: 1.2rem;
        font-style: italic;
    }

    .map-placeholder-icon {
        font-size: 4rem;
    }

    /* ===================================
       Image Carousel
       =================================== */
    .image-carousel {
        width: 100%;
        height: 100%;
        display: flex;
        flex-direction: column;
        position: relative;
    }

    .carousel-main {
        flex: 1;
        display: flex;
        align-items: center;
        justify-content: center;
        position: relative;
        overflow: hidden;
        background: #2d3748;
    }

    .carousel-image {
        max-width: 100%;
        max-height: 100%;
        object-fit: contain;
        border-radius: 4px;
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
        cursor: pointer;
        transition: opacity 0.2s;
    }

    .carousel-image:hover {
        opacity: 0.9;
    }

    .carousel-nav {
        position: absolute;
        top: 50%;
        transform: translateY(-50%);
        background: rgba(0, 0, 0, 0.5);
        color: white;
        border: 2px solid rgba(255, 255, 255, 0.3);
        padding: 1rem 0.75rem;
        cursor: pointer;
        font-size: 1.5rem;
        border-radius: 4px;
        transition: all 0.2s;
        z-index: 10;
    }

    .carousel-nav:hover {
        background: rgba(0, 0, 0, 0.7);
        transform: translateY(-50%) scale(1.1);
    }

    .carousel-nav:disabled {
        opacity: 0.3;
        cursor: not-allowed;
    }

    .carousel-nav:disabled:hover {
        transform: translateY(-50%);
    }

    .carousel-nav-prev {
        left: 1rem;
    }

    .carousel-nav-next {
        right: 1rem;
    }

    .carousel-info {
        padding: 0.75rem 1rem;
        background: linear-gradient(135deg, #2d3748 0%, #1a202c 100%);
        color: white;
        display: flex;
        justify-content: space-between;
        align-items: center;
        border-top: 2px solid rgba(212, 175, 55, 0.3);
    }

    .carousel-title {
        font-size: 0.9rem;
        font-weight: 600;
        color: #d4af37;
    }

    .carousel-counter {
        font-size: 0.8rem;
        color: #a0aec0;
    }

    .carousel-thumbnails {
        display: flex;
        gap: 0.5rem;
        padding: 0.75rem 1rem;
        background: #1a202c;
        overflow-x: auto;
        border-top: 1px solid rgba(255, 255, 255, 0.1);
    }

    .carousel-thumbnail {
        width: 60px;
        height: 60px;
        object-fit: cover;
        border-radius: 4px;
        cursor: pointer;
        border: 2px solid transparent;
        transition: all 0.2s;
        flex-shrink: 0;
    }

    .carousel-thumbnail:hover {
        border-color: rgba(212, 175, 55, 0.5);
        transform: scale(1.05);
    }

    .carousel-thumbnail.active {
        border-color: #d4af37;
        box-shadow: 0 0 10px rgba(212, 175, 55, 0.5);
    }

    .carousel-loading {
        display: flex;
        align-items: center;
        justify-content: center;
        width: 100%;
        height: 100%;
        color: #a0aec0;
        font-size: 1rem;
    }

    .carousel-loading::after {
        content: '';
        width: 40px;
        height: 40px;
        margin-left: 1rem;
        border: 4px solid #e2e8f0;
        border-top-color: #667eea;
        border-radius: 50%;
        animation: spin 1s linear infinite;
    }

    @keyframes spin {
        to { transform: rotate(360deg); }
    }

    /* ===================================
       Image Lightbox Modal
       =================================== */
    .image-lightbox {
        display: none;
        position: fixed;
        z-index: 9999;
        left: 0;
        top: 0;
        width: 100%;
        height: 100%;
        background-color: rgba(0, 0, 0, 0.95);
        animation: fadeIn 0.2s;
    }

    .image-lightbox.active {
        display: flex;
        align-items: center;
        justify-content: center;
    }

    .lightbox-content {
        position: relative;
        max-width: 85%;
        max-height: 85%;
        animation: zoomIn 0.3s;
    }

    .lightbox-image {
        max-width: 100%;
        max-height: 80vh;
        object-fit: contain;
        border-radius: 8px;
        box-shadow: 0 8px 32px rgba(0, 0, 0, 0.8);
    }

    .lightbox-close {
        position: absolute;
        top: -40px;
        right: 0;
        color: white;
        font-size: 35px;
        font-weight: bold;
        cursor: pointer;
        background: none;
        border: none;
        padding: 0 10px;
        transition: color 0.2s;
    }

    .lightbox-close:hover,
    .lightbox-close:focus {
        color: #d4af37;
        text-decoration: none;
    }

    .lightbox-title {
        position: absolute;
        bottom: -35px;
        left: 0;
        right: 0;
        color: white;
        text-align: center;
        font-size: 1.1rem;
        font-weight: 500;
        text-shadow: 0 2px 4px rgba(0, 0, 0, 0.8);
    }

    @keyframes fadeIn {
        from { opacity: 0; }
        to { opacity: 1; }
    }

    @keyframes zoomIn {
        from { transform: scale(0.8); opacity: 0; }
        to { transform: scale(1); opacity: 1; }
    }

    /* ===================================
       Chat Panel (Main Game Narrative)
       =================================== */
    .chat-panel {
        display: flex;
        flex-direction: column;
        height: 100%;
        overflow: hidden;
    }

    .chat-header {
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        color: white;
        padding: 0.5rem 0.75rem;
        font-weight: bold;
        font-size: 0.85rem;
        flex-shrink: 0;
        display: flex;
        align-items: center;
        justify-content: space-between;
        border-bottom: 2px solid rgba(212, 175, 55, 0.3);
        border-top-left-radius: 8px;
        border-top-right-radius: 8px;
    }

    .chat-messages {
        flex: 1;
        overflow-y: auto;
        padding: 0.6rem;
        background: #f7fafc;
    }

    .chat-message {
        margin-bottom: 0.6rem;
        animation: fadeIn 0.3s;
    }

    @keyframes fadeIn {
        from { opacity: 0; transform: translateY(10px); }
        to { opacity: 1; transform: translateY(0); }
    }

    .message-dm {
        background: #edf2f7;
        border-left: 4px solid #667eea;
        padding: 0.5rem 0.7rem;
        border-radius: 4px;
    }

    .message-player {
        background: #e6fffa;
        border-left: 4px solid #38b2ac;
        padding: 0.5rem 0.7rem;
        border-radius: 4px;
    }

    .message-npc {
        background: #fffaf0;
        border-left: 4px solid #ed8936;
        padding: 0.5rem 0.7rem;
        border-radius: 4px;
    }

    .message-assessment {
        background: #fef5e7;
        border-left: 4px solid #f6ad55;
        padding: 0.5rem 0.7rem;
        border-radius: 4px;
    }

    .message-sender {
        font-weight: bold;
        margin-bottom: 0.2rem;
        color: #2d3748;
        font-size: 0.8rem;
    }

    .message-content {
        color: #4a5568;
        line-height: 1.5;
        word-wrap: break-word;
        font-size: 0.85rem;
    }

    .message-time {
        font-size: 0.7rem;
        color: #a0aec0;
        margin-top: 0.3rem;
    }

    .chat-input-container {
        padding: 0.6rem;
        background: white;
        border-top: 1px solid #e2e8f0;
        flex-shrink: 0;
    }

    .action-opportunities {
        padding: 0.8rem;
        margin-bottom: 0.6rem;
        background: linear-gradient(135deg, rgba(102, 126, 234, 0.1), rgba(118, 75, 162, 0.1));
        border: 2px solid #667eea;
        border-radius: 8px;
        animation: slideDown 0.3s ease-out;
    }

    @keyframes slideDown {
        from {
            opacity: 0;
            transform: translateY(-10px);
        }
        to {
            opacity: 1;
            transform: translateY(0);
        }
    }

    .action-opportunities-header {
        font-size: 0.85rem;
        font-weight: 600;
        color: #667eea;
        margin-bottom: 0.6rem;
        display: flex;
        align-items: center;
        gap: 0.4rem;
    }

    .opportunity-group {
        margin-bottom: 0.6rem;
    }

    .opportunity-group:last-child {
        margin-bottom: 0;
    }

    .opportunity-group-title {
        font-size: 0.75rem;
        font-weight: 600;
        color: #4a5568;
        margin-bottom: 0.4rem;
        text-transform: uppercase;
        letter-spacing: 0.5px;
    }

    .opportunity-buttons {
        display: flex;
        flex-wrap: wrap;
        gap: 0.4rem;
    }

    .opportunity-btn {
        padding: 0.5rem 0.8rem;
        background: white;
        color: #667eea;
        border: 1.5px solid #667eea;
        border-radius: 6px;
        cursor: pointer;
        font-size: 0.85rem;
        font-weight: 500;
        transition: all 0.2s;
        white-space: normal;
        word-wrap: break-word;
        max-width: 200px;
        line-height: 1.3;
    }

    .opportunity-btn:hover {
        background: #667eea;
        color: white;
        transform: translateY(-1px);
        box-shadow: 0 2px 8px rgba(102, 126, 234, 0.3);
    }

    .opportunity-btn.npc {
        border-color: #48bb78;
        color: #48bb78;
    }

    .opportunity-btn.npc:hover {
        background: #48bb78;
        color: white;
    }

    .opportunity-btn.item {
        border-color: #ed64a6;
        color: #ed64a6;
    }

    .opportunity-btn.item:hover {
        background: #ed64a6;
        color: white;
    }

    .opportunity-btn.discovery {
        border-color: #f6ad55;
        color: #f6ad55;
    }

    .opportunity-btn.discovery:hover {
        background: #f6ad55;
        color: white;
    }

    /* ===================================
       Investigate Scene Panel Styles
       =================================== */
    .investigate-scene-button {
        padding: 0.6rem 1rem;
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        color: white;
        border: none;
        border-radius: 6px;
        cursor: pointer;
        font-size: 0.9rem;
        font-weight: 600;
        transition: all 0.2s;
        display: flex;
        align-items: center;
        gap: 0.4rem;
    }

    .investigate-scene-button:hover:not(:disabled) {
        transform: translateY(-2px);
        box-shadow: 0 4px 12px rgba(102, 126, 234, 0.4);
    }

    .investigate-scene-button:disabled {
        opacity: 0.5;
        cursor: not-allowed;
    }

    .investigate-panel-overlay {
        position: fixed;
        top: 0;
        left: 0;
        width: 100vw;
        height: 100vh;
        background: rgba(0, 0, 0, 0.6);
        z-index: 9999;
        display: flex;
        align-items: center;
        justify-content: center;
        animation: fadeIn 0.2s ease-out;
    }

    @keyframes fadeIn {
        from {
            opacity: 0;
        }
        to {
            opacity: 1;
        }
    }

    .investigate-panel {
        background: white;
        border-radius: 12px;
        width: 90%;
        max-width: 700px;
        max-height: 85vh;
        display: flex;
        flex-direction: column;
        box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
        animation: slideUp 0.3s ease-out;
    }

    @keyframes slideUp {
        from {
            transform: translateY(20px);
            opacity: 0;
        }
        to {
            transform: translateY(0);
            opacity: 1;
        }
    }

    .investigate-panel-header {
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        color: white;
        padding: 1.2rem 1.5rem;
        border-radius: 12px 12px 0 0;
        display: flex;
        align-items: center;
        justify-content: space-between;
    }

    .investigate-panel-header h2 {
        margin: 0;
        font-size: 1.4rem;
        font-weight: 600;
    }

    .panel-close-btn {
        background: rgba(255, 255, 255, 0.2);
        color: white;
        border: none;
        width: 36px;
        height: 36px;
        border-radius: 50%;
        cursor: pointer;
        font-size: 1.5rem;
        line-height: 1;
        transition: all 0.2s;
        display: flex;
        align-items: center;
        justify-content: center;
    }

    .panel-close-btn:hover {
        background: rgba(255, 255, 255, 0.3);
        transform: rotate(90deg);
    }

    .investigate-panel-content {
        flex: 1;
        overflow-y: auto;
        padding: 1rem;
    }

    .investigate-section {
        margin-bottom: 0.8rem;
        border: 2px solid #e2e8f0;
        border-radius: 8px;
        overflow: hidden;
        transition: all 0.2s;
    }

    .investigate-section:hover {
        border-color: #cbd5e0;
    }

    .investigate-section-header {
        background: #f7fafc;
        padding: 0.9rem 1rem;
        display: flex;
        align-items: center;
        gap: 0.75rem;
        cursor: pointer;
        user-select: none;
        transition: background 0.2s;
    }

    .investigate-section-header:hover {
        background: #edf2f7;
    }

    .section-icon {
        font-size: 1.3rem;
    }

    .section-title {
        flex: 1;
        font-weight: 600;
        font-size: 1rem;
        color: #2d3748;
    }

    .section-count {
        background: #667eea;
        color: white;
        padding: 0.2rem 0.6rem;
        border-radius: 12px;
        font-size: 0.75rem;
        font-weight: 600;
        min-width: 24px;
        text-align: center;
    }

    .section-toggle {
        color: #718096;
        font-size: 0.9rem;
        transition: transform 0.3s;
    }

    .investigate-section.collapsed .section-toggle {
        transform: rotate(-90deg);
    }

    .investigate-section-body {
        padding: 1rem;
        background: white;
        max-height: 400px;
        overflow-y: auto;
    }

    .investigate-section.collapsed .investigate-section-body {
        display: none;
    }

    .empty-state {
        color: #a0aec0;
        font-style: italic;
        text-align: center;
        padding: 1rem;
    }

    .entity-item {
        background: #f7fafc;
        border: 1px solid #e2e8f0;
        border-radius: 6px;
        padding: 0.9rem;
        margin-bottom: 0.6rem;
        transition: all 0.2s;
    }

    .entity-item:last-child {
        margin-bottom: 0;
    }

    .entity-item:hover {
        background: #edf2f7;
        border-color: #cbd5e0;
        transform: translateX(4px);
    }

    .entity-item.completed {
        background: #f0fdf4;
        border-color: #86efac;
        opacity: 0.85;
    }

    .entity-item.completed:hover {
        background: #dcfce7;
        border-color: #4ade80;
        opacity: 1;
    }

    .entity-item.completed .entity-name::after {
        content: ' ✓';
        color: #22c55e;
        font-weight: bold;
        margin-left: 0.5rem;
    }

    .entity-item.completed .entity-action-btn {
        opacity: 0.6;
        pointer-events: none;
    }

    .entity-header {
        display: flex;
        align-items: start;
        gap: 0.75rem;
        margin-bottom: 0.6rem;
    }

    .entity-icon {
        font-size: 1.8rem;
        flex-shrink: 0;
    }

    .entity-info {
        flex: 1;
    }

    .entity-name {
        font-weight: 600;
        font-size: 1rem;
        color: #2d3748;
        margin-bottom: 0.3rem;
    }

    .entity-role,
    .entity-description {
        font-size: 0.85rem;
        color: #718096;
        margin-bottom: 0.3rem;
    }

    .entity-actions {
        display: flex;
        flex-wrap: wrap;
        gap: 0.4rem;
        margin-top: 0.6rem;
    }

    .entity-action-btn {
        padding: 0.4rem 0.8rem;
        background: white;
        color: #667eea;
        border: 1.5px solid #667eea;
        border-radius: 6px;
        cursor: pointer;
        font-size: 0.85rem;
        font-weight: 500;
        transition: all 0.2s;
    }

    .entity-action-btn:hover {
        background: #667eea;
        color: white;
        transform: translateY(-1px);
        box-shadow: 0 2px 8px rgba(102, 126, 234, 0.3);
    }

    .entity-action-btn.primary {
        background: #667eea;
        color: white;
    }

    .entity-action-btn.primary:hover {
        background: #5568d3;
    }

    /* ===================================
       Acquisition Notifications Styles
       =================================== */
    .acquisition-notifications {
        position: fixed;
        top: 80px;
        right: 20px;
        z-index: 10000;
        display: flex;
        flex-direction: column;
        gap: 0.75rem;
        max-width: 400px;
        pointer-events: none;
    }

    .acquisition-notification {
        background: white;
        border-radius: 12px;
        padding: 1rem 1.25rem;
        box-shadow: 0 8px 24px rgba(0, 0, 0, 0.15);
        border-left: 4px solid #667eea;
        animation: slideInRight 0.4s ease-out, fadeOut 0.4s ease-in 4.6s;
        pointer-events: auto;
        cursor: pointer;
        transition: transform 0.2s, box-shadow 0.2s;
        position: relative;
        overflow: hidden;
    }

    .acquisition-notification::before {
        content: '';
        position: absolute;
        bottom: 0;
        left: 0;
        height: 3px;
        background: linear-gradient(90deg, #667eea, #764ba2);
        animation: progressBar 5s linear;
        width: 100%;
    }

    @keyframes progressBar {
        from {
            width: 100%;
        }
        to {
            width: 0%;
        }
    }

    .acquisition-notification:hover {
        transform: translateX(-5px);
        box-shadow: 0 12px 32px rgba(0, 0, 0, 0.2);
    }

    @keyframes slideInRight {
        from {
            opacity: 0;
            transform: translateX(100px);
        }
        to {
            opacity: 1;
            transform: translateX(0);
        }
    }

    @keyframes fadeOut {
        from {
            opacity: 1;
        }
        to {
            opacity: 0;
        }
    }

    .acquisition-notification.knowledge {
        border-left-color: #3f51b5;
    }

    .acquisition-notification.item {
        border-left-color: #ed64a6;
    }

    .acquisition-notification.npc {
        border-left-color: #48bb78;
    }

    .acquisition-notification.discovery {
        border-left-color: #f6ad55;
    }

    .acquisition-notification.challenge {
        border-left-color: #9c27b0;
    }

    .notification-header {
        display: flex;
        align-items: center;
        gap: 0.75rem;
        margin-bottom: 0.5rem;
    }

    .notification-icon {
        font-size: 1.5rem;
        flex-shrink: 0;
    }

    .notification-title {
        flex: 1;
        font-weight: 600;
        font-size: 0.95rem;
        color: #2d3748;
    }

    .notification-type {
        font-size: 0.7rem;
        text-transform: uppercase;
        letter-spacing: 0.5px;
        color: #667eea;
        font-weight: 600;
    }

    .notification-type.knowledge {
        color: #3f51b5;
    }

    .notification-type.item {
        color: #ed64a6;
    }

    .notification-type.npc {
        color: #48bb78;
    }

    .notification-type.discovery {
        color: #f6ad55;
    }

    .notification-type.challenge {
        color: #9c27b0;
    }

    .notification-body {
        margin-left: 2.25rem;
    }

    .notification-description {
        font-size: 0.85rem;
        color: #4a5568;
        margin-bottom: 0.4rem;
        line-height: 1.4;
    }

    .notification-source {
        font-size: 0.75rem;
        color: #718096;
        font-style: italic;
        display: flex;
        align-items: center;
        gap: 0.3rem;
    }

    .notification-quest-link {
        margin-top: 0.5rem;
        padding: 0.4rem 0.6rem;
        background: linear-gradient(135deg, rgba(102, 126, 234, 0.1), rgba(118, 75, 162, 0.1));
        border: 1px solid #667eea;
        border-radius: 6px;
        font-size: 0.75rem;
        color: #667eea;
        display: flex;
        align-items: center;
        gap: 0.4rem;
        font-weight: 500;
    }

    .notification-progress {
        margin-left: auto;
        font-weight: 600;
    }

    .chat-input {
        width: 100%;
        padding: 0.6rem;
        border: 2px solid #e2e8f0;
        border-radius: 4px;
        font-size: 0.9rem;
        resize: none;
    }

    .chat-input:focus {
        outline: none;
        border-color: #667eea;
    }

    .input-controls {
        display: flex;
        gap: 0.4rem;
        margin-top: 0.4rem;
    }

    .mic-button {
        flex-shrink: 0;
        padding: 0.6rem;
        background: #667eea;
        color: white;
        border: none;
        border-radius: 4px;
        cursor: pointer;
        transition: background 0.2s;
        font-size: 0.9rem;
    }

    .mic-button:hover {
        background: #5a67d8;
    }

    .mic-button.recording {
        background: #f56565;
        animation: pulse 1.5s infinite;
    }

    .mic-button:disabled {
        background: #cbd5e0;
        cursor: not-allowed;
    }

    @keyframes pulse {
        0%, 100% { opacity: 1; }
        50% { opacity: 0.7; }
    }

    .send-button {
        flex: 1;
        padding: 0.6rem;
        background: #667eea;
        color: white;
        border: none;
        border-radius: 4px;
        font-weight: bold;
        cursor: pointer;
        transition: background 0.2s;
        font-size: 0.9rem;
    }

    .send-button:hover {
        background: #5a67d8;
    }

    .send-button:disabled {
        background: #cbd5e0;
        cursor: not-allowed;
    }

    /* ===================================
       Info Panel (Tabs)
       =================================== */
    .info-panel {
        display: flex;
        flex-direction: column;
        height: 100%;
        overflow: hidden;
    }

    .info-tabs {
        display: flex;
        background: #edf2f7;
        border-bottom: 2px solid #e2e8f0;
        flex-shrink: 0;
    }

    .info-tab {
        flex: 1;
        padding: 0.75rem 0.5rem;
        text-align: center;
        cursor: pointer;
        font-weight: bold;
        color: #4a5568;
        transition: all 0.2s;
        font-size: 0.85rem;
    }

    .info-tab.active {
        background: white;
        color: #667eea;
        border-bottom: 3px solid #667eea;
    }

    .info-tab:hover {
        background: #f7fafc;
    }


    .quest-objective {
        padding: 0.4rem 0.3rem;
        background: rgba(212, 175, 55, 0.15);
        border-radius: 4px;
        margin-bottom: 0.3rem;
        display: flex;
        align-items: center;
        color: #b8b8d1;
        border: 1px solid rgba(212, 175, 55, 0.3);
    }

    .quest-objective.completed {
        background: rgba(72, 187, 120, 0.2);
        border: 1px solid rgba(72, 187, 120, 0.4);
        text-decoration: line-through;
        opacity: 0.7;
    }

    .objective-checkbox {
        margin-right: 0.25rem;
        font-size: 1.2rem;
        align-self: flex-start;
        line-height: 1;
        margin-top: 0.1rem;
    }

    /* Quest Progress Bars */
    .quest-overall-progress {
        margin-bottom: 1rem;
        padding: 0.75rem;
        background: rgba(45, 55, 72, 0.5);
        border-radius: 6px;
        border: 1px solid rgba(212, 175, 55, 0.3);
    }

    .quest-overall-progress-label {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 0.5rem;
        color: #d4af37;
        font-size: 0.9rem;
        font-weight: 600;
    }

    .quest-overall-progress-percent {
        font-size: 1.1rem;
        color: #d4af37;
    }

    .objective-content {
        flex: 1;
        display: flex;
        flex-direction: column;
        gap: 0.3rem;
    }

    .objective-description {
        font-size: 0.9rem;
        color: #b8b8d1;
        display: flex;
        justify-content: space-between;
        align-items: center;
    }

    .objective-progress-percent {
        font-size: 0.85rem;
        font-weight: 600;
        margin-left: 0.5rem;
        white-space: nowrap;
    }

    .progress-bar-container {
        width: 100%;
        height: 8px;
        background: rgba(0, 0, 0, 0.3);
        border-radius: 4px;
        overflow: hidden;
        position: relative;
    }

    .progress-bar-fill {
        height: 100%;
        transition: width 0.5s ease, background-color 0.3s ease;
        border-radius: 4px;
        position: relative;
        overflow: hidden;
    }

    .progress-bar-fill::after {
        content: '';
        position: absolute;
        top: 0;
        left: 0;
        bottom: 0;
        right: 0;
        background: linear-gradient(
            90deg,
            transparent,
            rgba(255, 255, 255, 0.2),
            transparent
        );
        animation: shimmer 2s infinite;
    }

    @keyframes shimmer {
        0% { transform: translateX(-100%); }
        100% { transform: translateX(100%); }
    }

    /* Progress color states */
    .progress-low { background: linear-gradient(90deg, #e53e3e 0%, #fc8181 100%); }
    .progress-medium { background: linear-gradient(90deg, #d69e2e 0%, #ecc94b 100%); }
    .progress-high { background: linear-gradient(90deg, #38a169 0%, #68d391 100%); }
    .progress-complete { background: linear-gradient(90deg, #d4af37 0%, #f6e05e 100%); }

    /* Progress text colors */
    .text-low { color: #fc8181; }
    .text-medium { color: #ecc94b; }
    .text-high { color: #68d391; }
    .text-complete { color: #d4af37; }

    .character-stat {
        display: flex;
        justify-content: space-between;
        padding: 0.35rem 0.4rem;
        border-bottom: 1px solid rgba(212, 175, 55, 0.2); /* RPG gold border */
        transition: all 0.3s ease;
    }

    .character-stat:hover {
        background: linear-gradient(90deg, rgba(212, 175, 55, 0.1) 0%, transparent 100%);
    }

    .stat-label {
        font-weight: 600;
        color: #b8b8d1;
        font-size: 0.85rem;
    }

    .stat-value {
        color: #d4af37 !important; /* RPG gold */
        font-size: 0.8rem !important;
        font-weight: 600 !important;
        text-shadow: 0 0 10px rgba(212, 175, 55, 0.5);
    }

    .available-actions {
        margin-top: 1rem;
    }

    .action-button {
        display: block;
        width: 100%;
        padding: 0.5rem;
        margin-bottom: 0.3rem;
        background: #f7fafc;
        border: 2px solid #e2e8f0;
        border-radius: 4px;
        cursor: pointer;
        transition: all 0.2s;
        font-size: 0.85rem;
    }

    .action-button:hover {
        background: #edf2f7;
        border-color: #667eea;
    }

    /* ===================================
       Connection Status
       =================================== */
    .connection-status {
        position: fixed;
        top: 74px; /* Position below main nav (64px) + small gap */
        right: 20px;
        padding: 0.5rem 1rem;
        background: #48bb78;
        color: white;
        border-radius: 4px;
        font-size: 0.875rem;
        z-index: 150; /* Above game header */
    }

    .connection-status.disconnected {
        background: #f56565;
    }

    .typing-indicator {
        padding: 1rem;
        color: #a0aec0;
        font-style: italic;
        font-size: 0.875rem;
    }

    /* ===================================
       TTS/STT Controls
       =================================== */
    .tts-controls {
        display: flex;
        gap: 0.5rem;
    }

    .tts-button, .stt-button {
        padding: 0.3rem 0.6rem;
        background: rgba(255, 255, 255, 0.2);
        color: white;
        border: 2px solid rgba(255, 255, 255, 0.3);
        border-radius: 4px;
        cursor: pointer;
        font-size: 0.75rem;
        transition: all 0.2s;
        display: flex;
        align-items: center;
        gap: 0.2rem;
    }

    .tts-button:hover, .stt-button:hover {
        background: rgba(255, 255, 255, 0.3);
    }

    .tts-button.playing {
        background: #48bb78;
        border-color: #48bb78;
    }

    .stt-button.recording {
        background: #f56565;
        border-color: #f56565;
        animation: pulse 1.5s infinite;
    }

    .message-tts-button {
        display: inline-flex;
        align-items: center;
        gap: 0.25rem;
        padding: 0.25rem 0.5rem;
        background: #e2e8f0;
        color: #4a5568;
        border: none;
        border-radius: 4px;
        cursor: pointer;
        font-size: 0.75rem;
        margin-left: 0.5rem;
        transition: all 0.2s;
    }

    .message-tts-button:hover {
        background: #cbd5e0;
    }

    .message-tts-button.playing {
        background: #48bb78;
        color: white;
    }

    /* ===================================
       Settings Modal
       =================================== */
    .settings-modal {
        display: none;
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0, 0, 0, 0.5);
        z-index: 2000;
        justify-content: center;
        align-items: center;
    }

    .settings-modal.show {
        display: flex;
    }

    .settings-content {
        background: white;
        padding: 2rem;
        border-radius: 8px;
        max-width: 500px;
        width: 90%;
    }

    .settings-option {
        margin-bottom: 1.5rem;
    }

    .settings-option label {
        display: block;
        font-weight: bold;
        margin-bottom: 0.5rem;
        color: #2d3748;
    }

    .settings-option select,
    .settings-option input[type="range"] {
        width: 100%;
        padding: 0.5rem;
        border: 2px solid #e2e8f0;
        border-radius: 4px;
        font-size: 1rem;
    }

    .settings-buttons {
        display: flex;
        gap: 1rem;
        margin-top: 2rem;
    }

    .settings-buttons button {
        flex: 1;
        padding: 0.75rem;
        border: none;
        border-radius: 4px;
        font-weight: bold;
        cursor: pointer;
        transition: all 0.2s;
    }

    .save-settings {
        background: #667eea;
        color: white;
    }

    .save-settings:hover {
        background: #5a67d8;
    }

    .cancel-settings {
        background: #e2e8f0;
        color: #4a5568;
    }

    .cancel-settings:hover {
        background: #cbd5e0;
    }

    /* ===================================
       Responsive Design
       =================================== */
    @media (max-width: 1200px) {
        .drawer-left, .drawer-right {
            width: 280px;
        }

        .drawer-toggle-left.hidden {
            left: 280px;
        }

        .drawer-toggle-right.hidden {
            right: 280px;
        }

        .game-grid.left-anchored {
            margin-left: 280px;
            width: calc(100% - 280px);
        }

        .game-grid.right-anchored {
            margin-right: 280px;
            width: calc(100% - 280px);
        }

        .game-grid.both-anchored {
            margin-left: 280px;
            margin-right: 280px;
            width: calc(100% - 560px);
        }

        .game-header.left-condensed {
            margin-left: calc(280px + 1rem);
            width: calc(100% - 280px - 2rem);
        }

        .game-header.right-condensed {
            margin-right: calc(280px + 1rem);
            width: calc(100% - 280px - 2rem);
        }

        .game-header.both-condensed {
            margin-left: calc(280px + 1rem);
            margin-right: calc(280px + 1rem);
            width: calc(100% - 560px - 2rem);
        }
    }

    @media (max-width: 768px) {
        .drawer-left, .drawer-right {
            width: 100%;
            max-width: 320px;
        }

        .drawer-left.anchored,
        .drawer-right.anchored {
            position: fixed;
        }

        .game-grid.left-anchored,
        .game-grid.right-anchored,
        .game-grid.both-anchored {
            margin-left: 0;
            margin-right: 0;
        }

        .game-grid {
            grid-template-columns: 1fr;
            grid-template-rows: 60% 40%;
        }

        .tile-chat {
            grid-column: 1;
            grid-row: 2;
        }

        .tile-map {
            grid-column: 1;
            grid-row: 1;
        }
    }

    .info-content h3 {
        font-size: 1.3rem;
        font-weight: bold;
        color: #2d3748;
        margin: 0 0 1rem 0;
    }

    .info-content h4 {
        font-size: 1rem;
        font-weight: bold;
        color: #4a5568;
        margin: 1rem 0 0.5rem 0;
    }

    /* ===================================
       Objectives Sidebar Styles
       =================================== */
    .objectives-panel.collapsed {
        right: -330px !important;
    }

    .objectives-panel::-webkit-scrollbar {
        width: 8px;
    }

    .objectives-panel::-webkit-scrollbar-track {
        background: rgba(255, 255, 255, 0.1);
        border-radius: 4px;
    }

    .objectives-panel::-webkit-scrollbar-thumb {
        background: rgba(106, 90, 205, 0.5);
        border-radius: 4px;
    }

    .objectives-panel::-webkit-scrollbar-thumb:hover {
        background: rgba(106, 90, 205, 0.7);
    }

    @keyframes pulse {
        0% { transform: scale(1); }
        50% { transform: scale(1.05); }
        100% { transform: scale(1); }
    }

    .objective-completed-animation {
        animation: pulse 0.5s ease-in-out;
    }
</style>
{% endblock %}

{% block content %}
<!-- Save/Load Component -->
{% include 'game/components/save_load.html' %}

<div class="game-wrapper">
    <!-- Header (unchanged) -->
    <div class="game-header">
        <div class="campaign-info-row">
            {% if campaign.primary_image_url %}
            <img src="{{ campaign.primary_image_url }}" alt="{{ campaign.title }}" class="campaign-thumbnail">
            {% elif campaign.campaign_images %}
            <img src="{{ campaign.campaign_images.0.url }}" alt="{{ campaign.title }}" class="campaign-thumbnail">
            {% else %}
            <div class="campaign-thumbnail" style="background: linear-gradient(135deg, #4a5568 0%, #2d3748 100%); display: flex; align-items: center; justify-content: center; font-size: 2rem;">
                🎲
            </div>
            {% endif %}
            <div class="campaign-details">
                <h1>{{ campaign.title }}</h1>
                <p class="description">{{ campaign.description|truncatewords:20|default:"Embark on an epic adventure in this AI-powered campaign!" }}</p>
            </div>
            <div style="display: flex; align-items: center; gap: 0.75rem;">
                <!-- Hidden for now -->
                <button onclick="openSaveLoadModal()" style="
                    display: none;
                    padding: 0.6rem 1.2rem;
                    background: rgba(255, 255, 255, 0.2);
                    color: white;
                    border: 2px solid rgba(255, 255, 255, 0.3);
                    border-radius: 6px;
                    font-weight: 600;
                    cursor: pointer;
                    font-size: 0.9rem;
                    transition: all 0.2s;
                    white-space: nowrap;
                " onmouseover="this.style.background='rgba(255, 255, 255, 0.3)'" onmouseout="this.style.background='rgba(255, 255, 255, 0.2)'">
                    💾 Save/Load
                </button>
                <button onclick="window.location.href='{% url 'game_lobby' %}'" style="
                    padding: 0.6rem 1.2rem;
                    background: linear-gradient(135deg, #fbbf24 0%, #f59e0b 100%);
                    color: #1f2937;
                    border: 2px solid rgba(251, 191, 36, 0.5);
                    border-radius: 6px;
                    font-weight: 700;
                    cursor: pointer;
                    font-size: 1rem;
                    transition: all 0.2s;
                    white-space: nowrap;
                    box-shadow: 0 4px 6px rgba(0,0,0,0.3);
                " onmouseover="this.style.boxShadow='0 6px 12px rgba(251, 191, 36, 0.6)'; this.style.transform='translateY(-2px)'" onmouseout="this.style.boxShadow='0 4px 6px rgba(0,0,0,0.3)'; this.style.transform='translateY(0)'">
                    ⬅️ Exit Game
                </button>
                <div id="connectionStatus" class="connection-status disconnected" style="position: static; margin: 0;">
                    Connecting...
                </div>
            </div>
        </div>

        <div class="game-status-row">
            <div class="status-item">
                <div class="status-label">Current Quest</div>
                <div class="status-value" id="currentQuest">Loading...</div>
            </div>
            <div class="status-item">
                <div class="status-label">Location</div>
                <div class="status-value" id="currentLocation">Unknown</div>
            </div>
            <div class="status-item">
                <div class="status-label">Party Size</div>
                <div class="status-value" id="partySize">1 Hero</div>
            </div>
            <div class="status-item">
                <div class="status-label">Bloom Level</div>
                <div class="status-value" id="headerBloomLevel">{{ character.blooms_level|title }}</div>
            </div>
        </div>
    </div>

    <!-- Main Game Container -->
    <div class="game-container">
        <!-- Left Drawer Toggle -->
        <button class="drawer-toggle drawer-toggle-left" id="leftDrawerToggle" onclick="toggleLeftDrawer()">
            📋
        </button>

        <!-- Left Drawer (Campaign/Quest/Actions) -->
        <div class="drawer drawer-left" id="leftDrawer">
            <div class="drawer-header">
                <h3>Game Info</h3>
                <div class="drawer-controls">
                    <button class="drawer-btn" onclick="toggleLeftDrawerAnchor()" title="Anchor drawer">
                        📌
                    </button>
                    <button class="drawer-btn" onclick="toggleLeftDrawer()">
                        ✕
                    </button>
                </div>
            </div>
            <div class="drawer-content">
                <!-- Campaign Status Section -->
                <h3>📜 Campaign</h3>
                <div style="padding: 1rem; background: rgba(212, 175, 55, 0.1); border-radius: 8px; border-left: 3px solid #d4af37; margin-bottom: 1.5rem;">
                    <h4 style="margin: 0; color: #d4af37; font-size: 1.1rem;">{{ campaign.title }}</h4>
                </div>

                <!-- Current Quest Objectives Section -->
                <h3>⚔️ Current Quest</h3>
                <div style="padding: 1rem; background: rgba(212, 175, 55, 0.1); border-radius: 8px; border-left: 3px solid #d4af37; margin-bottom: 1.5rem;">
                    <div id="drawerQuestInfo">
                        <p style="color: #b8b8d1;">Loading quest information...</p>
                    </div>
                    <h4 style="margin-top: 1rem; color: #a8a8c0; font-size: 0.95rem; display: flex; align-items: center; gap: 0.5rem;">
                        <i class="material-icons tiny" style="font-size: 16px;">assignment</i>
                        <span>Quest Objectives (What to do now)</span>
                    </h4>
                    <div id="drawerQuestObjectives" class="quest-tracker">
                        <!-- Objectives will be populated -->
                    </div>
                </div>

                <!-- Actions Section -->
                <h3>🎯 Available Actions</h3>
                <div id="drawerAvailableActions" class="available-actions" style="margin-bottom: 1.5rem;">
                    <p style="color: #b8b8d1; font-size: 0.9rem;">No actions available yet.</p>
                </div>
            </div>
        </div>

        <!-- Right Drawer Toggles -->
        <button class="drawer-toggle drawer-toggle-right-journey" id="rightDrawerJourneyToggle" onclick="toggleRightDrawerJourney()">
            👥
        </button>
        <button class="drawer-toggle drawer-toggle-right-progress" id="rightDrawerProgressToggle" onclick="toggleRightDrawerProgress()">
            📊
        </button>

        <!-- Right Drawer (Journey Arc) -->
        <div class="drawer drawer-right" id="rightDrawer">
            <div class="drawer-header">
                <h3>Journey Arc</h3>
                <div class="drawer-controls">
                    <button class="drawer-btn" onclick="toggleRightDrawerJourneyAnchor()" title="Anchor drawer">
                        📌
                    </button>
                    <button class="drawer-btn" onclick="toggleRightDrawerJourney()">
                        ✕
                    </button>
                </div>
            </div>
            <div class="drawer-content">
                <!-- Character Section -->
                <h3>🧙 Character</h3>
                <div style="padding: 1rem; background: rgba(212, 175, 55, 0.1); border-radius: 8px; border-left: 3px solid #d4af37; margin-bottom: 0.75rem;">
                    <h4 style="margin-top: 0; color: #d4af37;">{{ character.name }}</h4>
                    <div class="character-stat">
                        <span class="stat-label">Race:</span>
                        <span class="stat-value">{{ character.race|default:"Human" }}</span>
                    </div>
                    <div class="character-stat">
                        <span class="stat-label">Class:</span>
                        <span class="stat-value">{{ character.character_class|default:"Adventurer" }}</span>
                    </div>
                    <div class="character-stat">
                        <span class="stat-label">Level:</span>
                        <span class="stat-value">{{ character.level|default:"1" }}</span>
                    </div>
                    <div class="character-stat">
                        <span class="stat-label">Age:</span>
                        <span class="stat-value">{{ character.age|default:"25" }}</span>
                    </div>
                    <div class="character-stat">
                        <span class="stat-label">Height:</span>
                        <span class="stat-value">{{ character.height|default:"5'10\"" }}</span>
                    </div>
                </div>

                <!-- Personal Evolution Section -->
                <h3>⬆️ Personal Evolution</h3>
                <div style="padding: 1rem; background: rgba(212, 175, 55, 0.1); border-radius: 8px; border-left: 3px solid #d4af37; margin-bottom: 0.75rem;">
                    <div class="character-stat">
                        <span class="stat-label">Current Stage:</span>
                        <span class="stat-value" id="rightDrawerBloomLevel">{{ character.blooms_level|title }}</span>
                    </div>

                    <!-- Personal Evolution Arc Progress -->
                    <div style="display: flex; align-items: center; gap: 3px; margin-top: 12px; padding-bottom: 20px;">
                        {% with blooms_level=character.blooms_level %}
                        <div style="position: relative; flex: 1;">
                            <div style="height: 6px; background-color: {% if blooms_level == 'remembering' %}#6a5acd{% else %}rgba(255, 255, 255, 0.1){% endif %}; border-radius: 3px;"></div>
                            {% if blooms_level == 'remembering' %}
                            <div style="position: absolute; top: -2px; left: 50%; transform: translateX(-50%); width: 10px; height: 10px; background-color: #6a5acd; border: 2px solid #d4af37; border-radius: 50%;"></div>
                            {% endif %}
                            <div style="position: absolute; top: 12px; left: 50%; transform: translateX(-50%); white-space: nowrap; font-size: 0.6rem; {% if blooms_level == 'remembering' %}color: #6a5acd; font-weight: 600;{% else %}color: #718096; opacity: 0.6;{% endif %}">Novice</div>
                        </div>
                        <div style="position: relative; flex: 1;">
                            <div style="height: 6px; background-color: {% if blooms_level == 'understanding' %}#6a5acd{% elif blooms_level == 'remembering' %}rgba(106, 90, 205, 0.5){% else %}rgba(255, 255, 255, 0.1){% endif %}; border-radius: 3px;"></div>
                            {% if blooms_level == 'understanding' %}
                            <div style="position: absolute; top: -2px; left: 50%; transform: translateX(-50%); width: 10px; height: 10px; background-color: #6a5acd; border: 2px solid #d4af37; border-radius: 50%;"></div>
                            {% endif %}
                            <div style="position: absolute; top: 12px; left: 50%; transform: translateX(-50%); white-space: nowrap; font-size: 0.6rem; {% if blooms_level == 'understanding' %}color: #6a5acd; font-weight: 600;{% else %}color: #718096; opacity: 0.6;{% endif %}">Apprentice</div>
                        </div>
                        <div style="position: relative; flex: 1;">
                            <div style="height: 6px; background-color: {% if blooms_level == 'applying' %}#6a5acd{% elif blooms_level == 'understanding' or blooms_level == 'remembering' %}rgba(106, 90, 205, 0.5){% else %}rgba(255, 255, 255, 0.1){% endif %}; border-radius: 3px;"></div>
                            {% if blooms_level == 'applying' %}
                            <div style="position: absolute; top: -2px; left: 50%; transform: translateX(-50%); width: 10px; height: 10px; background-color: #6a5acd; border: 2px solid #d4af37; border-radius: 50%;"></div>
                            {% endif %}
                            <div style="position: absolute; top: 12px; left: 50%; transform: translateX(-50%); white-space: nowrap; font-size: 0.6rem; {% if blooms_level == 'applying' %}color: #6a5acd; font-weight: 600;{% else %}color: #718096; opacity: 0.6;{% endif %}">Journeyman</div>
                        </div>
                        <div style="position: relative; flex: 1;">
                            <div style="height: 6px; background-color: {% if blooms_level == 'analyzing' %}#6a5acd{% elif blooms_level == 'applying' or blooms_level == 'understanding' or blooms_level == 'remembering' %}rgba(106, 90, 205, 0.5){% else %}rgba(255, 255, 255, 0.1){% endif %}; border-radius: 3px;"></div>
                            {% if blooms_level == 'analyzing' %}
                            <div style="position: absolute; top: -2px; left: 50%; transform: translateX(-50%); width: 10px; height: 10px; background-color: #6a5acd; border: 2px solid #d4af37; border-radius: 50%;"></div>
                            {% endif %}
                            <div style="position: absolute; top: 12px; left: 50%; transform: translateX(-50%); white-space: nowrap; font-size: 0.6rem; {% if blooms_level == 'analyzing' %}color: #6a5acd; font-weight: 600;{% else %}color: #718096; opacity: 0.6;{% endif %}">Expert</div>
                        </div>
                        <div style="position: relative; flex: 1;">
                            <div style="height: 6px; background-color: {% if blooms_level == 'evaluating' %}#6a5acd{% elif blooms_level == 'analyzing' or blooms_level == 'applying' or blooms_level == 'understanding' or blooms_level == 'remembering' %}rgba(106, 90, 205, 0.5){% else %}rgba(255, 255, 255, 0.1){% endif %}; border-radius: 3px;"></div>
                            {% if blooms_level == 'evaluating' %}
                            <div style="position: absolute; top: -2px; left: 50%; transform: translateX(-50%); width: 10px; height: 10px; background-color: #6a5acd; border: 2px solid #d4af37; border-radius: 50%;"></div>
                            {% endif %}
                            <div style="position: absolute; top: 12px; left: 50%; transform: translateX(-50%); white-space: nowrap; font-size: 0.6rem; {% if blooms_level == 'evaluating' %}color: #6a5acd; font-weight: 600;{% else %}color: #718096; opacity: 0.6;{% endif %}">Master</div>
                        </div>
                        <div style="position: relative; flex: 1;">
                            <div style="height: 6px; background-color: {% if blooms_level == 'creating' %}#6a5acd{% elif blooms_level != 'creating' %}rgba(106, 90, 205, 0.5){% else %}rgba(255, 255, 255, 0.1){% endif %}; border-radius: 3px;"></div>
                            {% if blooms_level == 'creating' %}
                            <div style="position: absolute; top: -2px; left: 50%; transform: translateX(-50%); width: 10px; height: 10px; background-color: #6a5acd; border: 2px solid #d4af37; border-radius: 50%;"></div>
                            {% endif %}
                            <div style="position: absolute; top: 12px; left: 50%; transform: translateX(-50%); white-space: nowrap; font-size: 0.6rem; {% if blooms_level == 'creating' %}color: #6a5acd; font-weight: 600;{% else %}color: #718096; opacity: 0.6;{% endif %}">Grandmaster</div>
                        </div>
                        {% endwith %}
                    </div>
                </div>

                <!-- Progress Dashboard Component -->
                {% include 'game/components/progress_dashboard.html' %}
            </div>
        </div>

        <!-- Right Drawer (Campaign Progress) -->
        <div class="drawer drawer-right-progress" id="rightDrawerProgress">
            <div class="drawer-header">
                <h3>🎯 Campaign Goals</h3>
                <div class="drawer-controls">
                    <button class="drawer-btn" onclick="toggleRightDrawerProgressAnchor()" title="Anchor drawer">
                        📌
                    </button>
                    <button class="drawer-btn" onclick="toggleRightDrawerProgress()">
                        ✕
                    </button>
                </div>
            </div>
            <div class="drawer-content">
                <!-- Campaign Title -->
                <div style="padding: 0.75rem; background: rgba(212, 175, 55, 0.15); border-radius: 6px; border-left: 3px solid #d4af37; margin-bottom: 1.25rem;">
                    <div style="font-size: 0.75rem; color: #a8a8c0; margin-bottom: 0.25rem;">Campaign</div>
                    <div style="color: #d4af37; font-size: 1rem; font-weight: 600;">{{ campaign.title }}</div>
                </div>

                <!-- Strategic Campaign Objectives -->
                <div id="campaign-objectives-container">
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 12px;">
                        <h6 style="color: #d4af37; margin: 0; font-size: 0.95rem; display: flex; align-items: center; gap: 0.4rem;">
                            <i class="material-icons tiny" style="font-size: 16px;">military_tech</i>
                            <span>Strategic Objectives</span>
                        </h6>
                        <span id="overall-progress-badge" style="
                            background: rgba(106, 90, 205, 0.3);
                            color: #6A5ACD;
                            padding: 2px 8px;
                            border-radius: 12px;
                            font-size: 0.75rem;
                            font-weight: bold;
                        ">0%</span>
                    </div>
                    <div id="campaign-objectives-list">
                        <!-- Populated via JavaScript -->
                        <p style="color: #888; font-size: 0.85rem; text-align: center; padding: 20px;">
                            Loading objectives...
                        </p>
                    </div>
                </div>

                <!-- Current Quest Objectives -->
                <div id="quest-objectives-container" style="margin-top: 20px;">
                    <h6 style="color: #C0C0C0; margin-bottom: 8px; font-size: 0.9rem;">
                        <i class="material-icons tiny" style="vertical-align: middle; font-size: 16px;">assignment</i>
                        Current Quest
                    </h6>
                    <div id="quest-objectives-list">
                        <!-- Populated via JavaScript -->
                    </div>
                </div>

                <!-- Scene Objectives -->
                <div id="scene-objectives-container" style="margin-top: 20px;">
                    <h6 style="color: #C0C0C0; margin-bottom: 8px; font-size: 0.9rem;">
                        <i class="material-icons tiny" style="vertical-align: middle; font-size: 16px;">location_on</i>
                        This Scene
                    </h6>
                    <div id="scene-objectives-list">
                        <!-- Populated via JavaScript -->
                    </div>
                </div>

                <!-- Scene Resources (Knowledge & Items) -->
                <div id="scene-resources-container" style="margin-top: 20px;">
                    <h6 style="color: #FFD700; margin-bottom: 8px; font-size: 0.9rem;">
                        <i class="material-icons tiny" style="vertical-align: middle; font-size: 16px;">school</i>
                        Available Resources
                    </h6>

                    <div id="scene-knowledge-list" style="margin-bottom: 10px;">
                        <!-- Knowledge items -->
                    </div>

                    <div id="scene-items-list">
                        <!-- Item items -->
                    </div>
                </div>

                <!-- Dimensional Development -->
                <div id="dimensional-progress-container" style="margin-top: 20px;">
                    <h6 style="color: #C0C0C0; margin-bottom: 8px; font-size: 0.9rem;">
                        <i class="material-icons tiny" style="vertical-align: middle; font-size: 16px;">psychology</i>
                        Dimensional Development
                    </h6>
                    <div id="dimensions-list">
                        <!-- Populated via JavaScript -->
                    </div>
                </div>
            </div>
        </div>

        <!-- Objectives Sidebar (Right Panel) - HIDDEN, content moved to Campaign Progress drawer -->
        <div id="objectives-sidebar" class="objectives-panel" style="
            display: none;
            position: fixed;
            right: 20px;
            top: 120px;
            width: 350px;
            background: rgba(27, 27, 46, 0.95);
            padding: 20px;
            border-radius: 8px;
            max-height: calc(100vh - 140px);
            overflow-y: auto;
            box-shadow: 0 4px 12px rgba(0,0,0,0.3);
            z-index: 90;
            transition: right 0.3s ease-in-out;
        ">
            <!-- Header with Toggle -->
            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px;">
                <h5 style="color: #FFD700; margin: 0; font-size: 1.1rem;">
                    <i class="material-icons tiny" style="vertical-align: middle; font-size: 18px;">flag</i>
                    Objectives
                </h5>
                <button id="toggle-objectives-btn" class="btn-flat" style="color: white; padding: 0; min-width: 36px; height: 36px;">
                    <i class="material-icons">chevron_right</i>
                </button>
            </div>

            <!-- Campaign Objectives -->
            <div id="campaign-objectives-container">
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px;">
                    <h6 style="color: #C0C0C0; margin: 0; font-size: 0.9rem;">
                        Campaign Progress
                    </h6>
                    <span id="overall-progress-badge" style="
                        background: rgba(106, 90, 205, 0.3);
                        color: #6A5ACD;
                        padding: 2px 8px;
                        border-radius: 12px;
                        font-size: 0.75rem;
                        font-weight: bold;
                    ">0%</span>
                </div>
                <div id="campaign-objectives-list">
                    <!-- Populated via JavaScript -->
                    <p style="color: #888; font-size: 0.85rem; text-align: center; padding: 20px;">
                        Loading objectives...
                    </p>
                </div>
            </div>

            <!-- Current Quest Objectives -->
            <div id="quest-objectives-container" style="margin-top: 20px;">
                <h6 style="color: #C0C0C0; margin-bottom: 8px; font-size: 0.9rem;">
                    <i class="material-icons tiny" style="vertical-align: middle; font-size: 16px;">assignment</i>
                    Current Quest
                </h6>
                <div id="quest-objectives-list">
                    <!-- Populated via JavaScript -->
                </div>
            </div>

            <!-- Scene Objectives -->
            <div id="scene-objectives-container" style="margin-top: 20px;">
                <h6 style="color: #C0C0C0; margin-bottom: 8px; font-size: 0.9rem;">
                    <i class="material-icons tiny" style="vertical-align: middle; font-size: 16px;">location_on</i>
                    This Scene
                </h6>
                <div id="scene-objectives-list">
                    <!-- Populated via JavaScript -->
                </div>
            </div>

            <!-- Scene Resources (Knowledge & Items) -->
            <div id="scene-resources-container" style="margin-top: 20px;">
                <h6 style="color: #FFD700; margin-bottom: 8px; font-size: 0.9rem;">
                    <i class="material-icons tiny" style="vertical-align: middle; font-size: 16px;">school</i>
                    Available Resources
                </h6>

                <div id="scene-knowledge-list" style="margin-bottom: 10px;">
                    <!-- Knowledge items -->
                </div>

                <div id="scene-items-list">
                    <!-- Item items -->
                </div>
            </div>

            <!-- Dimensional Development -->
            <div id="dimensional-progress-container" style="margin-top: 20px;">
                <h6 style="color: #C0C0C0; margin-bottom: 8px; font-size: 0.9rem;">
                    <i class="material-icons tiny" style="vertical-align: middle; font-size: 16px;">psychology</i>
                    Dimensional Development
                </h6>
                <div id="dimensions-list">
                    <!-- Populated via JavaScript -->
                </div>
            </div>
        </div>

        <!-- Tile-Based Grid -->
        <div class="game-grid" id="gameGrid">
            <!-- Chat Section - Left Side (40% width, 100% height) -->
            <div class="grid-tile tile-chat">
                <div class="chat-panel">
                    <div class="chat-header">
                        <span>👤 Game Play</span>
                        <div class="tts-controls">
                            <button class="tts-button" id="autoPlayToggle" onclick="toggleAutoPlay()" title="Auto-play narration">
                                🔇 Auto-Play
                            </button>
                            <button class="tts-button" onclick="openSettingsModal()" title="TTS/STT Settings">
                                ⚙️
                            </button>
                        </div>
                    </div>
                    <div class="chat-messages" id="chatMessages">
                        <div class="chat-message message-dm">
                            <div class="message-sender">👤 Game Master</div>
                            <div class="message-content">
                                Welcome, adventurer! Connecting to the game world...
                            </div>
                        </div>
                    </div>
                    <div id="typingIndicator" class="typing-indicator" style="display: none;">
                        Someone is typing...
                    </div>
                    <div class="chat-input-container">
                        <!-- Quick Action Opportunities -->
                        <div id="actionOpportunities" class="action-opportunities" style="display: none;"></div>

                        <textarea id="playerInput" class="chat-input" rows="3" placeholder="What do you do?" disabled></textarea>
                        <div class="input-controls">
                            <button id="investigateSceneButton" class="investigate-scene-button" onclick="toggleInvestigatePanel()" disabled title="View all available actions in this scene">
                                🔍 Investigate Scene
                            </button>
                            <button id="micButton" class="mic-button" onclick="toggleMicrophone()" disabled title="Voice input">
                                🎤
                            </button>
                            <button id="sendButton" class="send-button" disabled>Send Action</button>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Right Column (Info Tabs + Visualizations) -->
            <div class="right-column">
                <!-- Game Information Tabbed Section - Top (50% height) -->
                <div class="info-sections">
                    <div class="grid-tile tile-info">
                        <div class="info-panel">
                            <div class="info-header">
                                <span>📋 Game Information</span>
                            </div>
                            <div class="info-toolbar">
                                <button class="info-toolbar-btn active" onclick="selectInfoTab('knowledge')">📚 Knowledge <span id="knowledgeCount" class="tab-count">(0)</span></button>
                                <button class="info-toolbar-btn" onclick="selectInfoTab('items')">🎒 Items <span id="itemsCount" class="tab-count">(0)</span></button>
                                <button class="info-toolbar-btn" onclick="selectInfoTab('encounters')">⚡ Encounters <span id="encountersCount" class="tab-count">(0)</span></button>
                            </div>
                            <div class="info-content">
                                <!-- Knowledge Tab -->
                                <div class="info-tab active" id="knowledgeTab">
                                    <div class="info-tab-content" id="knowledgeList">
                                        <p style="font-style: italic; color: #a0aec0;">No knowledge acquired yet. Explore the world to learn more!</p>
                                    </div>
                                </div>

                                <!-- Items Tab -->
                                <div class="info-tab" id="itemsTab">
                                    <div class="info-tab-content" id="itemsList">
                                        <p style="font-style: italic; color: #a0aec0;">No items acquired yet. Find treasures on your journey!</p>
                                    </div>
                                </div>

                                <!-- Encounters Tab -->
                                <div class="info-tab" id="encountersTab">
                                    <div class="info-tab-content" id="encountersList">
                                        <p style="font-style: italic; color: #a0aec0;">No encounters yet. Explore to discover events, challenges, and characters!</p>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Map/Images Section - Bottom (50% height) -->
                <div class="grid-tile tile-map">
                    <div class="map-panel">
                        <div class="map-header">
                            <span>🗺️ Visualizations</span>
                        </div>
                        <div class="map-toolbar">
                            <button class="map-toolbar-btn active" onclick="selectImageCategory('world')">World</button>
                            <button class="map-toolbar-btn" onclick="selectImageCategory('campaign')">Campaign</button>
                            <button class="map-toolbar-btn" onclick="selectImageCategory('region')">Region</button>
                            <button class="map-toolbar-btn" onclick="selectImageCategory('place')">Place</button>
                            <button class="map-toolbar-btn" onclick="selectImageCategory('scene')">Scene</button>
                        </div>
                        <div class="map-content" id="mapContent">
                            <!-- Loading state -->
                            <div class="carousel-loading" id="carouselLoading">
                                Loading images...
                            </div>

                            <!-- Carousel container (hidden initially) -->
                            <div class="image-carousel" id="imageCarousel" style="display: none;">
                                <div class="carousel-main">
                                    <button class="carousel-nav carousel-nav-prev" id="carouselPrev" onclick="previousImage()">‹</button>
                                    <img class="carousel-image" id="carouselImage" src="" alt="Campaign Image" />
                                    <button class="carousel-nav carousel-nav-next" id="carouselNext" onclick="nextImage()">›</button>
                                </div>
                                <div class="carousel-info">
                                    <div class="carousel-title" id="carouselTitle">Image Title</div>
                                    <div class="carousel-counter" id="carouselCounter">1 / 1</div>
                                </div>
                                <div class="carousel-thumbnails" id="carouselThumbnails">
                                    <!-- Thumbnails will be inserted here -->
                                </div>
                            </div>

                            <!-- Placeholder for no images -->
                            <div class="map-placeholder" id="carouselPlaceholder" style="display: none;">
                                <div class="map-placeholder-icon">🖼️</div>
                                <div>No images available</div>
                                <div style="font-size: 0.9rem; opacity: 0.5;">Images will appear here when available</div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

<!-- TTS/STT Settings Modal -->
<div id="settingsModal" class="settings-modal">
    <div class="settings-content">
        <h2 style="margin-top: 0;">Audio Settings</h2>

        <div class="settings-option">
            <label for="voiceTypeSelect">Game Master Voice:</label>
            <select id="voiceTypeSelect">
                <option value="game_master">Game Master (Old British Male)</option>
                <option value="dramatic">Dramatic (Deep & Resonant)</option>
                <option value="friendly">Friendly (Warm & Pleasant)</option>
                <option value="mysterious">Mysterious (Calm & Enigmatic)</option>
                <option value="heroic">Heroic (Strong & Commanding)</option>
            </select>
        </div>

        <div class="settings-option">
            <label for="playbackSpeedRange">Playback Speed: <span id="speedValue">1.0x</span></label>
            <input type="range" id="playbackSpeedRange" min="0.5" max="2.0" step="0.1" value="1.0" oninput="document.getElementById('speedValue').textContent = this.value + 'x'">
        </div>

        <div class="settings-option">
            <label>
                <input type="checkbox" id="autoPlayCheckbox" onchange="updateAutoPlayFromCheckbox()">
                Auto-play new Game Master narration
            </label>
        </div>

        <div class="settings-buttons">
            <button class="save-settings" onclick="saveSettings()">Save Settings</button>
            <button class="cancel-settings" onclick="closeSettingsModal()">Cancel</button>
        </div>
    </div>
</div>

<!-- Image Lightbox Modal -->
<div id="imageLightbox" class="image-lightbox" onclick="closeLightbox(event)">
    <div class="lightbox-content">
        <button class="lightbox-close" onclick="closeLightbox(event)">&times;</button>
        <img id="lightboxImage" class="lightbox-image" src="" alt="">
        <div id="lightboxTitle" class="lightbox-title"></div>
    </div>
</div>

<!-- Acquisition Notifications Container -->
<div id="acquisitionNotifications" class="acquisition-notifications"></div>

<!-- Investigate Scene Panel Modal -->
<div id="investigateScenePanel" class="investigate-panel-overlay" style="display: none;">
    <div class="investigate-panel">
        <div class="investigate-panel-header">
            <h2>🔍 Investigate Scene</h2>
            <button class="panel-close-btn" onclick="toggleInvestigatePanel()">&times;</button>
        </div>
        <div class="investigate-panel-content">
            <!-- NPCs Section -->
            <div class="investigate-section collapsed" id="npcsSection">
                <div class="investigate-section-header" onclick="toggleSection('npcs')">
                    <span class="section-icon">👥</span>
                    <span class="section-title">NPCs Present</span>
                    <span class="section-count" id="npcsCount">0</span>
                    <span class="section-toggle">▼</span>
                </div>
                <div class="investigate-section-body" id="npcsBody">
                    <div class="empty-state">No NPCs in this scene</div>
                </div>
            </div>

            <!-- Items Section -->
            <div class="investigate-section collapsed" id="itemsSection">
                <div class="investigate-section-header" onclick="toggleSection('items')">
                    <span class="section-icon">🎒</span>
                    <span class="section-title">Visible Items</span>
                    <span class="section-count" id="itemsCount">0</span>
                    <span class="section-toggle">▼</span>
                </div>
                <div class="investigate-section-body" id="itemsBody">
                    <div class="empty-state">No items visible</div>
                </div>
            </div>

            <!-- Discoveries Section -->
            <div class="investigate-section collapsed" id="discoveriesSection">
                <div class="investigate-section-header" onclick="toggleSection('discoveries')">
                    <span class="section-icon">🔍</span>
                    <span class="section-title">Discoveries</span>
                    <span class="section-count" id="discoveriesCount">0</span>
                    <span class="section-toggle">▼</span>
                </div>
                <div class="investigate-section-body" id="discoveriesBody">
                    <div class="empty-state">No discoveries available</div>
                </div>
            </div>

            <!-- Challenges Section -->
            <div class="investigate-section collapsed" id="challengesSection">
                <div class="investigate-section-header" onclick="toggleSection('challenges')">
                    <span class="section-icon">⚔️</span>
                    <span class="section-title">Active Challenges</span>
                    <span class="section-count" id="challengesCount">0</span>
                    <span class="section-toggle">▼</span>
                </div>
                <div class="investigate-section-body" id="challengesBody">
                    <div class="empty-state">No challenges active</div>
                </div>
            </div>

            <!-- Events Section -->
            <div class="investigate-section collapsed" id="eventsSection">
                <div class="investigate-section-header" onclick="toggleSection('events')">
                    <span class="section-icon">📍</span>
                    <span class="section-title">Active Events</span>
                    <span class="section-count" id="eventsCount">0</span>
                    <span class="section-toggle">▼</span>
                </div>
                <div class="investigate-section-body" id="eventsBody">
                    <div class="empty-state">No events happening</div>
                </div>
            </div>
        </div>
    </div>
</div>

<!-- Load Game Session Objectives JavaScript -->
<script src="{% static 'js/game_session.js' %}"></script>

<script>
    // Game Session Configuration
    const SESSION_ID = '{{ session_id }}';
    const PLAYER_ID = '{{ player.player_id }}';
    const CHARACTER_ID = '{{ character.character_id }}';
    const CAMPAIGN_ID = '{{ campaign.campaign_id }}';
    const GAME_ENGINE_WS_URL = 'ws://localhost:9500/api/v1/ws/session/' + SESSION_ID + '/player/' + PLAYER_ID;

    // Campaign Quest Data (from server)
    const CAMPAIGN_FIRST_QUEST = {% if first_quest_json %}{{ first_quest_json|safe }}{% else %}null{% endif %};

    // Campaign Introduction Data
    const CAMPAIGN_INTRO = {% if campaign_intro_json %}{{ campaign_intro_json|safe }}{% else %}null{% endif %};

    let ws = null;
    let isConnected = false;
    let isFirstSceneLoad = true;
    let streamingMessageDiv = null;
    let streamingContent = "";

    // TTS/STT Configuration
    let autoPlayEnabled = false;
    let currentAudio = null;
    let voiceType = 'game_master';
    let playbackSpeed = 1.0;
    let mediaRecorder = null;
    let audioChunks = [];
    let isRecording = false;

    // Drawer state - Load from localStorage if available
    let leftDrawerOpen = localStorage.getItem('leftDrawerOpen') === 'true' || false;
    let rightDrawerJourneyOpen = localStorage.getItem('rightDrawerJourneyOpen') === 'true' || false;
    let rightDrawerProgressOpen = localStorage.getItem('rightDrawerProgressOpen') === 'true' || false;
    let leftDrawerAnchored = localStorage.getItem('leftDrawerAnchored') === 'true' || false;
    let rightDrawerJourneyAnchored = localStorage.getItem('rightDrawerJourneyAnchored') === 'true' || false;
    let rightDrawerProgressAnchored = localStorage.getItem('rightDrawerProgressAnchored') === 'true' || false;

    // Make ws global for team chat component
    window.ws = ws;

    // ===================================
    // Campaign Images & Carousel Management
    // ===================================
    let campaignImages = {
        world: [],
        campaign: [],
        region: [],
        place: [],
        scene: [],
        species: []
    };
    let currentImageCategory = 'world';
    let currentImageIndex = 0;

    // Helper function to clean image titles
    function cleanImageTitle(title) {
        if (!title) return title;
        // Remove "- Image 1" from the title
        return title.replace(/\s*-\s*Image\s+1\s*$/i, '');
    }

    // SVG Placeholder Generator
    function generatePlaceholderImage(category) {
        const icons = {
            world: '&#127758;',  // 🌍 as HTML entity
            campaign: '&#9876;',  // ⚔️ as HTML entity
            region: '&#128506;', // 🗺️ as HTML entity
            place: '&#127984;',  // 🏰 as HTML entity
            scene: '&#127917;',  // 🎭 as HTML entity
            species: '&#128009;' // 🐉 as HTML entity
        };

        const colors = {
            world: '#4299e1',
            campaign: '#9f7aea',
            region: '#48bb78',
            place: '#ed8936',
            scene: '#f56565',
            species: '#ecc94b'
        };

        const icon = icons[category] || '&#128444;';  // 🖼️ as HTML entity
        const color = colors[category] || '#667eea';
        const title = category.charAt(0).toUpperCase() + category.slice(1);

        const svg = `
            <svg width="800" height="600" xmlns="http://www.w3.org/2000/svg">
                <defs>
                    <linearGradient id="grad-${category}" x1="0%" y1="0%" x2="100%" y2="100%">
                        <stop offset="0%" style="stop-color:${color};stop-opacity:0.8" />
                        <stop offset="100%" style="stop-color:${color};stop-opacity:0.4" />
                    </linearGradient>
                </defs>
                <rect width="800" height="600" fill="url(#grad-${category})"/>
                <text x="400" y="280" font-family="Arial, sans-serif" font-size="120" text-anchor="middle" fill="white">${icon}</text>
                <text x="400" y="360" font-family="Arial, sans-serif" font-size="32" text-anchor="middle" fill="white" opacity="0.9">${title} Image</text>
                <text x="400" y="400" font-family="Arial, sans-serif" font-size="18" text-anchor="middle" fill="white" opacity="0.6">No image available yet</text>
            </svg>
        `;

        // Use encodeURIComponent for Unicode-safe encoding
        return 'data:image/svg+xml;charset=utf-8,' + encodeURIComponent(svg);
    }

    // Fetch campaign images from API
    async function fetchCampaignImages() {
        try {
            const response = await fetch(`/api/campaigns/${CAMPAIGN_ID}/images/`);
            if (response.ok) {
                const data = await response.json();
                campaignImages = data.images;

                // Add placeholder images for empty categories
                Object.keys(campaignImages).forEach(category => {
                    if (campaignImages[category].length === 0) {
                        campaignImages[category].push({
                            url: generatePlaceholderImage(category),
                            title: `${category.charAt(0).toUpperCase() + category.slice(1)} Placeholder`,
                            is_primary: true,
                            is_placeholder: true
                        });
                    }
                });

                // Initialize and display world images on first load
                hideLoadingState();
                initializeCarousel();
            } else {
                console.error('Failed to fetch campaign images');
                showPlaceholder();
            }
        } catch (error) {
            console.error('Error fetching campaign images:', error);
            showPlaceholder();
        }
    }

    // Select and display image category
    function selectImageCategory(category) {
        currentImageCategory = category;
        currentImageIndex = 0;

        // Update button active states
        const buttons = document.querySelectorAll('.map-toolbar-btn');
        buttons.forEach(btn => {
            btn.classList.remove('active');
        });
        event.target.classList.add('active');

        // Display images for selected category
        displayCategoryImages(category);
    }

    // ===================================
    // Info Tab Management
    // ===================================
    function selectInfoTab(tabName) {
        // Update button active states
        const buttons = document.querySelectorAll('.info-toolbar-btn');
        buttons.forEach(btn => {
            btn.classList.remove('active');
        });
        event.target.classList.add('active');

        // Hide all tabs
        const tabs = document.querySelectorAll('.info-tab');
        tabs.forEach(tab => {
            tab.classList.remove('active');
        });

        // Show selected tab
        const tabMap = {
            'knowledge': 'knowledgeTab',
            'items': 'itemsTab',
            'encounters': 'encountersTab'
        };

        const selectedTab = document.getElementById(tabMap[tabName]);
        if (selectedTab) {
            selectedTab.classList.add('active');
        }
    }

    // Display images for a specific category
    function displayCategoryImages(category) {
        const images = campaignImages[category] || [];
        if (images.length === 0) {
            showPlaceholder();
            return;
        }

        showCarousel();
        updateCarousel();
    }

    // Update carousel display
    function updateCarousel() {
        const images = campaignImages[currentImageCategory] || [];
        if (images.length === 0) return;

        const currentImage = images[currentImageIndex];

        // Update main image
        const cleanTitle = cleanImageTitle(currentImage.title);
        document.getElementById('carouselImage').src = currentImage.url;
        document.getElementById('carouselImage').alt = cleanTitle;

        // Update title and counter
        document.getElementById('carouselTitle').textContent = cleanTitle;
        document.getElementById('carouselCounter').textContent = `${currentImageIndex + 1} / ${images.length}`;

        // Update navigation buttons
        document.getElementById('carouselPrev').disabled = currentImageIndex === 0;
        document.getElementById('carouselNext').disabled = currentImageIndex === images.length - 1;

        // Update thumbnails
        updateThumbnails();
    }

    // Update thumbnail display
    function updateThumbnails() {
        const images = campaignImages[currentImageCategory] || [];
        const thumbnailsContainer = document.getElementById('carouselThumbnails');

        thumbnailsContainer.innerHTML = '';

        images.forEach((image, index) => {
            const thumb = document.createElement('img');
            thumb.src = image.url;
            thumb.alt = cleanImageTitle(image.title);
            thumb.className = 'carousel-thumbnail';
            if (index === currentImageIndex) {
                thumb.classList.add('active');
            }
            thumb.onclick = () => goToImage(index);
            thumbnailsContainer.appendChild(thumb);
        });
    }

    // Navigation functions
    function previousImage() {
        const images = campaignImages[currentImageCategory] || [];
        if (currentImageIndex > 0) {
            currentImageIndex--;
            updateCarousel();
        }
    }

    function nextImage() {
        const images = campaignImages[currentImageCategory] || [];
        if (currentImageIndex < images.length - 1) {
            currentImageIndex++;
            updateCarousel();
        }
    }

    function goToImage(index) {
        currentImageIndex = index;
        updateCarousel();
    }

    // Lightbox functions
    function openLightbox() {
        const images = campaignImages[currentImageCategory] || [];
        if (images.length === 0 || currentImageIndex >= images.length) return;

        const currentImage = images[currentImageIndex];
        const lightbox = document.getElementById('imageLightbox');
        const lightboxImage = document.getElementById('lightboxImage');
        const lightboxTitle = document.getElementById('lightboxTitle');

        const cleanTitle = cleanImageTitle(currentImage.title);
        lightboxImage.src = currentImage.url;
        lightboxImage.alt = cleanTitle;
        lightboxTitle.textContent = cleanTitle;

        lightbox.classList.add('active');

        // Prevent body scroll when lightbox is open
        document.body.style.overflow = 'hidden';
    }

    function closeLightbox(event) {
        // Only close if clicking on the background or close button
        if (event && event.target.classList.contains('lightbox-image')) {
            return;
        }

        const lightbox = document.getElementById('imageLightbox');
        lightbox.classList.remove('active');

        // Restore body scroll
        document.body.style.overflow = '';
    }

    // Close lightbox on Escape key
    document.addEventListener('keydown', function(event) {
        if (event.key === 'Escape') {
            closeLightbox(event);
        }
    });

    // UI State Management
    function showCarousel() {
        document.getElementById('carouselLoading').style.display = 'none';
        document.getElementById('carouselPlaceholder').style.display = 'none';
        document.getElementById('imageCarousel').style.display = 'flex';
    }

    function showPlaceholder() {
        document.getElementById('carouselLoading').style.display = 'none';
        document.getElementById('imageCarousel').style.display = 'none';
        document.getElementById('carouselPlaceholder').style.display = 'flex';
    }

    function hideLoadingState() {
        document.getElementById('carouselLoading').style.display = 'none';
    }

    // Initialize carousel on first load
    function initializeCarousel() {
        // Display world images (will always have at least placeholder)
        displayCategoryImages('world');

        // Add click event to carousel image to open lightbox
        const carouselImage = document.getElementById('carouselImage');
        if (carouselImage) {
            carouselImage.addEventListener('click', openLightbox);
        }
    }

    // ===================================
    // Drawer Functions
    // ===================================
    function toggleLeftDrawer() {
        leftDrawerOpen = !leftDrawerOpen;
        const drawer = document.getElementById('leftDrawer');
        const toggle = document.getElementById('leftDrawerToggle');

        if (leftDrawerOpen) {
            drawer.classList.add('open');
            toggle.classList.add('hidden');
        } else {
            drawer.classList.remove('open');
            toggle.classList.remove('hidden');
        }

        // Save to localStorage
        localStorage.setItem('leftDrawerOpen', leftDrawerOpen);
    }

    function toggleRightDrawerJourney() {
        rightDrawerJourneyOpen = !rightDrawerJourneyOpen;
        const drawer = document.getElementById('rightDrawer');
        const toggle = document.getElementById('rightDrawerJourneyToggle');

        if (rightDrawerJourneyOpen) {
            drawer.classList.add('open');
            toggle.classList.add('hidden');
        } else {
            drawer.classList.remove('open');
            toggle.classList.remove('hidden');
        }

        // Save to localStorage
        localStorage.setItem('rightDrawerJourneyOpen', rightDrawerJourneyOpen);
    }

    function toggleRightDrawerProgress() {
        rightDrawerProgressOpen = !rightDrawerProgressOpen;
        const drawer = document.getElementById('rightDrawerProgress');
        const toggle = document.getElementById('rightDrawerProgressToggle');

        if (rightDrawerProgressOpen) {
            drawer.classList.add('open');
            toggle.classList.add('hidden');
        } else {
            drawer.classList.remove('open');
            toggle.classList.remove('hidden');
        }

        // Save to localStorage
        localStorage.setItem('rightDrawerProgressOpen', rightDrawerProgressOpen);
    }

    function toggleLeftDrawerAnchor() {
        leftDrawerAnchored = !leftDrawerAnchored;
        const drawer = document.getElementById('leftDrawer');
        const grid = document.getElementById('gameGrid');
        const header = document.querySelector('.game-header');
        const toggle = document.getElementById('leftDrawerToggle');

        if (leftDrawerAnchored) {
            drawer.classList.add('anchored');
            drawer.classList.remove('open');
            grid.classList.add('left-anchored');
            header.classList.add('left-condensed');
            toggle.style.display = 'none';
            leftDrawerOpen = false;

            if (rightDrawerJourneyAnchored) {
                grid.classList.add('both-anchored');
                header.classList.add('both-condensed');
                header.classList.remove('left-condensed');
            }
        } else {
            drawer.classList.remove('anchored');
            grid.classList.remove('left-anchored');
            grid.classList.remove('both-anchored');
            header.classList.remove('left-condensed');
            header.classList.remove('both-condensed');
            toggle.style.display = 'block';
            toggle.classList.remove('hidden');

            if (rightDrawerJourneyAnchored) {
                header.classList.add('right-condensed');
            }
        }

        // Save to localStorage
        localStorage.setItem('leftDrawerAnchored', leftDrawerAnchored);
        localStorage.setItem('leftDrawerOpen', leftDrawerOpen);
    }

    function toggleRightDrawerJourneyAnchor() {
        rightDrawerJourneyAnchored = !rightDrawerJourneyAnchored;
        const drawer = document.getElementById('rightDrawer');
        const grid = document.getElementById('gameGrid');
        const header = document.querySelector('.game-header');
        const toggle = document.getElementById('rightDrawerJourneyToggle');

        if (rightDrawerJourneyAnchored) {
            drawer.classList.add('anchored');
            drawer.classList.remove('open');
            toggle.style.display = 'none';
            rightDrawerJourneyOpen = false;

            // If Progress drawer is also anchored, we need both-right-anchored state
            if (rightDrawerProgressAnchored) {
                // Both right drawers are now anchored
                grid.classList.add('both-right-anchored');
                header.classList.add('both-right-condensed');
                grid.classList.remove('right-anchored');
                header.classList.remove('right-condensed');
            } else {
                // Only Journey drawer is anchored
                grid.classList.add('right-anchored');
                header.classList.add('right-condensed');

                if (leftDrawerAnchored) {
                    grid.classList.add('both-anchored');
                    header.classList.add('both-condensed');
                    header.classList.remove('right-condensed');
                }
            }
        } else {
            drawer.classList.remove('anchored');
            toggle.style.display = 'block';
            toggle.classList.remove('hidden');

            // If Progress drawer is still anchored, maintain right-anchored state
            if (rightDrawerProgressAnchored) {
                grid.classList.remove('both-right-anchored');
                header.classList.remove('both-right-condensed');
                // Keep right-anchored for Progress drawer
                grid.classList.add('right-anchored');
                header.classList.add('right-condensed');
            } else {
                grid.classList.remove('right-anchored');
                grid.classList.remove('both-anchored');
                header.classList.remove('right-condensed');
                header.classList.remove('both-condensed');

                if (leftDrawerAnchored) {
                    header.classList.add('left-condensed');
                }
            }
        }

        // Save to localStorage
        localStorage.setItem('rightDrawerJourneyAnchored', rightDrawerJourneyAnchored);
        localStorage.setItem('rightDrawerJourneyOpen', rightDrawerJourneyOpen);
    }

    function toggleRightDrawerProgressAnchor() {
        rightDrawerProgressAnchored = !rightDrawerProgressAnchored;
        const drawer = document.getElementById('rightDrawerProgress');
        const toggle = document.getElementById('rightDrawerProgressToggle');
        const grid = document.getElementById('gameGrid');
        const header = document.querySelector('.game-header');

        if (rightDrawerProgressAnchored) {
            drawer.classList.add('anchored');
            drawer.classList.remove('open');
            toggle.style.display = 'none';
            rightDrawerProgressOpen = false;

            // If Journey drawer is also anchored, we need both-right-anchored state
            if (rightDrawerJourneyAnchored) {
                // Both right drawers are now anchored
                grid.classList.add('both-right-anchored');
                header.classList.add('both-right-condensed');
                grid.classList.remove('right-anchored');
                header.classList.remove('right-condensed');
            } else {
                // Only Progress drawer is anchored
                grid.classList.add('right-anchored');
                header.classList.add('right-condensed');

                if (leftDrawerAnchored) {
                    grid.classList.add('both-anchored');
                    header.classList.add('both-condensed');
                    header.classList.remove('right-condensed');
                }
            }
        } else {
            drawer.classList.remove('anchored');
            toggle.style.display = 'block';
            toggle.classList.remove('hidden');

            // If Journey drawer is still anchored, maintain right-anchored state
            if (rightDrawerJourneyAnchored) {
                grid.classList.remove('both-right-anchored');
                header.classList.remove('both-right-condensed');
                // Keep right-anchored for Journey drawer
                grid.classList.add('right-anchored');
                header.classList.add('right-condensed');
            } else {
                grid.classList.remove('right-anchored');
                grid.classList.remove('both-anchored');
                header.classList.remove('right-condensed');
                header.classList.remove('both-condensed');

                if (leftDrawerAnchored) {
                    header.classList.add('left-condensed');
                }
            }
        }

        // Save to localStorage
        localStorage.setItem('rightDrawerProgressAnchored', rightDrawerProgressAnchored);
        localStorage.setItem('rightDrawerProgressOpen', rightDrawerProgressOpen);
    }

    // Restore drawer state from localStorage
    function restoreDrawerState() {
        const drawer = document.getElementById('leftDrawer');
        const grid = document.getElementById('gameGrid');
        const header = document.querySelector('.game-header');
        const leftToggle = document.getElementById('leftDrawerToggle');
        const rightDrawerJourney = document.getElementById('rightDrawer');
        const rightToggleJourney = document.getElementById('rightDrawerJourneyToggle');
        const rightDrawerProgress = document.getElementById('rightDrawerProgress');
        const rightToggleProgress = document.getElementById('rightDrawerProgressToggle');

        // If no saved state exists, default to Journey drawer anchored (first time)
        const hasStoredState = localStorage.getItem('leftDrawerAnchored') !== null;

        if (!hasStoredState) {
            // First time visit - pin left and journey drawers by default
            toggleLeftDrawerAnchor();
            toggleRightDrawerJourneyAnchor();
            return;
        }

        // Restore left drawer state
        if (leftDrawerAnchored) {
            drawer.classList.add('anchored');
            grid.classList.add('left-anchored');
            header.classList.add('left-condensed');
            leftToggle.style.display = 'none';
        } else if (leftDrawerOpen) {
            drawer.classList.add('open');
            leftToggle.classList.add('hidden');
        }

        // Restore right drawer journey state
        if (rightDrawerJourneyAnchored) {
            rightDrawerJourney.classList.add('anchored');
            rightToggleJourney.style.display = 'none';
        } else if (rightDrawerJourneyOpen) {
            rightDrawerJourney.classList.add('open');
            rightToggleJourney.classList.add('hidden');
        }

        // Restore right drawer progress state
        if (rightDrawerProgressAnchored) {
            rightDrawerProgress.classList.add('anchored');
            rightToggleProgress.style.display = 'none';
        } else if (rightDrawerProgressOpen) {
            rightDrawerProgress.classList.add('open');
            rightToggleProgress.classList.add('hidden');
        }

        // Apply grid and header classes based on which drawers are anchored
        // Handle all combinations of anchored drawers
        if (rightDrawerJourneyAnchored && rightDrawerProgressAnchored) {
            // Both right drawers anchored
            grid.classList.add('both-right-anchored');
            header.classList.add('both-right-condensed');
        } else if (rightDrawerJourneyAnchored || rightDrawerProgressAnchored) {
            // Only one right drawer anchored
            grid.classList.add('right-anchored');
            header.classList.add('right-condensed');
        }

        // If left drawer is also anchored, update classes accordingly
        if (leftDrawerAnchored) {
            if (rightDrawerJourneyAnchored && !rightDrawerProgressAnchored) {
                // Left + Journey only
                grid.classList.add('both-anchored');
                header.classList.add('both-condensed');
                header.classList.remove('left-condensed', 'right-condensed');
            } else if (rightDrawerProgressAnchored && !rightDrawerJourneyAnchored) {
                // Left + Progress only
                grid.classList.add('both-anchored');
                header.classList.add('both-condensed');
                header.classList.remove('left-condensed', 'right-condensed');
            } else if (rightDrawerJourneyAnchored && rightDrawerProgressAnchored) {
                // All three drawers anchored - keep left-condensed and both-right-condensed
                header.classList.remove('both-condensed');
            }
        }
    }

    // Initialize on page load
    document.addEventListener('DOMContentLoaded', function() {
        connectWebSocket();
        setupEventListeners();
        fetchSessionState();
        loadSettings();

        // Fetch campaign images
        fetchCampaignImages();

        // Restore drawer state from localStorage (or set defaults)
        restoreDrawerState();
    });

    function connectWebSocket() {
        updateConnectionStatus('connecting');

        ws = new WebSocket(GAME_ENGINE_WS_URL);
        window.ws = ws;

        ws.onopen = function() {
            isConnected = true;
            updateConnectionStatus('connected');
            enableInput();
        };

        ws.onmessage = function(event) {
            const data = JSON.parse(event.data);
            handleGameEvent(data);
        };

        ws.onerror = function(error) {
            updateConnectionStatus('error');
        };

        ws.onclose = function() {
            isConnected = false;
            updateConnectionStatus('disconnected');
            disableInput();
            setTimeout(connectWebSocket, 3000);
        };
    }

    function handleGameEvent(data) {
        switch(data.event) {
            case 'connected':
                addSystemMessage('Connected to game session');
                break;

            case 'chat_message':
                if (data.message && data.message.channel && typeof handleIncomingChat === 'function') {
                    handleIncomingChat(data.message);
                } else {
                    addChatMessage(data.message);
                }
                break;

            case 'scene_chunk':
                handleSceneChunk(data);
                break;

            case 'gm_answer_chunk':
                handleStreamingChunk(data);
                break;

            case 'action_outcome_chunk':
                handleStreamingChunk(data);
                break;

            case 'scene_update':
            case 'initial_scene':
                updateScene(data);
                break;

            case 'state_update':
                updateGameState(data);
                break;

            case 'action_received':
                if (lastActionSent) {
                    addSystemMessage(`Processing: "${lastActionSent}"`);
                } else {
                    addSystemMessage('Processing your action...');
                }
                break;

            case 'typing_indicator':
                showTypingIndicator(data.is_typing);
                break;

            case 'player_joined_session':
                addSystemMessage(`${data.character_name} joined the party`);
                if (typeof handleIncomingChat === 'function') {
                    handleIncomingChat({
                        event: 'player_joined',
                        player_name: data.character_name
                    });
                }
                break;

            case 'player_left':
                addSystemMessage(`A player left the session`);
                if (typeof handleIncomingChat === 'function') {
                    handleIncomingChat({
                        event: 'player_left',
                        player_name: data.character_name || 'Unknown'
                    });
                }
                break;

            case 'quest_completed':
                handleQuestComplete(data);
                break;

            case 'dynamic_event_triggered':
                handleDynamicEvent(data.event_data);
                break;

            case 'challenge_created':
                handleChallenge(data.challenge);
                break;

            case 'knowledge_gained':
                console.log('WebSocket knowledge_gained event:', data);
                console.log('knowledge object:', data.knowledge);
                addKnowledge(data.knowledge);
                break;

            case 'quest_progress_update':
                updateQuestProgress(data.quest_progress);
                break;

            case 'item_acquired':
                addItem(data.item);
                break;

            case 'npc_encountered':
                addEncounter({...data.npc, type: 'npc'});
                break;

            case 'event_encountered':
                addEncounter({...data.event, type: 'event'});
                break;

            case 'discovery_encountered':
                console.log('======= discovery_encountered EVENT =======');
                console.log('Discovery data:', data.discovery);
                console.log('Discovery name:', data.discovery.name);
                addEncounter({...data.discovery, type: 'discovery'});
                break;

            case 'challenge_encountered':
                addEncounter({...data.challenge, type: 'challenge'});
                break;

            case 'action_opportunities':
                displayActionOpportunities(data.opportunities, data.context);
                break;

            case 'objective_progress':
                // Handle quest objective progress updates
                if (typeof window.GameSessionObjectives !== 'undefined' &&
                    typeof window.GameSessionObjectives.handleObjectiveProgress === 'function') {
                    window.GameSessionObjectives.handleObjectiveProgress(data);
                }
                // Also reload full objectives data to update both drawers
                if (typeof window.GameSessionObjectives !== 'undefined' &&
                    typeof window.GameSessionObjectives.loadObjectiveProgress === 'function') {
                    window.GameSessionObjectives.loadObjectiveProgress(SESSION_ID, PLAYER_ID);
                }
                // Also refresh legacy quest progress (left drawer)
                if (typeof refreshQuestProgress === 'function') {
                    refreshQuestProgress();
                }
                break;

            case 'campaign_objective_progress':
                // Handle campaign objective progress updates
                if (typeof window.GameSessionObjectives !== 'undefined' &&
                    typeof window.GameSessionObjectives.handleCampaignObjectiveProgress === 'function') {
                    window.GameSessionObjectives.handleCampaignObjectiveProgress(data);
                }
                // Also reload full objectives data to update both drawers
                if (typeof window.GameSessionObjectives !== 'undefined' &&
                    typeof window.GameSessionObjectives.loadObjectiveProgress === 'function') {
                    window.GameSessionObjectives.loadObjectiveProgress(SESSION_ID, PLAYER_ID);
                }
                // Also refresh legacy quest progress (left drawer)
                if (typeof refreshQuestProgress === 'function') {
                    refreshQuestProgress();
                }
                break;
        }
    }

    // ===================================
    // Action Opportunities Display
    // ===================================
    function displayActionOpportunities(opportunities, context) {
        const container = document.getElementById('actionOpportunities');

        if (!container) {
            console.error('Action opportunities container not found');
            return;
        }

        // Check if there are any opportunities
        const hasOpportunities = opportunities && Object.values(opportunities).some(arr => arr && arr.length > 0);

        if (!hasOpportunities) {
            container.style.display = 'none';
            return;
        }

        // Build HTML for opportunities
        let html = '<div class="action-opportunities-header">💡 Quick Actions</div>';

        // NPCs
        if (opportunities.npcs && opportunities.npcs.length > 0) {
            html += '<div class="opportunity-group">';
            html += '<div class="opportunity-group-title">👥 Talk To</div>';
            html += '<div class="opportunity-buttons">';
            opportunities.npcs.forEach(npc => {
                const npcId = npc.id || '';
                const npcAction = (npc.action || '').replace(/'/g, "\\'");
                html += `<button class="opportunity-btn npc" data-context="${npc.context}" data-id="${npcId}" data-action="${npcAction}">${npc.action}</button>`;
            });
            html += '</div></div>';
        }

        // Items
        if (opportunities.items && opportunities.items.length > 0) {
            html += '<div class="opportunity-group">';
            html += '<div class="opportunity-group-title">🎒 Items</div>';
            html += '<div class="opportunity-buttons">';
            opportunities.items.forEach(item => {
                const itemAction = (item.action || '').replace(/'/g, "\\'");
                html += `<button class="opportunity-btn item" data-context="${item.context}" data-action="${itemAction}">${item.action}</button>`;
            });
            html += '</div></div>';
        }

        // Discoveries
        if (opportunities.discoveries && opportunities.discoveries.length > 0) {
            html += '<div class="opportunity-group">';
            html += '<div class="opportunity-group-title">🔍 Investigate</div>';
            html += '<div class="opportunity-buttons">';
            opportunities.discoveries.forEach(discovery => {
                const discoveryId = discovery.id || '';
                const discoveryAction = (discovery.action || '').replace(/'/g, "\\'");
                html += `<button class="opportunity-btn discovery" data-context="${discovery.context}" data-id="${discoveryId}" data-action="${discoveryAction}">${discovery.action}</button>`;
            });
            html += '</div></div>';
        }

        // General actions
        if (opportunities.actions && opportunities.actions.length > 0) {
            html += '<div class="opportunity-group">';
            html += '<div class="opportunity-group-title">⚡ Actions</div>';
            html += '<div class="opportunity-buttons">';
            opportunities.actions.forEach(action => {
                const actionText = (action.action || '').replace(/'/g, "\\'");
                html += `<button class="opportunity-btn" data-context="${action.context}" data-action="${actionText}">${action.action}</button>`;
            });
            html += '</div></div>';
        }

        container.innerHTML = html;
        container.style.display = 'block';

        // Add click handlers to all opportunity buttons
        container.querySelectorAll('.opportunity-btn').forEach(btn => {
            btn.addEventListener('click', handleOpportunityClick);
        });
    }

    function handleOpportunityClick(event) {
        const button = event.currentTarget;
        const actionText = button.getAttribute('data-action');

        if (!actionText) {
            console.error('No action text found on button');
            return;
        }

        // Submit the action as if player typed it
        const playerInput = document.getElementById('playerInput');
        if (playerInput) {
            playerInput.value = actionText;
            sendPlayerAction();
        }

        // Hide opportunities after click
        const container = document.getElementById('actionOpportunities');
        if (container) {
            container.style.display = 'none';
        }
    }

    // ===================================
    // Name Formatting Helper
    // ===================================
    function formatDisplayName(name) {
        if (!name) return 'Unknown';
        // Remove underscores and convert to title case
        return name
            .split('_')
            .map(word => word.charAt(0).toUpperCase() + word.slice(1).toLowerCase())
            .join(' ');
    }

    // ===================================
    // Investigate Scene Panel Functions
    // ===================================
    let currentSceneData = {
        npcs: [],
        items: [],
        discoveries: [],
        challenges: [],
        events: []
    };

    function toggleInvestigatePanel() {
        const panel = document.getElementById('investigateScenePanel');
        if (!panel) return;

        const isVisible = panel.style.display !== 'none';

        if (isVisible) {
            panel.style.display = 'none';
        } else {
            // Refresh panel content before showing
            populateInvestigatePanel();
            panel.style.display = 'flex';
        }
    }

    function toggleSection(sectionName) {
        const section = document.getElementById(sectionName + 'Section');
        if (!section) return;

        const isCurrentlyCollapsed = section.classList.contains('collapsed');

        // If clicking on a collapsed section, first collapse all sections
        if (isCurrentlyCollapsed) {
            const allSections = document.querySelectorAll('.investigate-section');
            allSections.forEach(s => s.classList.add('collapsed'));
        }

        // Then toggle the clicked section
        section.classList.toggle('collapsed');
    }

    function populateInvestigatePanel() {
        // Populate NPCs
        populateNPCs(currentSceneData.npcs);

        // Populate Items
        populateItems(currentSceneData.items);

        // Populate Discoveries
        populateDiscoveries(currentSceneData.discoveries);

        // Populate Challenges
        populateChallenges(currentSceneData.challenges);

        // Populate Events
        populateEvents(currentSceneData.events);
    }

    function populateNPCs(npcs) {
        const body = document.getElementById('npcsBody');
        const count = document.getElementById('npcsCount');

        if (!npcs || npcs.length === 0) {
            body.innerHTML = '<div class="empty-state">No NPCs in this scene</div>';
            count.textContent = '0';
            return;
        }

        count.textContent = npcs.length.toString();

        let html = '';
        npcs.forEach(npc => {
            const npcId = npc.npc_id || npc._id || npc.id || '';
            const npcName = npc.name || 'Unknown NPC';
            const npcRole = npc.role || 'Character';
            const npcDescription = npc.description || '';

            // Escape single quotes and backslashes for onclick handlers
            const escapedName = npcName.replace(/\\/g, '\\\\').replace(/'/g, "\\'");

            html += `
                <div class="entity-item">
                    <div class="entity-header">
                        <div class="entity-icon">👤</div>
                        <div class="entity-info">
                            <div class="entity-name">${npcName}</div>
                            <div class="entity-role">${npcRole}</div>
                            ${npcDescription ? `<div class="entity-description">${npcDescription}</div>` : ''}
                        </div>
                    </div>
                    <div class="entity-actions">
                        <button class="entity-action-btn primary" onclick="performSceneAction('Talk to ${escapedName}')">💬 Talk</button>
                        <button class="entity-action-btn" onclick="performSceneAction('Ask ${escapedName} about their story')">📖 Ask About Story</button>
                        <button class="entity-action-btn" onclick="performSceneAction('Examine ${escapedName}')">🔍 Examine</button>
                    </div>
                </div>
            `;
        });

        body.innerHTML = html;
    }

    function populateItems(items) {
        const body = document.getElementById('itemsBody');
        const count = document.getElementById('itemsCount');

        if (!items || items.length === 0) {
            body.innerHTML = '<div class="empty-state">No items visible</div>';
            count.textContent = '0';
            return;
        }

        count.textContent = items.length.toString();

        let html = '';
        items.forEach(item => {
            const itemName = typeof item === 'string' ? item : (item.name || 'Unknown Item');
            const itemDescription = typeof item === 'object' ? (item.description || '') : '';
            const displayName = formatDisplayName(itemName);

            // Escape single quotes and backslashes for onclick handlers
            const escapedItemName = itemName.replace(/\\/g, '\\\\').replace(/'/g, "\\'");

            html += `
                <div class="entity-item">
                    <div class="entity-header">
                        <div class="entity-icon">📦</div>
                        <div class="entity-info">
                            <div class="entity-name">${displayName}</div>
                            ${itemDescription ? `<div class="entity-description">${itemDescription}</div>` : ''}
                        </div>
                    </div>
                    <div class="entity-actions">
                        <button class="entity-action-btn primary" onclick="performSceneAction('Pick up the ${escapedItemName} from the scene')">✋ Take</button>
                        <button class="entity-action-btn" onclick="performSceneAction('Examine the ${escapedItemName}')">🔍 Examine</button>
                    </div>
                </div>
            `;
        });

        body.innerHTML = html;
    }

    function populateDiscoveries(discoveries) {
        console.log('======= populateDiscoveries START =======');
        console.log('completedDiscoveries Set:', Array.from(completedDiscoveries));

        const body = document.getElementById('discoveriesBody');
        const count = document.getElementById('discoveriesCount');

        if (!discoveries || discoveries.length === 0) {
            body.innerHTML = '<div class="empty-state">No discoveries available</div>';
            count.textContent = '0';
            return;
        }

        count.textContent = discoveries.length.toString();

        let html = '';
        discoveries.forEach(discovery => {
            const discoveryId = discovery.discovery_id || discovery._id || discovery.id || '';
            const discoveryName = discovery.name || 'Unknown Discovery';
            const discoveryDescription = discovery.description || '';

            console.log(`Checking discovery: "${discoveryName}"`);
            console.log(`  - discovery.investigated: ${discovery.investigated}`);
            console.log(`  - completedDiscoveries.has("${discoveryName}"): ${completedDiscoveries.has(discoveryName)}`);

            // Check if this discovery has been investigated (from backend OR from our tracking)
            const isInvestigated = discovery.investigated || completedDiscoveries.has(discoveryName);
            console.log(`  - isInvestigated: ${isInvestigated}`);

            const completedClass = isInvestigated ? ' completed' : '';
            const investigatedLabel = isInvestigated ? '<span style="color: #4caf50; font-weight: 600; margin-left: 8px;">✓ Investigated</span>' : '';

            // Escape single quotes and backslashes for onclick handlers
            const escapedDiscoveryName = discoveryName.replace(/\\/g, '\\\\').replace(/'/g, "\\'");

            html += `
                <div class="entity-item${completedClass}">
                    <div class="entity-header">
                        <div class="entity-icon">🔎</div>
                        <div class="entity-info">
                            <div class="entity-name">${discoveryName} ${investigatedLabel}</div>
                            ${discoveryDescription ? `<div class="entity-description">${discoveryDescription}</div>` : ''}
                        </div>
                    </div>
                    <div class="entity-actions">
                        <button class="entity-action-btn primary" onclick="performSceneAction('Investigate ${escapedDiscoveryName}')" ${isInvestigated ? 'disabled' : ''}>🔍 ${isInvestigated ? 'Already Investigated' : 'Investigate'}</button>
                        <button class="entity-action-btn" onclick="performSceneAction('Examine ${escapedDiscoveryName}')">👁️ Examine</button>
                    </div>
                </div>
            `;
        });

        body.innerHTML = html;
    }

    function populateChallenges(challenges) {
        const body = document.getElementById('challengesBody');
        const count = document.getElementById('challengesCount');

        if (!challenges || challenges.length === 0) {
            body.innerHTML = '<div class="empty-state">No challenges active</div>';
            count.textContent = '0';
            return;
        }

        count.textContent = challenges.length.toString();

        let html = '';
        challenges.forEach(challenge => {
            const challengeId = challenge.challenge_id || challenge._id || challenge.id || '';
            const challengeName = challenge.name || 'Unknown Challenge';
            const challengeDescription = challenge.description || '';

            // Escape single quotes and backslashes for onclick handlers
            const escapedChallengeName = challengeName.replace(/\\/g, '\\\\').replace(/'/g, "\\'");

            html += `
                <div class="entity-item">
                    <div class="entity-header">
                        <div class="entity-icon">⚔️</div>
                        <div class="entity-info">
                            <div class="entity-name">${challengeName}</div>
                            ${challengeDescription ? `<div class="entity-description">${challengeDescription}</div>` : ''}
                        </div>
                    </div>
                    <div class="entity-actions">
                        <button class="entity-action-btn primary" onclick="performSceneAction('Attempt ${escapedChallengeName}')">⚔️ Attempt</button>
                        <button class="entity-action-btn" onclick="performSceneAction('Examine ${escapedChallengeName}')">🔍 Examine</button>
                    </div>
                </div>
            `;
        });

        body.innerHTML = html;
    }

    function populateEvents(events) {
        const body = document.getElementById('eventsBody');
        const count = document.getElementById('eventsCount');

        if (!events || events.length === 0) {
            body.innerHTML = '<div class="empty-state">No events happening</div>';
            count.textContent = '0';
            return;
        }

        count.textContent = events.length.toString();

        let html = '';
        events.forEach(event => {
            const eventId = event.event_id || event._id || event.id || '';
            const eventName = event.name || 'Unknown Event';
            const eventDescription = event.description || '';

            // Escape single quotes and backslashes for onclick handlers
            const escapedEventName = eventName.replace(/\\/g, '\\\\').replace(/'/g, "\\'");

            html += `
                <div class="entity-item">
                    <div class="entity-header">
                        <div class="entity-icon">📍</div>
                        <div class="entity-info">
                            <div class="entity-name">${eventName}</div>
                            ${eventDescription ? `<div class="entity-description">${eventDescription}</div>` : ''}
                        </div>
                    </div>
                    <div class="entity-actions">
                        <button class="entity-action-btn primary" onclick="performSceneAction('Participate in ${escapedEventName}')">✨ Participate</button>
                        <button class="entity-action-btn" onclick="performSceneAction('Examine ${escapedEventName}')">🔍 Examine</button>
                    </div>
                </div>
            `;
        });

        body.innerHTML = html;
    }

    function performSceneAction(actionText) {
        // Submit the action
        const playerInput = document.getElementById('playerInput');
        if (playerInput) {
            playerInput.value = actionText;
            sendPlayerAction();
        }

        // Close the investigate panel
        toggleInvestigatePanel();
    }

    function updateSceneData(sceneData) {
        // Update current scene data from WebSocket events
        if (sceneData.available_npcs) {
            currentSceneData.npcs = sceneData.available_npcs;
        }

        if (sceneData.visible_items) {
            currentSceneData.items = sceneData.visible_items;
        }

        if (sceneData.available_discoveries) {
            currentSceneData.discoveries = sceneData.available_discoveries;
        }

        if (sceneData.active_challenges) {
            currentSceneData.challenges = sceneData.active_challenges;
        }

        if (sceneData.active_events) {
            currentSceneData.events = sceneData.active_events;
        }

        // If investigate panel is open, refresh it
        const panel = document.getElementById('investigateScenePanel');
        if (panel && panel.style.display !== 'none') {
            populateInvestigatePanel();
        }
    }

    // ===================================
    // Enhanced Acquisition Notification System
    // ===================================
    function showAcquisitionNotification(type, data) {
        console.log('showAcquisitionNotification called with:', type, data);
        const container = document.getElementById('acquisitionNotifications');
        if (!container) {
            console.error('acquisitionNotifications container not found!');
            return;
        }

        // Determine icon based on type
        const icons = {
            knowledge: '📚',
            item: '🎒',
            npc: '👤',
            discovery: '🔎',
            challenge: '⚔️',
            event: '📍'
        };

        const icon = icons[type] || '✨';
        const rawTitle = data.name || data.title || 'Unknown';
        const title = formatDisplayName(rawTitle);
        const description = data.description || '';
        const source = data.source || '';
        const questLink = data.questLink || null;
        const progress = data.progress || null;

        console.log('Notification params - questLink:', questLink, 'progress:', progress);

        // Create notification element
        const notification = document.createElement('div');
        notification.className = `acquisition-notification ${type}`;

        let html = `
            <div class="notification-header">
                <span class="notification-icon">${icon}</span>
                <div style="flex: 1;">
                    <div class="notification-title">${title}</div>
                    <div class="notification-type ${type}">${type}</div>
                </div>
            </div>
        `;

        if (description || source) {
            html += `<div class="notification-body">`;

            if (description) {
                html += `<div class="notification-description">${description}</div>`;
            }

            if (source) {
                html += `<div class="notification-source">📍 ${source}</div>`;
            }

            html += `</div>`;
        }

        if (questLink) {
            console.log('Adding quest link to notification!', questLink, progress);
            html += `
                <div class="notification-quest-link">
                    <span>✅ ${questLink}</span>
                    ${progress ? `<span class="notification-progress">${progress}</span>` : ''}
                </div>
            `;
        } else {
            console.log('No questLink, skipping quest progress display');
        }

        notification.innerHTML = html;

        // Add to container
        container.appendChild(notification);

        // Auto-remove after 5 seconds
        setTimeout(() => {
            notification.style.animation = 'fadeOut 0.3s ease-out';
            setTimeout(() => {
                if (notification.parentElement) {
                    notification.parentElement.removeChild(notification);
                }
            }, 300);
        }, 5000);

        // Click to dismiss
        notification.addEventListener('click', () => {
            notification.style.animation = 'fadeOut 0.2s ease-out';
            setTimeout(() => {
                if (notification.parentElement) {
                    notification.parentElement.removeChild(notification);
                }
            }, 200);
        });
    }

    // ===================================
    // Knowledge, Items, and Encounters Management
    // ===================================
    let knowledgeAcquired = [];
    let itemsAcquired = [];
    let encountersRecord = [];
    let completedDiscoveries = new Set(); // Track completed discovery names
    let completedChallenges = new Set(); // Track completed challenge names
    let lastQuestProgress = null; // Store the last quest progress data from backend

    function refreshQuestProgress() {
        // Refresh quest objectives using backend data if available
        if (lastQuestProgress) {
            updateQuestProgress(lastQuestProgress);
        }
        // If no backend data yet, do nothing - wait for WebSocket update
    }

    function addKnowledge(knowledge) {
        // Debug: Log what we received
        console.log('======= addKnowledge START =======');
        console.log('Knowledge received:', knowledge);
        console.log('Current knowledgeAcquired array length BEFORE:', knowledgeAcquired.length);
        console.log('Current knowledgeAcquired array:', JSON.stringify(knowledgeAcquired));

        // Check if already acquired
        if (knowledgeAcquired.some(k => k.id === knowledge.id)) {
            console.log('Knowledge already acquired, skipping');
            return;
        }

        knowledgeAcquired.push(knowledge);
        console.log('Knowledge added. New length:', knowledgeAcquired.length);
        console.log('Calling updateKnowledgeList()...');
        updateKnowledgeList();
        console.log('updateKnowledgeList() completed');

        // Track the source discovery as completed if provided
        if (knowledge.source_discovery || knowledge.discovery_name) {
            const discoveryName = knowledge.source_discovery || knowledge.discovery_name;
            completedDiscoveries.add(discoveryName);
            console.log('Discovery completed:', discoveryName);
            // Refresh the Investigate Scene dialog if it's open
            if (currentSceneData && currentSceneData.discoveries) {
                populateDiscoveries(currentSceneData.discoveries);
            }
        }

        // Refresh quest progress bars
        refreshQuestProgress();

        // Show enhanced notification
        showAcquisitionNotification('knowledge', {
            name: knowledge.name || knowledge.title,
            description: knowledge.description || 'Knowledge acquired',
            source: knowledge.source || 'Learned during your journey',
            questLink: knowledge.questLink || null,
            progress: knowledge.progress || null
        });

        // Also show system message for backwards compatibility
        addSystemMessage(`📚 New knowledge acquired: ${knowledge.name || knowledge.title}`);
    }

    function addItem(item) {
        // Check if already acquired
        if (itemsAcquired.some(i => i.id === item.id)) {
            return;
        }

        itemsAcquired.push(item);
        updateItemsList();

        // Remove from visible items in Investigate Scene panel
        if (currentSceneData && currentSceneData.items) {
            // Remove by matching item name or ID
            currentSceneData.items = currentSceneData.items.filter(sceneItem => {
                const sceneItemName = typeof sceneItem === 'string' ? sceneItem : sceneItem.name;
                const acquiredItemName = item.name;
                return sceneItemName !== acquiredItemName && sceneItem !== acquiredItemName;
            });

            // Refresh the Investigate Scene panel if it's open
            const panel = document.getElementById('investigateScenePanel');
            if (panel && panel.style.display !== 'none') {
                populateItems(currentSceneData.items);
            }
        }

        // Refresh quest progress bars
        refreshQuestProgress();

        // Show enhanced notification
        showAcquisitionNotification('item', {
            name: item.name,
            description: item.description || 'Item acquired',
            source: item.source || 'Found during your adventure',
            questLink: item.questLink || null,
            progress: item.progress || null
        });

        // Also show system message for backwards compatibility
        addSystemMessage(`🎒 New item acquired: ${item.name}`);
    }

    function addEncounter(encounter) {
        // Check if already encountered
        if (encountersRecord.some(e => e.id === encounter.id && e.type === encounter.type)) {
            return;
        }

        encountersRecord.push(encounter);
        updateEncountersList();

        // Track discovery as completed if this is a discovery encounter
        if (encounter.type === 'discovery' && encounter.name) {
            completedDiscoveries.add(encounter.name);
            console.log('Discovery marked as completed (from encounter):', encounter.name);
            // Refresh the Investigate Scene dialog if it's open
            if (currentSceneData && currentSceneData.discoveries) {
                populateDiscoveries(currentSceneData.discoveries);
            }
        }

        // Refresh quest progress bars
        refreshQuestProgress();

        // Show enhanced notification based on type
        const type = encounter.type || 'encounter';
        showAcquisitionNotification(type, {
            name: encounter.name || encounter.title,
            description: encounter.description || `${type.charAt(0).toUpperCase() + type.slice(1)} encountered`,
            source: encounter.source || `Encountered in ${encounter.location || 'your journey'}`,
            questLink: encounter.questLink || null,
            progress: encounter.progress || null
        });

        // Show notification with appropriate icon
        const icons = {
            'npc': '👥',
            'event': '🌟',
            'discovery': '🔍',
            'challenge': '⚔️'
        };
        const icon = icons[encounter.type] || '⚡';
        const typeName = encounter.type ? encounter.type.charAt(0).toUpperCase() + encounter.type.slice(1) : 'Encounter';
        addSystemMessage(`${icon} New ${typeName}: ${encounter.name || encounter.title}`);
    }

    function updateKnowledgeList() {
        console.log('======= updateKnowledgeList START =======');
        console.log('knowledgeAcquired.length:', knowledgeAcquired.length);

        const knowledgeList = document.getElementById('knowledgeList');
        const knowledgeCount = document.getElementById('knowledgeCount');

        console.log('knowledgeList element:', knowledgeList);
        console.log('knowledgeCount element:', knowledgeCount);

        // Update count badge
        if (knowledgeCount) {
            knowledgeCount.textContent = `(${knowledgeAcquired.length})`;
            console.log('Updated count badge to:', knowledgeAcquired.length);
        }

        if (knowledgeAcquired.length === 0) {
            knowledgeList.innerHTML = '<p style="font-style: italic; color: #a0aec0;">No knowledge acquired yet. Explore the world to learn more!</p>';
            console.log('Set empty state message');
            return;
        }

        console.log('Building knowledge list HTML...');

        let html = '<ul style="list-style: none; padding: 0; margin: 0;">';
        knowledgeAcquired.forEach(knowledge => {
            const displayName = formatDisplayName(knowledge.name || knowledge.title);
            html += `
                <li style="padding: 8px; margin-bottom: 6px; background: white; border-left: 3px solid #d4af37; border-radius: 4px; box-shadow: 0 1px 3px rgba(0,0,0,0.1);">
                    <div style="color: #d4af37; margin-bottom: 4px;">
                        📚 ${displayName}
                    </div>
                    <div style="font-size: 0.85rem; color: #4a5568; font-weight: normal;">
                        ${knowledge.description || 'Knowledge acquired'}
                    </div>
                </li>
            `;
        });
        html += '</ul>';

        knowledgeList.innerHTML = html;
        console.log('Knowledge list HTML updated. Final HTML length:', html.length);
        console.log('======= updateKnowledgeList END =======');
    }

    function updateItemsList() {
        const itemsList = document.getElementById('itemsList');
        const itemsCount = document.getElementById('itemsCount');

        // Update count badge
        if (itemsCount) {
            itemsCount.textContent = `(${itemsAcquired.length})`;
        }

        if (itemsAcquired.length === 0) {
            itemsList.innerHTML = '<p style="font-style: italic; color: #a0aec0;">No items acquired yet. Find treasures on your journey!</p>';
            return;
        }

        let html = '<ul style="list-style: none; padding: 0; margin: 0;">';
        itemsAcquired.forEach(item => {
            const displayName = formatDisplayName(item.name);
            html += `
                <li style="padding: 8px; margin-bottom: 6px; background: white; border-left: 3px solid #667eea; border-radius: 4px; box-shadow: 0 1px 3px rgba(0,0,0,0.1);">
                    <div style="color: #667eea; margin-bottom: 4px;">
                        🎒 ${displayName}
                    </div>
                    <div style="font-size: 0.85rem; color: #4a5568; font-weight: normal;">
                        ${item.description || 'Item in inventory'}
                    </div>
                </li>
            `;
        });
        html += '</ul>';

        itemsList.innerHTML = html;
    }

    function updateEncountersList() {
        const encountersList = document.getElementById('encountersList');
        const encountersCount = document.getElementById('encountersCount');

        // Update count badge
        if (encountersCount) {
            encountersCount.textContent = `(${encountersRecord.length})`;
        }

        if (encountersRecord.length === 0) {
            encountersList.innerHTML = '<p style="font-style: italic; color: #a0aec0;">No encounters yet. Explore to discover events, challenges, and characters!</p>';
            return;
        }

        // Define styling for each encounter type
        const encounterStyles = {
            'npc': {
                icon: '👥',
                color: '#48bb78',
                label: 'NPC'
            },
            'event': {
                icon: '🌟',
                color: '#f6ad55',
                label: 'Event'
            },
            'discovery': {
                icon: '🔍',
                color: '#4299e1',
                label: 'Discovery'
            },
            'challenge': {
                icon: '⚔️',
                color: '#ed64a6',
                label: 'Challenge'
            }
        };

        let html = '<ul style="list-style: none; padding: 0; margin: 0;">';
        encountersRecord.forEach(encounter => {
            const style = encounterStyles[encounter.type] || encounterStyles['npc'];
            const displayName = encounter.name || encounter.title || 'Unknown';
            const displayDescription = encounter.description || encounter.role || `${style.label} encountered`;

            html += `
                <li style="padding: 8px; margin-bottom: 6px; background: white; border-left: 3px solid ${style.color}; border-radius: 4px; box-shadow: 0 1px 3px rgba(0,0,0,0.1);">
                    <div style="color: ${style.color}; margin-bottom: 4px;">
                        ${style.icon} ${displayName}
                        <span style="font-size: 0.75rem; opacity: 0.8; margin-left: 6px;">[${style.label}]</span>
                    </div>
                    <div style="font-size: 0.85rem; color: #4a5568; font-weight: normal;">
                        ${displayDescription}
                    </div>
                </li>
            `;
        });
        html += '</ul>';

        encountersList.innerHTML = html;
    }

    // Store last action sent for display
    let lastActionSent = '';

    function sendPlayerAction() {
        const input = document.getElementById('playerInput');
        const action = input.value.trim();

        if (!action || !isConnected) return;

        // Store the action text before clearing
        lastActionSent = action;

        ws.send(JSON.stringify({
            event: 'player_action',
            content: action
        }));

        input.value = '';
        disableInput();
    }

    function handleSceneChunk(data) {
        const chatMessages = document.getElementById('chatMessages');

        if (!streamingMessageDiv) {
            streamingContent = "";
            streamingMessageDiv = document.createElement('div');
            streamingMessageDiv.className = 'chat-message message-dm';
            streamingMessageDiv.innerHTML = `
                <div class="message-sender">👤 Game Master</div>
                <div class="message-content" id="streamingContent"></div>
                <div class="message-time">${formatTime(new Date().toISOString())}</div>
            `;
            chatMessages.appendChild(streamingMessageDiv);
        }

        if (data.is_complete) {
            if (streamingMessageDiv) {
                const contentDiv = streamingMessageDiv.querySelector('.message-content');
                contentDiv.innerHTML = formatMessageContent(streamingContent);

                const plainText = contentDiv.innerText || contentDiv.textContent;
                addTTSButtonToMessage(streamingMessageDiv, plainText);

                if (autoPlayEnabled && !isFirstSceneLoad && plainText.length < 3000) {
                    setTimeout(() => {
                        playTextToSpeech(plainText, streamingMessageDiv);
                    }, 500);
                } else if (autoPlayEnabled && plainText.length >= 3000) {
                    console.log('Skipping auto-play: text too long (' + plainText.length + ' chars)');
                }

                isFirstSceneLoad = false;
            }

            streamingMessageDiv = null;
            streamingContent = "";
            return;
        }

        streamingContent += data.chunk;
        const contentDiv = streamingMessageDiv.querySelector('.message-content');
        contentDiv.innerHTML = formatMessageContent(streamingContent);

        if (!isFirstSceneLoad) {
            chatMessages.scrollTop = chatMessages.scrollHeight;
        }
    }

    // Handle streaming chunks for GM answers and action outcomes
    function handleStreamingChunk(data) {
        const chatMessages = document.getElementById('chatMessages');

        if (!streamingMessageDiv) {
            streamingContent = "";
            streamingMessageDiv = document.createElement('div');
            streamingMessageDiv.className = 'chat-message message-dm';
            streamingMessageDiv.innerHTML = `
                <div class="message-sender">👤 Game Master</div>
                <div class="message-content" id="streamingContent"></div>
                <div class="message-time">${formatTime(new Date().toISOString())}</div>
            `;
            chatMessages.appendChild(streamingMessageDiv);
        }

        if (data.is_complete) {
            if (streamingMessageDiv) {
                const contentDiv = streamingMessageDiv.querySelector('.message-content');
                contentDiv.innerHTML = formatMessageContent(streamingContent);

                const plainText = contentDiv.innerText || contentDiv.textContent;
                addTTSButtonToMessage(streamingMessageDiv, plainText);

                if (autoPlayEnabled && plainText.length < 3000) {
                    setTimeout(() => {
                        playTextToSpeech(plainText, streamingMessageDiv);
                    }, 500);
                } else if (autoPlayEnabled && plainText.length >= 3000) {
                    console.log('Skipping auto-play: text too long (' + plainText.length + ' chars)');
                }
            }

            streamingMessageDiv = null;
            streamingContent = "";
            return;
        }

        streamingContent += data.chunk;
        const contentDiv = streamingMessageDiv.querySelector('.message-content');
        contentDiv.innerHTML = formatMessageContent(streamingContent);

        chatMessages.scrollTop = chatMessages.scrollHeight;
    }

    function addChatMessage(message) {
        const chatMessages = document.getElementById('chatMessages');
        const messageDiv = document.createElement('div');
        messageDiv.className = 'chat-message';

        let messageClass = 'message-dm';
        let senderIcon = '👤';

        switch(message.message_type) {
            case 'PLAYER_ACTION':
                messageClass = 'message-player';
                senderIcon = '⚔️';
                break;
            case 'DM_NPC_DIALOGUE':
                messageClass = 'message-npc';
                senderIcon = '💬';
                break;
            case 'DM_ASSESSMENT':
                messageClass = 'message-assessment';
                senderIcon = '📊';
                break;
        }

        messageDiv.classList.add(messageClass);

        const formattedContent = formatMessageContent(message.content);

        messageDiv.innerHTML = `
            <div class="message-sender">${senderIcon} ${message.sender_name}</div>
            <div class="message-content">${formattedContent}</div>
            <div class="message-time">${formatTime(message.timestamp)}</div>
        `;

        chatMessages.appendChild(messageDiv);

        if (!isFirstSceneLoad) {
            chatMessages.scrollTop = chatMessages.scrollHeight;
        }
    }

    function addSystemMessage(text) {
        const chatMessages = document.getElementById('chatMessages');
        const messageDiv = document.createElement('div');
        messageDiv.className = 'chat-message message-dm';
        messageDiv.innerHTML = `
            <div class="message-content" style="font-style: italic; color: #718096;">
                ${escapeHtml(text)}
            </div>
        `;
        chatMessages.appendChild(messageDiv);

        if (!isFirstSceneLoad) {
            chatMessages.scrollTop = chatMessages.scrollHeight;
        }
    }

    function updateScene(data) {
        if (data.scene_description) {
            addChatMessage({
                message_type: 'DM_NARRATIVE',
                sender_name: 'Game Master',
                content: data.scene_description,
                timestamp: data.timestamp
            });

            isFirstSceneLoad = false;
        }

        if (data.available_actions) {
            updateAvailableActions(data.available_actions);
        }

        if (data.available_npcs) {
            updateNPCList(data.available_npcs);
        }

        // Update investigate panel scene data
        updateSceneData(data);

        // Enable investigate scene button
        const investigateBtn = document.getElementById('investigateSceneButton');
        if (investigateBtn) {
            investigateBtn.disabled = false;
        }
    }

    function updateQuestInfo(questId, questTitle, questDescription, questObjectives) {
        if ((!questTitle || questTitle === '' || questTitle === null || questTitle === undefined)) {
            if (CAMPAIGN_FIRST_QUEST) {
                questTitle = CAMPAIGN_FIRST_QUEST.title;
                questDescription = CAMPAIGN_FIRST_QUEST.description;
                questObjectives = CAMPAIGN_FIRST_QUEST.objectives;
            } else {
                questTitle = "ERROR: Quest Not Found";
                questDescription = "The campaign quest could not be loaded. Please contact support.";
                questObjectives = [];
            }
        }

        // Update header quest status
        const questElement = document.getElementById('currentQuest');
        if (questTitle) {
            questElement.textContent = questTitle;
        } else if (questId) {
            questElement.textContent = "Active Quest";
        } else {
            questElement.textContent = 'Free Exploration';
        }

        // Update drawer quest info - only show title, not description
        const drawerQuestInfoDiv = document.getElementById('drawerQuestInfo');
        if (questTitle) {
            drawerQuestInfoDiv.innerHTML = `<h4 style="margin: 0; color: #d4af37; font-size: 1.1rem;">${questTitle}</h4>`;

            // Show placeholder while waiting for WebSocket quest progress data
            if (questObjectives && questObjectives.length > 0) {
                if (lastQuestProgress) {
                    // Use cached backend data if available
                    updateQuestProgress(lastQuestProgress);
                } else {
                    // Show loading placeholder - will be replaced by WebSocket update
                    document.getElementById('drawerQuestObjectives').innerHTML = '<p style="color: #b8b8d1; font-size: 0.9rem;">Loading quest progress...</p>';
                }
            } else {
                document.getElementById('drawerQuestObjectives').innerHTML = '<p style="color: #b8b8d1; font-size: 0.9rem;">No specific objectives yet. Explore freely!</p>';
            }
        } else {
            drawerQuestInfoDiv.innerHTML = '<p style="color: #b8b8d1; font-style: italic;">No active quest. Explore the world!</p>';
        }
    }

    function calculateObjectiveProgress(objectiveText) {
        // Smart detection of objective progress based on text patterns
        const text = objectiveText.toLowerCase();
        let current = 0;
        let target = 1;
        let progress = 0;
        let detected = false;

        // Pattern 1: "Acquire/Find/Collect/Gather X knowledge/items/discoveries"
        const acquireMatch = text.match(/(?:acquire|find|collect|gather|obtain)\s+(\d+)\s+(knowledge|item|discovery|discoverie)/i);
        if (acquireMatch) {
            target = parseInt(acquireMatch[1]);
            const type = acquireMatch[2];
            if (type.includes('knowledge')) {
                current = knowledgeAcquired.length;
            } else if (type.includes('item')) {
                current = itemsAcquired.length;
            } else if (type.includes('discover')) {
                current = completedDiscoveries.size;
            }
            detected = true;
        }

        // Pattern 2: "Secure/Protect/Defend X buildings/locations/areas"
        const secureMatch = text.match(/(?:secure|protect|defend|fortify|establish|safeguard)\s+(?:.*?\s+)?(\d+|one|two|three|four|five|six|seven|eight|nine|ten|initial|first|second|third|a|an)\s+(?:\w+\s+)?(?:building|location|area|zone|position)/i);
        if (secureMatch && !detected) {
            const numText = secureMatch[1].toLowerCase();
            const numMap = { 'one': 1, 'two': 2, 'three': 3, 'four': 4, 'five': 5, 'six': 6, 'seven': 7, 'eight': 8, 'nine': 9, 'ten': 10, 'initial': 1, 'first': 1, 'second': 2, 'third': 3, 'a': 1, 'an': 1 };
            target = numMap[numText] || (isNaN(parseInt(numText)) ? 1 : parseInt(numText));

            // Count encounters related to securing/protecting (NOT discoveries)
            current = encountersRecord.filter(e =>
                e.type === 'event' || e.type === 'challenge'
            ).length;
            detected = true;
        }

        // Pattern 3: "Mediate/Resolve/Handle X conflicts/disputes"
        const mediateMatch = text.match(/(?:mediate|resolve|handle|settle|address)\s+(?:.*?\s+)?(\d+|one|two|three|four|five|first|second|a|an)\s+(?:\w+\s+)?(?:conflict|dispute|disagreement|argument|issue)/i);
        if (mediateMatch && !detected) {
            const numText = mediateMatch[1].toLowerCase();
            const numMap = { 'one': 1, 'two': 2, 'three': 3, 'four': 4, 'five': 5, 'first': 1, 'second': 2, 'a': 1, 'an': 1 };
            target = numMap[numText] || (isNaN(parseInt(numText)) ? 1 : parseInt(numText));

            // Count NPC encounters that could be mediations
            current = encountersRecord.filter(e => e.type === 'npc').length;
            detected = true;
        }

        // Pattern 4: "Collect/Document/Gather evidence/information/data"
        const collectEvidenceMatch = text.match(/(?:collect|document|gather|obtain|acquire)\s+(?:and\s+\w+\s+)?(?:initial|first|some|any|the)?\s*(?:evidence|information|data|proof|clues?)/i);
        if (collectEvidenceMatch && !detected) {
            target = 1; // Evidence collection is usually binary (collected or not)
            current = knowledgeAcquired.length > 0 ? 1 : 0;
            detected = true;
        }

        // Pattern 5: "Talk to/Meet/Find [NPC Name]"
        const npcMatch = text.match(/(?:talk to|meet|find|speak with)\s+(?:the\s+)?([a-z\s]+)/i);
        if (npcMatch && !detected) {
            const npcName = npcMatch[1].trim();
            current = encountersRecord.some(e =>
                e.type === 'npc' && e.name && e.name.toLowerCase().includes(npcName)
            ) ? 1 : 0;
            target = 1;
            detected = true;
        }

        // Pattern 6: "Investigate/Explore X discoveries/locations"
        const investigateMatch = text.match(/(?:investigate|explore|examine)\s+(\d+)\s+(discover|location|place)/i);
        if (investigateMatch && !detected) {
            target = parseInt(investigateMatch[1]);
            current = completedDiscoveries.size;
            detected = true;
        }

        // Pattern 7: "Complete/Solve X challenges/puzzles"
        const challengeMatch = text.match(/(?:complete|solve|finish)\s+(\d+)\s+(challenge|puzzle|task)/i);
        if (challengeMatch && !detected) {
            target = parseInt(challengeMatch[1]);
            current = completedChallenges.size;
            detected = true;
        }

        // Pattern 8: Generic numbered objective - "X anything"
        // This catches patterns like "three marketplace buildings", "two emerging conflicts", etc.
        const genericNumberMatch = text.match(/\b(\d+|one|two|three|four|five|six|seven|eight|nine|ten)\s+(?:\w+\s+)?(?:building|location|conflict|area|npc|character|person|group)/i);
        if (genericNumberMatch && !detected) {
            const numText = genericNumberMatch[1].toLowerCase();
            const numMap = { 'one': 1, 'two': 2, 'three': 3, 'four': 4, 'five': 5, 'six': 6, 'seven': 7, 'eight': 8, 'nine': 9, 'ten': 10 };
            target = numMap[numText] || parseInt(numText);

            // Use a combination of encounters and discoveries as progress
            current = encountersRecord.length + completedDiscoveries.size;
            detected = true;
        }

        // Pattern 9: Check for any specific item/knowledge name mentions
        if (!detected) {
            // Check if any acquired knowledge/item names are mentioned in objective
            for (const knowledge of knowledgeAcquired) {
                if (text.includes(knowledge.name.toLowerCase())) {
                    current = 1;
                    target = 1;
                    detected = true;
                    break;
                }
            }
        }

        if (!detected) {
            for (const item of itemsAcquired) {
                if (text.includes(item.name.toLowerCase())) {
                    current = 1;
                    target = 1;
                    detected = true;
                    break;
                }
            }
        }

        // Calculate progress percentage
        progress = target > 0 ? Math.min((current / target) * 100, 100) : 0;

        return {
            current,
            target,
            progress: Math.round(progress),
            detected
        };
    }

    function getProgressColorClass(progress) {
        if (progress >= 100) return 'progress-complete';
        if (progress >= 67) return 'progress-high';
        if (progress >= 34) return 'progress-medium';
        return 'progress-low';
    }

    function updateQuestObjectives(objectives) {
        const drawerObjectivesDiv = document.getElementById('drawerQuestObjectives');
        if (!objectives || objectives.length === 0) {
            drawerObjectivesDiv.innerHTML = '<p style="color: #b8b8d1; font-size: 0.9rem;">No specific objectives yet.</p>';
            return;
        }

        let totalProgress = 0;
        let objectivesHTML = '';

        objectives.forEach(objective => {
            const objectiveText = typeof objective === 'string' ? objective : objective.description;
            const isCompleted = objective.completed || false;
            const checkIcon = isCompleted ? '⚔️' : '🔸';
            const completedClass = isCompleted ? ' completed' : '';

            // Calculate progress for this objective
            const progressData = calculateObjectiveProgress(objectiveText);
            totalProgress += progressData.progress;

            // Build progress bar HTML
            let progressHTML = '';
            if (progressData.detected || progressData.progress > 0) {
                const colorClass = getProgressColorClass(progressData.progress);
                const percentText = `${progressData.current}/${progressData.target} - ${progressData.progress}%`;

                progressHTML = `
                    <div class="progress-bar-container">
                        <div class="progress-bar-fill ${colorClass}" style="width: ${progressData.progress}%"></div>
                    </div>
                `;

                objectivesHTML += `
                    <div class="quest-objective${completedClass}">
                        <span class="objective-checkbox">${checkIcon}</span>
                        <div class="objective-content">
                            <div class="objective-description">
                                <span>${objectiveText}</span>
                                <span class="objective-progress-percent ${colorClass.replace('progress-', 'text-')}">${percentText}</span>
                            </div>
                            ${progressHTML}
                        </div>
                    </div>
                `;
            } else {
                // No progress tracking detected, show simple objective
                objectivesHTML += `
                    <div class="quest-objective${completedClass}">
                        <span class="objective-checkbox">${checkIcon}</span>
                        <span class="objective-description">${objectiveText}</span>
                    </div>
                `;
            }
        });

        // Calculate overall quest progress
        const overallProgress = objectives.length > 0 ? Math.round(totalProgress / objectives.length) : 0;
        const overallColorClass = getProgressColorClass(overallProgress);

        // Add overall progress bar at the top
        const overallProgressHTML = `
            <div class="quest-overall-progress">
                <div class="quest-overall-progress-label">
                    <span>Quest Progress</span>
                    <span class="quest-overall-progress-percent">${overallProgress}%</span>
                </div>
                <div class="progress-bar-container">
                    <div class="progress-bar-fill ${overallColorClass}" style="width: ${overallProgress}%"></div>
                </div>
            </div>
        `;

        drawerObjectivesDiv.innerHTML = overallProgressHTML + objectivesHTML;
    }

    function updateQuestProgress(questProgress) {
        // Update quest progress display with actual backend data
        const drawerObjectivesDiv = document.getElementById('drawerQuestObjectives');

        if (!questProgress || !questProgress.objectives) {
            return;
        }

        // Store for future refreshes
        lastQuestProgress = questProgress;

        let objectivesHTML = '';
        const objectives = questProgress.objectives;

        objectives.forEach(objective => {
            const isCompleted = objective.completed || false;
            const checkIcon = isCompleted ? '⚔️' : '🔸';
            const completedClass = isCompleted ? ' completed' : '';
            const progress = objective.percent || 0;
            const colorClass = getProgressColorClass(progress);
            const percentText = `${objective.current}/${objective.total} - ${progress}%`;

            // Build progress bar HTML
            const progressHTML = `
                <div class="progress-bar-container">
                    <div class="progress-bar-fill ${colorClass}" style="width: ${progress}%"></div>
                </div>
            `;

            objectivesHTML += `
                <div class="quest-objective${completedClass}">
                    <span class="objective-checkbox">${checkIcon}</span>
                    <div class="objective-content">
                        <div class="objective-description">
                            <span>${objective.description}</span>
                            <span class="objective-progress-percent ${colorClass.replace('progress-', 'text-')}">${percentText}</span>
                        </div>
                        ${progressHTML}
                    </div>
                </div>
            `;
        });

        // Add overall progress bar at the top
        const overallProgress = questProgress.overall_progress || 0;
        const overallColorClass = getProgressColorClass(overallProgress);
        const overallProgressHTML = `
            <div class="quest-overall-progress">
                <div class="quest-overall-progress-label">
                    <span>Quest Progress</span>
                    <span class="quest-overall-progress-percent">${overallProgress}%</span>
                </div>
                <div class="progress-bar-container">
                    <div class="progress-bar-fill ${overallColorClass}" style="width: ${overallProgress}%"></div>
                </div>
            </div>
        `;

        drawerObjectivesDiv.innerHTML = overallProgressHTML + objectivesHTML;
    }

    function updateAvailableActions(actions) {
        const drawerActionsDiv = document.getElementById('drawerAvailableActions');

        if (!actions || actions.length === 0) {
            drawerActionsDiv.innerHTML = '<p style="color: #b8b8d1; font-size: 0.9rem;">No actions available yet.</p>';
            return;
        }

        drawerActionsDiv.innerHTML = '';

        actions.forEach(action => {
            const button = document.createElement('button');
            button.className = 'action-button';
            button.textContent = action;
            button.style.background = 'rgba(212, 175, 55, 0.2)';
            button.style.border = '2px solid rgba(212, 175, 55, 0.4)';
            button.style.color = '#d4af37';
            button.onclick = () => {
                document.getElementById('playerInput').value = action;
            };
            drawerActionsDiv.appendChild(button);
        });
    }

    function updateNPCList(npcs) {
        // Could add NPC list to UI
    }

    function updateGameState(data) {
        if (data.awaiting_player_input) {
            enableInput();
        }

        if (data.current_quest_id || data.quest_id) {
            updateQuestInfo(
                data.current_quest_id || data.quest_id,
                data.quest_title,
                data.quest_description,
                data.quest_objectives
            );
        }

        if (data.current_scene_id || data.current_location || data.location_name || data.scene_name || data.place_name) {
            let locationName = data.location_name || data.scene_name || data.place_name || data.current_location;

            if (!locationName && data.current_scene_id) {
                if (data.current_scene_id === 'starting_location') {
                    locationName = 'Starting Area';
                } else {
                    // Remove UUID-like strings and "Scene" prefix for cleaner display
                    locationName = data.current_scene_id
                        .replace(/[0-9a-f]{8,}/gi, '') // Remove UUID-like strings first
                        .replace(/^Scene\s*/i, '')  // Remove "Scene" prefix
                        .replace(/_/g, ' ')
                        .trim()
                        .replace(/\b\w/g, c => c.toUpperCase());

                    // If we end up with an empty string or just whitespace after cleanup, use a default
                    if (!locationName || locationName.length === 0 || locationName.trim() === '') {
                        locationName = 'Current Location';
                    }
                }
            }

            // Update both header and drawer locations
            document.getElementById('currentLocation').textContent = locationName || 'Exploring';
            const drawerLocation = document.getElementById('drawerLocation');
            if (drawerLocation) {
                drawerLocation.textContent = locationName || 'Exploring';
            }
        }

        if (data.blooms_level) {
            const bloomsLevel = data.blooms_level.charAt(0).toUpperCase() + data.blooms_level.slice(1);
            document.getElementById('headerBloomLevel').textContent = bloomsLevel;
            const rightDrawerBloomLevel = document.getElementById('rightDrawerBloomLevel');
            if (rightDrawerBloomLevel) {
                rightDrawerBloomLevel.textContent = bloomsLevel;
            }
        }

        if (data.party_members) {
            const partySize = Array.isArray(data.party_members) ? data.party_members.length : 1;
            document.getElementById('partySize').textContent = partySize === 1 ? '1 Hero' : `${partySize} Heroes`;
        }
    }

    async function fetchSessionState() {
        try {
            const response = await fetch(`http://localhost:9500/api/v1/session/${SESSION_ID}/state`);
            if (response.ok) {
                const state = await response.json();

                if (state.current_quest_id) {
                    updateQuestInfo(
                        state.current_quest_id,
                        state.quest_title,
                        state.quest_description,
                        state.quest_objectives
                    );
                }

                if (state.current_scene_id || state.current_location || state.location_name || state.scene_name || state.place_name) {
                    let locationName = state.location_name || state.scene_name || state.place_name || state.current_location;

                    if (!locationName && state.current_scene_id) {
                        if (state.current_scene_id === 'starting_location') {
                            locationName = 'Starting Area';
                        } else {
                            // Remove UUID-like strings and "Scene" prefix for cleaner display
                            locationName = state.current_scene_id
                                .replace(/[0-9a-f]{8,}/gi, '') // Remove UUID-like strings first
                                .replace(/^Scene\s*/i, '')  // Remove "Scene" prefix
                                .replace(/_/g, ' ')
                                .trim()
                                .replace(/\b\w/g, c => c.toUpperCase());

                            // If we end up with an empty string or just whitespace after cleanup, use a default
                            if (!locationName || locationName.length === 0 || locationName.trim() === '') {
                                locationName = 'Current Location';
                            }
                        }
                    }

                    // Update both header and drawer locations
                    document.getElementById('currentLocation').textContent = locationName || 'Exploring';
                    const drawerLocation = document.getElementById('drawerLocation');
                    if (drawerLocation) {
                        drawerLocation.textContent = locationName || 'Exploring';
                    }
                }

                if (state.blooms_level) {
                    const bloomsLevel = state.blooms_level.charAt(0).toUpperCase() + state.blooms_level.slice(1);
                    document.getElementById('headerBloomLevel').textContent = bloomsLevel;
                    const rightDrawerBloomLevel = document.getElementById('rightDrawerBloomLevel');
                    if (rightDrawerBloomLevel) {
                        rightDrawerBloomLevel.textContent = bloomsLevel;
                    }
                }

                if (state.party_members) {
                    const partySize = Array.isArray(state.party_members) ? state.party_members.length : 1;
                    document.getElementById('partySize').textContent = partySize === 1 ? '1 Hero' : `${partySize} Heroes`;
                }

                // Only add scene description if we have one
                // Don't clear initial welcome message
                if (state.scene_description) {
                    // Clear the welcome message first
                    const chatMessages = document.getElementById('chatMessages');
                    const welcomeMsg = chatMessages.querySelector('.chat-message');
                    if (welcomeMsg && welcomeMsg.textContent.includes('Welcome, adventurer')) {
                        chatMessages.innerHTML = '';
                    }

                    addChatMessage({
                        message_type: 'DM_NARRATIVE',
                        sender_name: 'Game Master',
                        content: state.scene_description,
                        timestamp: new Date().toISOString()
                    });

                    // Mark that we've loaded the first scene
                    isFirstSceneLoad = false;
                }

                if (state.available_actions && state.available_actions.length > 0) {
                    updateAvailableActions(state.available_actions);
                }

                if (state.awaiting_player_input) {
                    enableInput();
                }

                // Load persisted knowledge and items
                if (state.player_knowledge && state.players && state.players.length > 0) {
                    const playerId = state.players[0].player_id;
                    const playerKnowledgeData = state.player_knowledge[playerId];

                    if (playerKnowledgeData) {
                        // Handle two possible formats:
                        // 1. Array of full knowledge objects (new format from game-engine)
                        // 2. Dictionary of {knowledge_id: level} (old format)

                        if (Array.isArray(playerKnowledgeData)) {
                            // New format: Array of full knowledge objects
                            playerKnowledgeData.forEach(knowledgeObj => {
                                // Check if already in knowledgeAcquired
                                const knowledgeId = knowledgeObj.knowledge_id || knowledgeObj.id;
                                if (!knowledgeAcquired.some(k => k.id === knowledgeId)) {
                                    knowledgeAcquired.push({
                                        id: knowledgeId,
                                        name: knowledgeObj.name || 'Unknown Knowledge',
                                        description: knowledgeObj.description || 'Knowledge acquired',
                                        type: knowledgeObj.knowledge_type || 'general',
                                        source: 'From MongoDB'
                                    });
                                }
                            });
                        } else {
                            // Old format: Dictionary {knowledge_id: level}
                            const knowledgeIds = Object.keys(playerKnowledgeData);

                            knowledgeIds.forEach(knowledgeId => {
                                // Check if already in knowledgeAcquired
                                if (!knowledgeAcquired.some(k => k.id === knowledgeId)) {
                                    // Create a placeholder - ideally this shouldn't happen with new backend
                                    let displayName = knowledgeId.replace(/_/g, ' ').replace(/knowledge /gi, '');

                                    // If the name is just a number or too short, provide a better default
                                    if (!displayName || displayName.trim().length === 0 || /^\d+$/.test(displayName)) {
                                        displayName = 'Acquired Knowledge';
                                    }

                                    const knowledgeObj = {
                                        id: knowledgeId,
                                        name: displayName,
                                        description: 'Previously acquired knowledge from a past session',
                                        source: 'From previous session (placeholder)'
                                    };
                                    knowledgeAcquired.push(knowledgeObj);
                                }
                            });
                        }

                        // Update knowledge list UI
                        if (knowledgeAcquired.length > 0) {
                            updateKnowledgeList();
                        }
                    }
                }

                if (state.player_inventories && state.players && state.players.length > 0) {
                    const playerId = state.players[0].player_id;
                    const playerInventory = state.player_inventories[playerId] || [];

                    // Populate itemsAcquired array with full objects
                    playerInventory.forEach(item => {
                        // Format item object for frontend
                        const itemObj = {
                            id: item.item_id,
                            name: item.name,
                            description: item.description || '',
                            source: item.source || 'Found during your adventure'
                        };

                        // Add to itemsAcquired if not already present
                        if (!itemsAcquired.some(i => i.id === itemObj.id)) {
                            itemsAcquired.push(itemObj);
                        }
                    });

                    // Update items list UI
                    if (itemsAcquired.length > 0) {
                        updateItemsList();
                    }
                }

                // Load encounters from action history
                if (state.action_history && Array.isArray(state.action_history)) {
                    state.action_history.forEach(action => {
                        let encounterObj = null;

                        // Reconstruct encounters based on action type
                        if (action.action_type === 'investigate_discovery' && action.target_id) {
                            encounterObj = {
                                id: action.target_id,
                                type: 'discovery',
                                name: action.parameters?.discovery_name || action.target_id,
                                description: 'Discovery encountered during your journey',
                                timestamp: action.timestamp
                            };
                        } else if (action.action_type === 'talk' && action.target_id) {
                            encounterObj = {
                                id: action.target_id,
                                type: 'npc',
                                name: action.target_id.replace(/_/g, ' ').replace(/\b\w/g, c => c.toUpperCase()),
                                description: 'NPC encountered during your journey',
                                timestamp: action.timestamp
                            };
                        } else if (action.action_type === 'attempt_challenge' && action.target_id) {
                            encounterObj = {
                                id: action.target_id,
                                type: 'challenge',
                                name: action.target_id.replace(/_/g, ' ').replace(/\b\w/g, c => c.toUpperCase()),
                                description: 'Challenge encountered during your journey',
                                timestamp: action.timestamp
                            };
                        }

                        // Add to encountersRecord if not already present
                        if (encounterObj && !encountersRecord.some(e => e.id === encounterObj.id && e.type === encounterObj.type)) {
                            encountersRecord.push(encounterObj);
                        }
                    });
                }

                // Also load from conversation history (for NPC dialogues)
                if (state.conversation_history && Array.isArray(state.conversation_history)) {
                    state.conversation_history.forEach(turn => {
                        if (turn.npc_id) {
                            const encounterObj = {
                                id: turn.npc_id,
                                type: 'npc',
                                name: turn.npc_id.replace(/_/g, ' ').replace(/\b\w/g, c => c.toUpperCase()),
                                description: 'NPC encountered during your journey',
                                timestamp: turn.timestamp
                            };

                            // Add to encountersRecord if not already present
                            if (!encountersRecord.some(e => e.id === encounterObj.id && e.type === 'npc')) {
                                encountersRecord.push(encounterObj);
                            }
                        }
                    });
                }

                // Load from event log
                if (state.event_log && Array.isArray(state.event_log)) {
                    state.event_log.forEach(event => {
                        const encounterObj = {
                            id: event.event_id,
                            type: event.event_type || 'event',
                            name: event.description || 'Event',
                            description: event.description || '',
                            timestamp: event.timestamp
                        };

                        // Add to encountersRecord if not already present
                        if (!encountersRecord.some(e => e.id === encounterObj.id)) {
                            encountersRecord.push(encounterObj);
                        }
                    });
                }

                // Update encounters list UI
                if (encountersRecord.length > 0) {
                    updateEncountersList();
                }

                // Refresh quest progress after loading all data
                refreshQuestProgress();
            }
        } catch (error) {
            console.error('Failed to fetch session state:', error);
        }
    }

    function handleQuestComplete(data) {
        addSystemMessage(`🎉 Quest Complete: ${data.quest_title}!`);
        if (data.rewards) {
            addSystemMessage(`Rewards: ${JSON.stringify(data.rewards)}`);
        }
    }

    function handleDynamicEvent(event) {
        addChatMessage({
            message_type: 'DM_NARRATIVE',
            sender_name: 'Game Master',
            content: `⚡ ${event.title}\n\n${event.description}`,
            timestamp: event.triggered_at
        });

        if (event.choices && event.choices.length > 0) {
            const actionsDiv = document.getElementById('availableActions');
            event.choices.forEach(choice => {
                const button = document.createElement('button');
                button.className = 'action-button';
                button.textContent = choice.text;
                button.onclick = () => {
                    ws.send(JSON.stringify({
                        event: 'resolve_event',
                        event_id: event.event_id,
                        choice_id: choice.choice_id
                    }));
                };
                actionsDiv.appendChild(button);
            });
        }
    }

    function handleChallenge(challenge) {
        addChatMessage({
            message_type: 'DM_NARRATIVE',
            sender_name: 'Game Master',
            content: `⚔️ Challenge: ${challenge.title}\n\n${challenge.description}\n\nSuccess Criteria: ${challenge.success_criteria}`,
            timestamp: challenge.created_at
        });
    }

    function setupEventListeners() {
        document.getElementById('sendButton').addEventListener('click', sendPlayerAction);

        document.getElementById('playerInput').addEventListener('keydown', function(e) {
            if (e.key === 'Enter' && !e.shiftKey) {
                e.preventDefault();
                sendPlayerAction();
            }
        });
    }

    function enableInput() {
        document.getElementById('playerInput').disabled = false;
        document.getElementById('sendButton').disabled = false;
        document.getElementById('micButton').disabled = false;

        const investigateBtn = document.getElementById('investigateSceneButton');
        if (investigateBtn) {
            investigateBtn.disabled = false;
        }
    }

    function disableInput() {
        document.getElementById('sendButton').disabled = true;
    }

    function updateConnectionStatus(status) {
        const statusDiv = document.getElementById('connectionStatus');

        switch(status) {
            case 'connected':
                statusDiv.textContent = '🟢 Connected';
                statusDiv.className = 'connection-status';
                break;
            case 'connecting':
                statusDiv.textContent = '🟡 Connecting...';
                statusDiv.className = 'connection-status';
                break;
            case 'disconnected':
            case 'error':
                statusDiv.textContent = '🔴 Disconnected';
                statusDiv.className = 'connection-status disconnected';
                break;
        }
    }

    function showTypingIndicator(isTyping) {
        const indicator = document.getElementById('typingIndicator');
        indicator.style.display = isTyping ? 'block' : 'none';
    }

    function escapeHtml(text) {
        const div = document.createElement('div');
        div.textContent = text;
        return div.innerHTML;
    }

    function formatMessageContent(text) {
        let html = text;

        html = html.replace(/^# (.+)$/gm, '<h2 style="font-size: 1.4rem; font-weight: bold; margin: 1.5rem 0 1rem 0; color: #2d3748;">$1</h2>');
        html = html.replace(/^## (.+)$/gm, '<h3 style="font-size: 1.2rem; font-weight: bold; margin: 1.25rem 0 0.75rem 0; color: #4a5568;">$1</h3>');
        html = html.replace(/^### (.+)$/gm, '<h4 style="font-size: 1.1rem; font-weight: bold; margin: 1rem 0 0.5rem 0; color: #4a5568;">$1</h4>');
        html = html.replace(/\*\*(.+?)\*\*/g, '<strong>$1</strong>');
        html = html.replace(/^[•\-] (.+)$/gm, '<li style="margin-left: 1.5rem; margin-bottom: 0.25rem;">$1</li>');
        html = html.replace(/(<li[^>]*>.*<\/li>\n?)+/g, '<ul style="margin: 0.5rem 0; padding-left: 0; list-style-position: inside;">$&</ul>');
        html = html.replace(/\n\n/g, '</p><p style="margin-bottom: 1rem; line-height: 1.6;">');
        html = html.replace(/\n/g, '<br>');
        html = '<p style="margin-bottom: 1rem; line-height: 1.6;">' + html + '</p>';
        html = html.replace(/<p[^>]*><\/p>/g, '');

        return html;
    }

    function formatTime(timestamp) {
        const date = new Date(timestamp);
        return date.toLocaleTimeString();
    }

    // ============================================
    // TTS (Text-to-Speech) Functions
    // ============================================

    function toggleAutoPlay() {
        autoPlayEnabled = !autoPlayEnabled;
        const button = document.getElementById('autoPlayToggle');
        if (autoPlayEnabled) {
            button.textContent = '🔊 Auto-Play';
            button.classList.add('playing');
        } else {
            button.textContent = '🔇 Auto-Play';
            button.classList.remove('playing');
        }
        localStorage.setItem('tts_autoplay', autoPlayEnabled);
    }

    async function playTextToSpeech(text, messageElement) {
        try {
            if (currentAudio) {
                currentAudio.pause();
                currentAudio = null;
            }

            let button = null;
            if (messageElement) {
                button = messageElement.querySelector('.message-tts-button');
                if (button) {
                    button.disabled = true;
                    button.classList.add('loading');
                    button.textContent = '⏳ Loading...';
                }
            }

            const controller = new AbortController();
            const timeoutId = setTimeout(() => controller.abort(), 60000);

            const response = await fetch(`http://localhost:9500/api/v1/tts/generate`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                    text: text,
                    voice_type: voiceType
                }),
                signal: controller.signal
            });

            clearTimeout(timeoutId);

            if (!response.ok) {
                console.error('TTS generation failed:', response.statusText);
                if (button) {
                    button.disabled = false;
                    button.classList.remove('loading');
                    button.textContent = '❌ Failed';
                    setTimeout(() => {
                        button.textContent = '🔊 Listen';
                    }, 2000);
                }
                return;
            }

            const audioBlob = await response.blob();
            const audioUrl = URL.createObjectURL(audioBlob);
            currentAudio = new Audio(audioUrl);
            currentAudio.playbackRate = playbackSpeed;

            if (button) {
                button.disabled = false;
                button.classList.remove('loading');
                button.classList.add('playing');
                button.textContent = '⏸️ Stop';
            }

            await currentAudio.play();

            currentAudio.onended = () => {
                URL.revokeObjectURL(audioUrl);
                currentAudio = null;
                if (button) {
                    button.classList.remove('playing');
                    button.textContent = '🔊 Listen';
                }
            };

            currentAudio.onerror = () => {
                URL.revokeObjectURL(audioUrl);
                currentAudio = null;
                if (button) {
                    button.classList.remove('playing');
                    button.textContent = '❌ Error';
                    setTimeout(() => {
                        button.textContent = '🔊 Listen';
                    }, 2000);
                }
            };

        } catch (error) {
            console.error('Error playing TTS:', error);

            if (error.name === 'AbortError') {
                console.error('TTS request timed out');
                if (messageElement) {
                    const button = messageElement.querySelector('.message-tts-button');
                    if (button) {
                        button.disabled = false;
                        button.classList.remove('loading');
                        button.textContent = '⏱️ Timeout';
                        setTimeout(() => {
                            button.textContent = '🔊 Listen';
                        }, 3000);
                    }
                }
            } else {
                if (messageElement) {
                    const button = messageElement.querySelector('.message-tts-button');
                    if (button) {
                        button.disabled = false;
                        button.classList.remove('loading');
                        button.textContent = '❌ Error';
                        setTimeout(() => {
                            button.textContent = '🔊 Listen';
                        }, 2000);
                    }
                }
            }
        }
    }

    function addTTSButtonToMessage(messageDiv, text) {
        const contentDiv = messageDiv.querySelector('.message-content');
        if (!contentDiv) return;

        const ttsButton = document.createElement('button');
        ttsButton.className = 'message-tts-button';
        ttsButton.textContent = '🔊 Listen';
        ttsButton.onclick = function() {
            if (currentAudio && !currentAudio.paused) {
                currentAudio.pause();
                currentAudio = null;
                this.classList.remove('playing');
                this.textContent = '🔊 Listen';
            } else {
                const plainText = contentDiv.innerText || contentDiv.textContent;
                playTextToSpeech(plainText, messageDiv);
            }
        };

        const timeDiv = messageDiv.querySelector('.message-time');
        if (timeDiv) {
            timeDiv.appendChild(ttsButton);
        }
    }

    // ============================================
    // STT (Speech-to-Text) Functions
    // ============================================

    async function toggleMicrophone() {
        if (isRecording) {
            stopRecording();
        } else {
            await startRecording();
        }
    }

    async function startRecording() {
        try {
            const stream = await navigator.mediaDevices.getUserMedia({ audio: true });

            mediaRecorder = new MediaRecorder(stream);
            audioChunks = [];

            mediaRecorder.ondataavailable = (event) => {
                audioChunks.push(event.data);
            };

            mediaRecorder.onstop = async () => {
                const audioBlob = new Blob(audioChunks, { type: 'audio/webm' });
                await transcribeAudio(audioBlob);

                stream.getTracks().forEach(track => track.stop());
            };

            mediaRecorder.start();
            isRecording = true;

            const micButton = document.getElementById('micButton');
            micButton.classList.add('recording');
            micButton.textContent = '⏹️';

        } catch (error) {
            console.error('Error accessing microphone:', error);
            alert('Could not access microphone. Please check your permissions.');
        }
    }

    function stopRecording() {
        if (mediaRecorder && isRecording) {
            mediaRecorder.stop();
            isRecording = false;

            const micButton = document.getElementById('micButton');
            micButton.classList.remove('recording');
            micButton.textContent = '🎤';
        }
    }

    async function transcribeAudio(audioBlob) {
        try {
            const formData = new FormData();
            formData.append('audio', audioBlob, 'recording.webm');
            formData.append('language', 'en');

            const response = await fetch(`http://localhost:9500/api/v1/stt/session/${SESSION_ID}/player-action?player_id=${PLAYER_ID}`, {
                method: 'POST',
                body: formData
            });

            if (!response.ok) {
                console.error('STT transcription failed:', response.statusText);
                return;
            }

            const result = await response.json();

            if (result.success && result.text) {
                document.getElementById('playerInput').value = result.text;
                console.log('Transcribed:', result.text);
            }

        } catch (error) {
            console.error('Error transcribing audio:', error);
            alert('Failed to transcribe audio. Please try again.');
        }
    }

    // ============================================
    // Settings Modal Functions
    // ============================================

    function openSettingsModal() {
        const modal = document.getElementById('settingsModal');

        document.getElementById('voiceTypeSelect').value = voiceType;
        document.getElementById('playbackSpeedRange').value = playbackSpeed;
        document.getElementById('speedValue').textContent = playbackSpeed + 'x';
        document.getElementById('autoPlayCheckbox').checked = autoPlayEnabled;

        modal.classList.add('show');
    }

    function closeSettingsModal() {
        const modal = document.getElementById('settingsModal');
        modal.classList.remove('show');
    }

    function saveSettings() {
        voiceType = document.getElementById('voiceTypeSelect').value;
        playbackSpeed = parseFloat(document.getElementById('playbackSpeedRange').value);
        autoPlayEnabled = document.getElementById('autoPlayCheckbox').checked;

        const button = document.getElementById('autoPlayToggle');
        if (autoPlayEnabled) {
            button.textContent = '🔊 Auto-Play';
            button.classList.add('playing');
        } else {
            button.textContent = '🔇 Auto-Play';
            button.classList.remove('playing');
        }

        localStorage.setItem('tts_voice_type', voiceType);
        localStorage.setItem('tts_playback_speed', playbackSpeed);
        localStorage.setItem('tts_autoplay', autoPlayEnabled);

        closeSettingsModal();
    }

    function updateAutoPlayFromCheckbox() {
        autoPlayEnabled = document.getElementById('autoPlayCheckbox').checked;
    }

    function loadSettings() {
        const savedVoiceType = localStorage.getItem('tts_voice_type');
        const savedSpeed = localStorage.getItem('tts_playback_speed');
        const savedAutoPlay = localStorage.getItem('tts_autoplay');

        if (savedVoiceType) voiceType = savedVoiceType;
        if (savedSpeed) playbackSpeed = parseFloat(savedSpeed);
        if (savedAutoPlay) autoPlayEnabled = savedAutoPlay === 'true';

        const button = document.getElementById('autoPlayToggle');
        if (autoPlayEnabled) {
            button.textContent = '🔊 Auto-Play';
            button.classList.add('playing');
        }
    }

    // ============================================
    // Enhanced addChatMessage to support TTS
    // ============================================

    const originalAddChatMessage = addChatMessage;
    addChatMessage = function(message) {
        originalAddChatMessage(message);

        if (message.message_type === 'DM_NARRATIVE') {
            const chatMessages = document.getElementById('chatMessages');
            const lastMessage = chatMessages.lastElementChild;

            if (lastMessage) {
                const contentDiv = lastMessage.querySelector('.message-content');
                if (contentDiv) {
                    const plainText = contentDiv.innerText || contentDiv.textContent;
                    addTTSButtonToMessage(lastMessage, plainText);

                    if (autoPlayEnabled && !isFirstSceneLoad && plainText.length < 5000) {
                        setTimeout(() => {
                            playTextToSpeech(plainText, lastMessage);
                        }, 500);
                    } else if (autoPlayEnabled && plainText.length >= 5000) {
                        console.log('Skipping auto-play: text too long (' + plainText.length + ' chars)');
                    }
                }
            }
        }
    };
</script>
{% endblock %}
