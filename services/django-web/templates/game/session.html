{% extends 'base.html' %}
{% load static %}

{% block title %}Game Session - {{ campaign.title }}{% endblock %}

{% block extra_css %}
<style>
    .game-container {
        display: grid;
        grid-template-columns: 2fr 1fr;
        grid-template-rows: auto 1fr auto;
        gap: 1rem;
        height: calc(100vh - 120px);
        padding: 1rem;
    }

    .game-header {
        grid-column: 1 / -1;
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        color: white;
        border-radius: 8px;
        box-shadow: 0 4px 6px rgba(0,0,0,0.1);
        overflow: hidden;
    }

    .campaign-info-row {
        display: flex;
        align-items: center;
        gap: 1rem;
        padding: 0.75rem 1rem;
        border-bottom: 1px solid rgba(255,255,255,0.2);
    }

    .campaign-thumbnail {
        width: 60px;
        height: 60px;
        object-fit: cover;
        border-radius: 6px;
        border: 2px solid rgba(255,255,255,0.3);
        flex-shrink: 0;
    }

    .campaign-details {
        flex: 1;
    }

    .campaign-details h1 {
        margin: 0 0 0.25rem 0;
        font-size: 1.3rem;
    }

    .campaign-details .description {
        margin: 0;
        opacity: 0.9;
        font-size: 0.85rem;
        line-height: 1.4;
    }

    .game-status-row {
        display: grid;
        grid-template-columns: repeat(4, 1fr);
        gap: 0.75rem;
        padding: 0.75rem 1rem;
        background: rgba(0,0,0,0.1);
    }

    .status-item {
        display: flex;
        flex-direction: column;
        gap: 0.25rem;
    }

    .status-label {
        font-size: 0.7rem;
        opacity: 0.8;
        text-transform: uppercase;
        letter-spacing: 0.5px;
    }

    .status-value {
        font-size: 0.9rem;
        font-weight: bold;
    }

    .chat-panel {
        background: white;
        border-radius: 8px;
        box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        display: flex;
        flex-direction: column;
        overflow: hidden;
        min-height: 500px;
    }

    .chat-header {
        background: #667eea;
        color: white;
        padding: 1rem;
        font-weight: bold;
        flex-shrink: 0;
    }

    .chat-panel .chat-messages {
        flex: 1 1 auto;
        overflow-y: auto;
        padding: 1rem;
        background: #f7fafc;
        min-height: 300px;
        display: block !important;
    }

    .chat-message {
        margin-bottom: 1rem;
        animation: fadeIn 0.3s;
    }

    @keyframes fadeIn {
        from { opacity: 0; transform: translateY(10px); }
        to { opacity: 1; transform: translateY(0); }
    }

    .message-dm {
        background: #edf2f7;
        border-left: 4px solid #667eea;
        padding: 0.75rem 1rem;
        border-radius: 4px;
        display: flex;
        flex-direction: column;
    }

    .message-player {
        background: #e6fffa;
        border-left: 4px solid #38b2ac;
        padding: 0.75rem 1rem;
        border-radius: 4px;
        display: flex;
        flex-direction: column;
    }

    .message-npc {
        background: #fffaf0;
        border-left: 4px solid #ed8936;
        padding: 0.75rem 1rem;
        border-radius: 4px;
        display: flex;
        flex-direction: column;
    }

    .message-assessment {
        background: #fef5e7;
        border-left: 4px solid #f6ad55;
        padding: 0.75rem 1rem;
        border-radius: 4px;
        display: flex;
        flex-direction: column;
    }

    .message-sender {
        font-weight: bold;
        margin-bottom: 0.25rem;
        color: #2d3748;
        font-size: 0.875rem;
        display: block;
    }

    .message-content {
        color: #4a5568;
        line-height: 1.6;
        display: block;
        word-wrap: break-word;
        font-size: 0.9rem;
    }

    .message-time {
        font-size: 0.75rem;
        color: #a0aec0;
        margin-top: 0.5rem;
    }

    .chat-input-container {
        padding: 1rem;
        background: white;
        border-top: 1px solid #e2e8f0;
    }

    .chat-input {
        width: 100%;
        padding: 0.75rem;
        border: 2px solid #e2e8f0;
        border-radius: 4px;
        font-size: 1rem;
        resize: none;
    }

    .chat-input:focus {
        outline: none;
        border-color: #667eea;
    }

    .send-button {
        margin-top: 0.5rem;
        width: 100%;
        padding: 0.75rem;
        background: #667eea;
        color: white;
        border: none;
        border-radius: 4px;
        font-weight: bold;
        cursor: pointer;
        transition: background 0.2s;
    }

    .send-button:hover {
        background: #5a67d8;
    }

    .send-button:disabled {
        background: #cbd5e0;
        cursor: not-allowed;
    }

    .info-panel {
        background: white;
        border-radius: 8px;
        box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        overflow-y: auto;
    }

    .info-tabs {
        display: flex;
        background: #edf2f7;
        border-bottom: 2px solid #e2e8f0;
    }

    .info-tab {
        flex: 1;
        padding: 1rem;
        text-align: center;
        cursor: pointer;
        font-weight: bold;
        color: #4a5568;
        transition: all 0.2s;
    }

    .info-tab.active {
        background: white;
        color: #667eea;
        border-bottom: 3px solid #667eea;
    }

    .info-tab:hover {
        background: #f7fafc;
    }

    .info-content {
        padding: 1rem;
        display: none;
    }

    .info-content.active {
        display: block;
    }

    .quest-tracker {
        margin-bottom: 1rem;
    }

    .quest-objective {
        padding: 0.75rem;
        background: #f7fafc;
        border-radius: 4px;
        margin-bottom: 0.5rem;
        display: flex;
        align-items: center;
        color: #2d3748;
    }

    .quest-objective.completed {
        background: #c6f6d5;
        text-decoration: line-through;
        opacity: 0.7;
    }

    .objective-checkbox {
        margin-right: 0.75rem;
        font-size: 1.2rem;
    }

    .character-stat {
        display: flex;
        justify-content: space-between;
        padding: 0.5rem;
        border-bottom: 1px solid #e2e8f0;
    }

    .stat-label {
        font-weight: bold;
        color: #4a5568;
        font-size: 1.05rem;
    }

    .stat-value {
        color: #667eea !important;
        font-size: 0.95rem !important;
        font-weight: normal !important;
    }

    .available-actions {
        margin-top: 1rem;
    }

    .action-button {
        display: block;
        width: 100%;
        padding: 0.75rem;
        margin-bottom: 0.5rem;
        background: #f7fafc;
        border: 2px solid #e2e8f0;
        border-radius: 4px;
        cursor: pointer;
        transition: all 0.2s;
    }

    .action-button:hover {
        background: #edf2f7;
        border-color: #667eea;
    }

    .connection-status {
        position: fixed;
        top: 80px;
        right: 20px;
        padding: 0.5rem 1rem;
        background: #48bb78;
        color: white;
        border-radius: 4px;
        font-size: 0.875rem;
        z-index: 1000;
    }

    .connection-status.disconnected {
        background: #f56565;
    }

    .typing-indicator {
        padding: 1rem;
        color: #a0aec0;
        font-style: italic;
        font-size: 0.875rem;
    }

    .info-content h3 {
        font-size: 1.3rem;
        font-weight: bold;
        color: #2d3748;
        margin: 0 0 1rem 0;
    }

    .info-content h4 {
        font-size: 1rem;
        font-weight: bold;
        color: #4a5568;
        margin: 1rem 0 0.5rem 0;
    }

    /* TTS/STT Controls */
    .tts-controls {
        display: flex;
        gap: 0.5rem;
        margin-left: auto;
    }

    .tts-button, .stt-button {
        padding: 0.4rem 0.8rem;
        background: rgba(255, 255, 255, 0.2);
        color: white;
        border: 2px solid rgba(255, 255, 255, 0.3);
        border-radius: 4px;
        cursor: pointer;
        font-size: 0.85rem;
        transition: all 0.2s;
        display: flex;
        align-items: center;
        gap: 0.25rem;
    }

    .tts-button:hover, .stt-button:hover {
        background: rgba(255, 255, 255, 0.3);
    }

    .tts-button.playing {
        background: #48bb78;
        border-color: #48bb78;
    }

    .stt-button.recording {
        background: #f56565;
        border-color: #f56565;
        animation: pulse 1.5s infinite;
    }

    @keyframes pulse {
        0%, 100% { opacity: 1; }
        50% { opacity: 0.7; }
    }

    .message-tts-button {
        display: inline-flex;
        align-items: center;
        gap: 0.25rem;
        padding: 0.25rem 0.5rem;
        background: #e2e8f0;
        color: #4a5568;
        border: none;
        border-radius: 4px;
        cursor: pointer;
        font-size: 0.75rem;
        margin-left: 0.5rem;
        transition: all 0.2s;
    }

    .message-tts-button:hover {
        background: #cbd5e0;
    }

    .message-tts-button.playing {
        background: #48bb78;
        color: white;
    }

    .input-controls {
        display: flex;
        gap: 0.5rem;
        margin-top: 0.5rem;
    }

    .mic-button {
        flex-shrink: 0;
        padding: 0.75rem;
        background: #667eea;
        color: white;
        border: none;
        border-radius: 4px;
        cursor: pointer;
        transition: background 0.2s;
        font-size: 1rem;
    }

    .mic-button:hover {
        background: #5a67d8;
    }

    .mic-button.recording {
        background: #f56565;
        animation: pulse 1.5s infinite;
    }

    .mic-button:disabled {
        background: #cbd5e0;
        cursor: not-allowed;
    }

    /* Settings Modal */
    .settings-modal {
        display: none;
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0, 0, 0, 0.5);
        z-index: 2000;
        justify-content: center;
        align-items: center;
    }

    .settings-modal.show {
        display: flex;
    }

    .settings-content {
        background: white;
        padding: 2rem;
        border-radius: 8px;
        max-width: 500px;
        width: 90%;
    }

    .settings-option {
        margin-bottom: 1.5rem;
    }

    .settings-option label {
        display: block;
        font-weight: bold;
        margin-bottom: 0.5rem;
        color: #2d3748;
    }

    .settings-option select,
    .settings-option input[type="range"] {
        width: 100%;
        padding: 0.5rem;
        border: 2px solid #e2e8f0;
        border-radius: 4px;
        font-size: 1rem;
    }

    .settings-buttons {
        display: flex;
        gap: 1rem;
        margin-top: 2rem;
    }

    .settings-buttons button {
        flex: 1;
        padding: 0.75rem;
        border: none;
        border-radius: 4px;
        font-weight: bold;
        cursor: pointer;
        transition: all 0.2s;
    }

    .save-settings {
        background: #667eea;
        color: white;
    }

    .save-settings:hover {
        background: #5a67d8;
    }

    .cancel-settings {
        background: #e2e8f0;
        color: #4a5568;
    }

    .cancel-settings:hover {
        background: #cbd5e0;
    }
</style>
{% endblock %}

{% block content %}
<!-- Save/Load Component -->
{% include 'game/components/save_load.html' %}

<div id="connectionStatus" class="connection-status disconnected">
    Connecting...
</div>

<div class="game-container">
    <div class="game-header">
        <!-- Campaign Info Row -->
        <div class="campaign-info-row">
            {% if campaign.primary_image_url %}
            <img src="{{ campaign.primary_image_url }}" alt="{{ campaign.title }}" class="campaign-thumbnail">
            {% elif campaign.campaign_images %}
            <img src="{{ campaign.campaign_images.0.url }}" alt="{{ campaign.title }}" class="campaign-thumbnail">
            {% else %}
            <div class="campaign-thumbnail" style="background: linear-gradient(135deg, #4a5568 0%, #2d3748 100%); display: flex; align-items: center; justify-content: center; font-size: 2rem;">
                üé≤
            </div>
            {% endif %}
            <div class="campaign-details">
                <h1>{{ campaign.title }}</h1>
                <p class="description">{{ campaign.description|truncatewords:20|default:"Embark on an epic adventure in this AI-powered campaign!" }}</p>
            </div>
            <button onclick="openSaveLoadModal()" style="
                padding: 0.6rem 1.2rem;
                background: rgba(255, 255, 255, 0.2);
                color: white;
                border: 2px solid rgba(255, 255, 255, 0.3);
                border-radius: 6px;
                font-weight: 600;
                cursor: pointer;
                font-size: 0.9rem;
                transition: all 0.2s;
                white-space: nowrap;
                height: fit-content;
            " onmouseover="this.style.background='rgba(255, 255, 255, 0.3)'" onmouseout="this.style.background='rgba(255, 255, 255, 0.2)'">
                üíæ Save/Load
            </button>
        </div>

        <!-- Status Row -->
        <div class="game-status-row">
            <div class="status-item">
                <div class="status-label">Current Quest</div>
                <div class="status-value" id="currentQuest">Loading...</div>
            </div>
            <div class="status-item">
                <div class="status-label">Location</div>
                <div class="status-value" id="currentLocation">Unknown</div>
            </div>
            <div class="status-item">
                <div class="status-label">Party Size</div>
                <div class="status-value" id="partySize">1 Hero</div>
            </div>
            <div class="status-item">
                <div class="status-label">Bloom Level</div>
                <div class="status-value" id="headerBloomLevel">{{ character.blooms_level|title }}</div>
            </div>
        </div>
    </div>

    <div class="chat-panel">
        <div class="chat-header" style="display: flex; align-items: center;">
            <span>üë§ Game Master's Narration</span>
            <div class="tts-controls">
                <button class="tts-button" id="autoPlayToggle" onclick="toggleAutoPlay()" title="Auto-play narration">
                    üîá Auto-Play
                </button>
                <button class="tts-button" onclick="openSettingsModal()" title="TTS/STT Settings">
                    ‚öôÔ∏è
                </button>
            </div>
        </div>
        <div class="chat-messages" id="chatMessages">
            <div class="chat-message message-dm">
                <div class="message-sender">üë§ Game Master</div>
                <div class="message-content">
                    Welcome, adventurer! Connecting to the game world...
                </div>
            </div>
        </div>
        <div id="typingIndicator" class="typing-indicator" style="display: none;">
            Someone is typing...
        </div>
        <div class="chat-input-container">
            <textarea id="playerInput" class="chat-input" rows="3" placeholder="What do you do?" disabled></textarea>
            <div class="input-controls">
                <button id="micButton" class="mic-button" onclick="toggleMicrophone()" disabled title="Voice input">
                    üé§
                </button>
                <button id="sendButton" class="send-button" disabled style="flex: 1;">Send Action</button>
            </div>
        </div>
    </div>

    <div class="info-panel">
        <div class="info-tabs">
            <div class="info-tab active" data-tab="quest">Quest</div>
            <div class="info-tab" data-tab="character">Character</div>
            <div class="info-tab" data-tab="party">Party</div>
            <div class="info-tab" data-tab="progress">Progress</div>
        </div>

        <div class="info-content active" data-content="quest">
            <div id="questInfo">
                <p>Loading quest information...</p>
            </div>
            <h4>Objectives</h4>
            <div id="questObjectives" class="quest-tracker">
                <!-- Objectives will be populated -->
            </div>
            <h4>Available Actions</h4>
            <div id="availableActions" class="available-actions">
                <!-- Actions will be populated -->
            </div>
        </div>

        <div class="info-content" data-content="character">
            <h3>{{ character.name }}</h3>
            <div id="characterStats">
                <div class="character-stat">
                    <span class="stat-label">Species:</span>
                    <span class="stat-value">{{ character.species.name }}</span>
                </div>
                <div class="character-stat">
                    <span class="stat-label">Bloom's Level:</span>
                    <span class="stat-value" id="bloomLevel">Understand</span>
                </div>
                <div class="character-stat">
                    <span class="stat-label">Experience:</span>
                    <span class="stat-value" id="experiencePoints">0 XP</span>
                </div>
            </div>
            <h4>Inventory</h4>
            <div id="inventory">
                <p>Empty</p>
            </div>
        </div>

        <div class="info-content" data-content="party">
            <!-- Team Chat Component -->
            {% include 'game/components/team_chat.html' %}
        </div>

        <div class="info-content" data-content="progress">
            <!-- Progress Dashboard Component -->
            {% include 'game/components/progress_dashboard.html' %}
        </div>
    </div>
</div>

<!-- TTS/STT Settings Modal -->
<div id="settingsModal" class="settings-modal">
    <div class="settings-content">
        <h2 style="margin-top: 0;">Audio Settings</h2>

        <div class="settings-option">
            <label for="voiceTypeSelect">Game Master Voice:</label>
            <select id="voiceTypeSelect">
                <option value="game_master">Game Master (Old British Male)</option>
                <option value="dramatic">Dramatic (Deep & Resonant)</option>
                <option value="friendly">Friendly (Warm & Pleasant)</option>
                <option value="mysterious">Mysterious (Calm & Enigmatic)</option>
                <option value="heroic">Heroic (Strong & Commanding)</option>
            </select>
        </div>

        <div class="settings-option">
            <label for="playbackSpeedRange">Playback Speed: <span id="speedValue">1.0x</span></label>
            <input type="range" id="playbackSpeedRange" min="0.5" max="2.0" step="0.1" value="1.0" oninput="document.getElementById('speedValue').textContent = this.value + 'x'">
        </div>

        <div class="settings-option">
            <label>
                <input type="checkbox" id="autoPlayCheckbox" onchange="updateAutoPlayFromCheckbox()">
                Auto-play new Game Master narration
            </label>
        </div>

        <div class="settings-buttons">
            <button class="save-settings" onclick="saveSettings()">Save Settings</button>
            <button class="cancel-settings" onclick="closeSettingsModal()">Cancel</button>
        </div>
    </div>
</div>

<script>
    // Game Session Configuration
    const SESSION_ID = '{{ session_id }}';
    const PLAYER_ID = '{{ player.player_id }}';
    const CHARACTER_ID = '{{ character.character_id }}';
    const GAME_ENGINE_WS_URL = 'ws://localhost:9500/api/v1/ws/session/' + SESSION_ID + '/player/' + PLAYER_ID;

    // Campaign Quest Data (from server)
    const CAMPAIGN_FIRST_QUEST = {% if first_quest_json %}{{ first_quest_json|safe }}{% else %}null{% endif %};

    // Campaign Introduction Data
    const CAMPAIGN_INTRO = {% if campaign_intro_json %}{{ campaign_intro_json|safe }}{% else %}null{% endif %};

    let ws = null;
    let isConnected = false;
    let isFirstSceneLoad = true; // Track if this is the first scene load
    let streamingMessageDiv = null; // Track currently streaming message
    let streamingContent = ""; // Accumulate streaming content

    // TTS/STT Configuration
    let autoPlayEnabled = false;
    let currentAudio = null;
    let voiceType = 'game_master';
    let playbackSpeed = 1.0;
    let mediaRecorder = null;
    let audioChunks = [];
    let isRecording = false;

    // Make ws global for team chat component
    window.ws = ws;

    // Initialize on page load
    document.addEventListener('DOMContentLoaded', function() {
        initializeTabs();
        // Don't display raw campaign intro - wait for LLM narration
        connectWebSocket();
        setupEventListeners();
        fetchSessionState(); // Fetch initial state
    });

    function initializeTabs() {
        document.querySelectorAll('.info-tab').forEach(tab => {
            tab.addEventListener('click', function() {
                const tabName = this.dataset.tab;

                // Update active tab
                document.querySelectorAll('.info-tab').forEach(t => t.classList.remove('active'));
                this.classList.add('active');

                // Show corresponding content
                document.querySelectorAll('.info-content').forEach(c => c.classList.remove('active'));
                document.querySelector(`[data-content="${tabName}"]`).classList.add('active');
            });
        });
    }

    // Removed displayCampaignIntro() - now waiting for LLM-generated narration from Game Master

    function connectWebSocket() {
        updateConnectionStatus('connecting');

        ws = new WebSocket(GAME_ENGINE_WS_URL);
        window.ws = ws; // Make accessible to team chat component

        ws.onopen = function() {
            isConnected = true;
            updateConnectionStatus('connected');
            enableInput();
        };

        ws.onmessage = function(event) {
            const data = JSON.parse(event.data);
            handleGameEvent(data);
        };

        ws.onerror = function(error) {
            updateConnectionStatus('error');
        };

        ws.onclose = function() {
            isConnected = false;
            updateConnectionStatus('disconnected');
            disableInput();

            // Attempt reconnection after 3 seconds
            setTimeout(connectWebSocket, 3000);
        };
    }

    function handleGameEvent(data) {

        switch(data.event) {
            case 'connected':
                addSystemMessage('Connected to game session');
                break;

            case 'chat_message':
                // Route to team chat if it's a team chat message
                if (data.message && data.message.channel && typeof handleIncomingChat === 'function') {
                    handleIncomingChat(data.message);
                } else {
                    addChatMessage(data.message);
                }
                break;

            case 'scene_chunk':
                handleSceneChunk(data);
                break;

            case 'scene_update':
            case 'initial_scene':
                updateScene(data);
                break;

            case 'state_update':
                updateGameState(data);
                break;

            case 'action_received':
                addSystemMessage('Processing your action...');
                break;

            case 'typing_indicator':
                showTypingIndicator(data.is_typing);
                break;

            case 'player_joined_session':
                addSystemMessage(`${data.character_name} joined the party`);
                // Route to team chat
                if (typeof handleIncomingChat === 'function') {
                    handleIncomingChat({
                        event: 'player_joined',
                        player_name: data.character_name
                    });
                }
                break;

            case 'player_left':
                addSystemMessage(`A player left the session`);
                // Route to team chat
                if (typeof handleIncomingChat === 'function') {
                    handleIncomingChat({
                        event: 'player_left',
                        player_name: data.character_name || 'Unknown'
                    });
                }
                break;

            case 'quest_completed':
                handleQuestComplete(data);
                break;

            case 'dynamic_event_triggered':
                handleDynamicEvent(data.event_data);
                break;

            case 'challenge_created':
                handleChallenge(data.challenge);
                break;
        }
    }

    function sendPlayerAction() {
        const input = document.getElementById('playerInput');
        const action = input.value.trim();

        if (!action || !isConnected) return;

        // Send action to game engine
        ws.send(JSON.stringify({
            event: 'player_action',
            content: action
        }));

        // Clear input
        input.value = '';

        // Disable input while processing
        disableInput();
    }

    function handleSceneChunk(data) {
        const chatMessages = document.getElementById('chatMessages');

        // If this is the first chunk, create the message container
        if (!streamingMessageDiv) {
            streamingContent = "";
            streamingMessageDiv = document.createElement('div');
            streamingMessageDiv.className = 'chat-message message-dm';
            streamingMessageDiv.innerHTML = `
                <div class="message-sender">üë§ Game Master</div>
                <div class="message-content" id="streamingContent"></div>
                <div class="message-time">${formatTime(new Date().toISOString())}</div>
            `;
            chatMessages.appendChild(streamingMessageDiv);
        }

        // If this is the completion marker
        if (data.is_complete) {
            // Finalize the streaming message
            if (streamingMessageDiv) {
                const contentDiv = streamingMessageDiv.querySelector('.message-content');
                contentDiv.innerHTML = formatMessageContent(streamingContent);

                // Add TTS button to the completed streaming message
                const plainText = contentDiv.innerText || contentDiv.textContent;
                addTTSButtonToMessage(streamingMessageDiv, plainText);

                // Auto-play if enabled (skip if text is too long to avoid timeouts)
                // Limit to 3000 chars to avoid 60s timeout with chunked generation
                if (autoPlayEnabled && !isFirstSceneLoad && plainText.length < 3000) {
                    setTimeout(() => {
                        playTextToSpeech(plainText, streamingMessageDiv);
                    }, 500);
                } else if (autoPlayEnabled && plainText.length >= 3000) {
                    console.log('Skipping auto-play: text too long (' + plainText.length + ' chars). Use Listen button for long narrations.');
                }

                // After first scene is loaded, allow auto-scrolling for future messages
                isFirstSceneLoad = false;
            }

            // Reset streaming state
            streamingMessageDiv = null;
            streamingContent = "";
            return;
        }

        // Accumulate the chunk
        streamingContent += data.chunk;

        // Update the streaming content display with formatted markdown
        const contentDiv = streamingMessageDiv.querySelector('.message-content');
        contentDiv.innerHTML = formatMessageContent(streamingContent);

        // Auto-scroll during streaming (but not on first scene load)
        if (!isFirstSceneLoad) {
            chatMessages.scrollTop = chatMessages.scrollHeight;
        }
    }

    function addChatMessage(message) {
        const chatMessages = document.getElementById('chatMessages');
        const messageDiv = document.createElement('div');
        messageDiv.className = 'chat-message';

        // Determine message type styling
        let messageClass = 'message-dm';
        let senderIcon = 'üë§';

        switch(message.message_type) {
            case 'PLAYER_ACTION':
                messageClass = 'message-player';
                senderIcon = '‚öîÔ∏è';
                break;
            case 'DM_NPC_DIALOGUE':
                messageClass = 'message-npc';
                senderIcon = 'üí¨';
                break;
            case 'DM_ASSESSMENT':
                messageClass = 'message-assessment';
                senderIcon = 'üìä';
                break;
        }

        messageDiv.classList.add(messageClass);

        // Format content with markdown support
        const formattedContent = formatMessageContent(message.content);

        messageDiv.innerHTML = `
            <div class="message-sender">${senderIcon} ${message.sender_name}</div>
            <div class="message-content">${formattedContent}</div>
            <div class="message-time">${formatTime(message.timestamp)}</div>
        `;

        chatMessages.appendChild(messageDiv);

        // Only auto-scroll if this is not the first scene load
        if (!isFirstSceneLoad) {
            chatMessages.scrollTop = chatMessages.scrollHeight;
        }
    }

    function addSystemMessage(text) {
        const chatMessages = document.getElementById('chatMessages');
        const messageDiv = document.createElement('div');
        messageDiv.className = 'chat-message message-dm';
        messageDiv.innerHTML = `
            <div class="message-content" style="font-style: italic; color: #718096;">
                ${escapeHtml(text)}
            </div>
        `;
        chatMessages.appendChild(messageDiv);

        // Only auto-scroll if this is not the first scene load
        if (!isFirstSceneLoad) {
            chatMessages.scrollTop = chatMessages.scrollHeight;
        }
    }

    function updateScene(data) {
        // Update scene description
        if (data.scene_description) {
            addChatMessage({
                message_type: 'DM_NARRATIVE',
                sender_name: 'Game Master',
                content: data.scene_description,
                timestamp: data.timestamp
            });

            // After first scene is loaded, allow auto-scrolling for future messages
            isFirstSceneLoad = false;
        }

        // Update available actions
        if (data.available_actions) {
            updateAvailableActions(data.available_actions);
        }

        // Update available NPCs
        if (data.available_npcs) {
            updateNPCList(data.available_npcs);
        }
    }

    function updateQuestInfo(questId, questTitle, questDescription, questObjectives) {
        // ONLY use real campaign quest data - no defaults, no generation
        if ((!questTitle || questTitle === '' || questTitle === null || questTitle === undefined)) {
            if (CAMPAIGN_FIRST_QUEST) {
                questTitle = CAMPAIGN_FIRST_QUEST.title;
                questDescription = CAMPAIGN_FIRST_QUEST.description;
                questObjectives = CAMPAIGN_FIRST_QUEST.objectives;
            } else {
                questTitle = "ERROR: Quest Not Found";
                questDescription = "The campaign quest could not be loaded. Please contact support.";
                questObjectives = [];
            }
        }

        // Update header quest display
        const questElement = document.getElementById('currentQuest');
        if (questTitle) {
            questElement.textContent = questTitle;
        } else if (questId) {
            questElement.textContent = "Active Quest";
        } else {
            questElement.textContent = 'Free Exploration';
        }

        // Update sidebar quest info section
        const questInfoDiv = document.getElementById('questInfo');
        if (questTitle || questDescription) {
            let questInfoHTML = '<div style="padding: 1rem; background: #f7fafc; border-radius: 8px; border-left: 4px solid #667eea;">';

            if (questTitle) {
                questInfoHTML += `<h4 style="margin: 0 0 0.75rem 0; color: #2d3748; font-size: 1.2rem;">Quest: ${questTitle}</h4>`;
            }

            if (questDescription) {
                questInfoHTML += `<p style="margin: 0; color: #4a5568; line-height: 1.6; font-size: 0.9rem;">${questDescription}</p>`;
            }

            questInfoHTML += '</div>';
            questInfoDiv.innerHTML = questInfoHTML;

            // Update objectives if provided
            if (questObjectives && questObjectives.length > 0) {
                updateQuestObjectives(questObjectives);
            } else {
                // Show default message if no objectives
                document.getElementById('questObjectives').innerHTML = '<p style="color: #a0aec0; font-size: 0.9rem;">No specific objectives yet. Explore freely!</p>';
            }
        } else {
            questInfoDiv.innerHTML = '<p style="color: #a0aec0; font-style: italic;">No active quest. Explore the world!</p>';
        }
    }

    function updateQuestObjectives(objectives) {
        const objectivesDiv = document.getElementById('questObjectives');
        if (!objectives || objectives.length === 0) {
            objectivesDiv.innerHTML = '<p style="color: #a0aec0; font-size: 0.9rem;">No specific objectives yet.</p>';
            return;
        }

        let objectivesHTML = '';
        objectives.forEach(objective => {
            const isCompleted = objective.completed || false;
            const checkIcon = isCompleted ? '‚úÖ' : '‚¨ú';
            const completedClass = isCompleted ? ' completed' : '';

            objectivesHTML += `
                <div class="quest-objective${completedClass}">
                    <span class="objective-checkbox">${checkIcon}</span>
                    <span style="font-size: 0.9rem;">${typeof objective === 'string' ? objective : objective.description}</span>
                </div>
            `;
        });
        objectivesDiv.innerHTML = objectivesHTML;
    }

    function updateAvailableActions(actions) {
        const actionsDiv = document.getElementById('availableActions');
        actionsDiv.innerHTML = '';

        actions.forEach(action => {
            const button = document.createElement('button');
            button.className = 'action-button';
            button.textContent = action;
            button.onclick = () => {
                document.getElementById('playerInput').value = action;
            };
            actionsDiv.appendChild(button);
        });
    }

    function updateNPCList(npcs) {
        // Could add NPC list to UI
    }

    function updateGameState(data) {
        if (data.awaiting_player_input) {
            enableInput();
        }

        // Update quest info if available
        if (data.current_quest_id || data.quest_id) {
            updateQuestInfo(
                data.current_quest_id || data.quest_id,
                data.quest_title,
                data.quest_description,
                data.quest_objectives
            );
        }

        // Update location if available
        if (data.current_scene_id || data.current_location || data.location_name) {
            let locationName = data.location_name || data.current_location;

            // Format scene_id to be more user-friendly
            if (!locationName && data.current_scene_id) {
                if (data.current_scene_id === 'starting_location') {
                    locationName = 'Starting Area';
                } else {
                    locationName = data.current_scene_id
                        .replace(/_/g, ' ')
                        .replace(/\b\w/g, c => c.toUpperCase());
                }
            }

            document.getElementById('currentLocation').textContent = locationName || 'Exploring';
        }

        // Update bloom level if available
        if (data.blooms_level) {
            document.getElementById('headerBloomLevel').textContent = data.blooms_level.charAt(0).toUpperCase() + data.blooms_level.slice(1);
        }

        // Update party size if available
        if (data.party_members) {
            const partySize = Array.isArray(data.party_members) ? data.party_members.length : 1;
            document.getElementById('partySize').textContent = partySize === 1 ? '1 Hero' : `${partySize} Heroes`;
        }
    }

    async function fetchSessionState() {
        try {
            const response = await fetch(`http://localhost:9500/api/v1/session/${SESSION_ID}/state`);
            if (response.ok) {
                const state = await response.json();

                // Update quest info
                if (state.current_quest_id) {
                    updateQuestInfo(
                        state.current_quest_id,
                        state.quest_title,
                        state.quest_description,
                        state.quest_objectives
                    );
                }

                // Update location
                if (state.current_scene_id || state.current_location || state.location_name) {
                    let locationName = state.location_name || state.current_location;

                    // Format scene_id to be more user-friendly
                    if (!locationName && state.current_scene_id) {
                        if (state.current_scene_id === 'starting_location') {
                            locationName = 'Starting Area';
                        } else {
                            // Convert snake_case or other formats to Title Case
                            locationName = state.current_scene_id
                                .replace(/_/g, ' ')
                                .replace(/\b\w/g, c => c.toUpperCase());
                        }
                    }

                    document.getElementById('currentLocation').textContent = locationName || 'Exploring';
                }

                // Update bloom level
                if (state.blooms_level) {
                    document.getElementById('headerBloomLevel').textContent = state.blooms_level.charAt(0).toUpperCase() + state.blooms_level.slice(1);
                }

                // Update party size
                if (state.party_members) {
                    const partySize = Array.isArray(state.party_members) ? state.party_members.length : 1;
                    document.getElementById('partySize').textContent = partySize === 1 ? '1 Hero' : `${partySize} Heroes`;
                }

                // Update scene if available
                if (state.scene_description) {
                    addChatMessage({
                        message_type: 'DM_NARRATIVE',
                        sender_name: 'Game Master',
                        content: state.scene_description,
                        timestamp: new Date().toISOString()
                    });
                }

                // Update available actions
                if (state.available_actions && state.available_actions.length > 0) {
                    updateAvailableActions(state.available_actions);
                }

                // Enable input if awaiting
                if (state.awaiting_player_input) {
                    enableInput();
                }
            }
        } catch (error) {
            console.error('Failed to fetch session state:', error);
        }
    }

    function handleQuestComplete(data) {
        addSystemMessage(`üéâ Quest Complete: ${data.quest_title}!`);
        if (data.rewards) {
            addSystemMessage(`Rewards: ${JSON.stringify(data.rewards)}`);
        }
    }

    function handleDynamicEvent(event) {
        addChatMessage({
            message_type: 'DM_NARRATIVE',
            sender_name: 'Game Master',
            content: `‚ö° ${event.title}\n\n${event.description}`,
            timestamp: event.triggered_at
        });

        // Show choices if available
        if (event.choices && event.choices.length > 0) {
            const actionsDiv = document.getElementById('availableActions');
            event.choices.forEach(choice => {
                const button = document.createElement('button');
                button.className = 'action-button';
                button.textContent = choice.text;
                button.onclick = () => {
                    ws.send(JSON.stringify({
                        event: 'resolve_event',
                        event_id: event.event_id,
                        choice_id: choice.choice_id
                    }));
                };
                actionsDiv.appendChild(button);
            });
        }
    }

    function handleChallenge(challenge) {
        addChatMessage({
            message_type: 'DM_NARRATIVE',
            sender_name: 'Game Master',
            content: `‚öîÔ∏è Challenge: ${challenge.title}\n\n${challenge.description}\n\nSuccess Criteria: ${challenge.success_criteria}`,
            timestamp: challenge.created_at
        });
    }

    function setupEventListeners() {
        document.getElementById('sendButton').addEventListener('click', sendPlayerAction);

        document.getElementById('playerInput').addEventListener('keydown', function(e) {
            if (e.key === 'Enter' && !e.shiftKey) {
                e.preventDefault();
                sendPlayerAction();
            }
        });
    }

    function enableInput() {
        document.getElementById('playerInput').disabled = false;
        document.getElementById('sendButton').disabled = false;
    }

    function disableInput() {
        document.getElementById('sendButton').disabled = true;
    }

    function updateConnectionStatus(status) {
        const statusDiv = document.getElementById('connectionStatus');

        switch(status) {
            case 'connected':
                statusDiv.textContent = 'üü¢ Connected';
                statusDiv.className = 'connection-status';
                break;
            case 'connecting':
                statusDiv.textContent = 'üü° Connecting...';
                statusDiv.className = 'connection-status';
                break;
            case 'disconnected':
            case 'error':
                statusDiv.textContent = 'üî¥ Disconnected';
                statusDiv.className = 'connection-status disconnected';
                break;
        }
    }

    function showTypingIndicator(isTyping) {
        const indicator = document.getElementById('typingIndicator');
        indicator.style.display = isTyping ? 'block' : 'none';
    }

    function escapeHtml(text) {
        const div = document.createElement('div');
        div.textContent = text;
        return div.innerHTML;
    }

    function formatMessageContent(text) {
        // Simple markdown parser for Game Master narration
        let html = text;

        // Convert headers (# Header) to bold headers with spacing
        html = html.replace(/^# (.+)$/gm, '<h2 style="font-size: 1.4rem; font-weight: bold; margin: 1.5rem 0 1rem 0; color: #2d3748;">$1</h2>');
        html = html.replace(/^## (.+)$/gm, '<h3 style="font-size: 1.2rem; font-weight: bold; margin: 1.25rem 0 0.75rem 0; color: #4a5568;">$1</h3>');
        html = html.replace(/^### (.+)$/gm, '<h4 style="font-size: 1.1rem; font-weight: bold; margin: 1rem 0 0.5rem 0; color: #4a5568;">$1</h4>');

        // Convert bold text (**text**)
        html = html.replace(/\*\*(.+?)\*\*/g, '<strong>$1</strong>');

        // Convert bullet points (‚Ä¢ or - at start of line)
        html = html.replace(/^[‚Ä¢\-] (.+)$/gm, '<li style="margin-left: 1.5rem; margin-bottom: 0.25rem;">$1</li>');

        // Wrap consecutive <li> in <ul>
        html = html.replace(/(<li[^>]*>.*<\/li>\n?)+/g, '<ul style="margin: 0.5rem 0; padding-left: 0; list-style-position: inside;">$&</ul>');

        // Convert double line breaks to paragraph breaks
        html = html.replace(/\n\n/g, '</p><p style="margin-bottom: 1rem; line-height: 1.6;">');

        // Convert single line breaks to <br> within paragraphs
        html = html.replace(/\n/g, '<br>');

        // Wrap in paragraph tags
        html = '<p style="margin-bottom: 1rem; line-height: 1.6;">' + html + '</p>';

        // Clean up empty paragraphs
        html = html.replace(/<p[^>]*><\/p>/g, '');

        return html;
    }

    function formatTime(timestamp) {
        const date = new Date(timestamp);
        return date.toLocaleTimeString();
    }

    // ============================================
    // TTS (Text-to-Speech) Functions
    // ============================================

    function toggleAutoPlay() {
        autoPlayEnabled = !autoPlayEnabled;
        const button = document.getElementById('autoPlayToggle');
        if (autoPlayEnabled) {
            button.textContent = 'üîä Auto-Play';
            button.classList.add('playing');
        } else {
            button.textContent = 'üîá Auto-Play';
            button.classList.remove('playing');
        }
        localStorage.setItem('tts_autoplay', autoPlayEnabled);
    }

    async function playTextToSpeech(text, messageElement) {
        try {
            // Stop any currently playing audio
            if (currentAudio) {
                currentAudio.pause();
                currentAudio = null;
            }

            // Update button to show loading state
            let button = null;
            if (messageElement) {
                button = messageElement.querySelector('.message-tts-button');
                if (button) {
                    button.disabled = true;
                    button.classList.add('loading');
                    button.textContent = '‚è≥ Loading...';
                }
            }

            // Generate TTS audio using POST with URLSearchParams
            const params = new URLSearchParams({
                text: text,
                voice_type: voiceType
            });

            // Add timeout to the fetch request (60 seconds for very long texts)
            const controller = new AbortController();
            const timeoutId = setTimeout(() => controller.abort(), 60000);

            const response = await fetch(`http://localhost:9500/api/v1/tts/generate?${params.toString()}`, {
                method: 'POST',
                signal: controller.signal
            });

            clearTimeout(timeoutId);

            if (!response.ok) {
                console.error('TTS generation failed:', response.statusText);
                if (button) {
                    button.disabled = false;
                    button.classList.remove('loading');
                    button.textContent = '‚ùå Failed';
                    setTimeout(() => {
                        button.textContent = 'üîä Listen';
                    }, 2000);
                }
                return;
            }

            // Create audio element
            const audioBlob = await response.blob();
            const audioUrl = URL.createObjectURL(audioBlob);
            currentAudio = new Audio(audioUrl);
            currentAudio.playbackRate = playbackSpeed;

            // Update UI to playing state
            if (button) {
                button.disabled = false;
                button.classList.remove('loading');
                button.classList.add('playing');
                button.textContent = '‚è∏Ô∏è Stop';
            }

            // Play audio
            await currentAudio.play();

            // Cleanup when done
            currentAudio.onended = () => {
                URL.revokeObjectURL(audioUrl);
                currentAudio = null;
                if (button) {
                    button.classList.remove('playing');
                    button.textContent = 'üîä Listen';
                }
            };

            // Cleanup on error
            currentAudio.onerror = () => {
                URL.revokeObjectURL(audioUrl);
                currentAudio = null;
                if (button) {
                    button.classList.remove('playing');
                    button.textContent = '‚ùå Error';
                    setTimeout(() => {
                        button.textContent = 'üîä Listen';
                    }, 2000);
                }
            };

        } catch (error) {
            console.error('Error playing TTS:', error);

            // Handle timeout specifically
            if (error.name === 'AbortError') {
                console.error('TTS request timed out');
                if (messageElement) {
                    const button = messageElement.querySelector('.message-tts-button');
                    if (button) {
                        button.disabled = false;
                        button.classList.remove('loading');
                        button.textContent = '‚è±Ô∏è Timeout';
                        setTimeout(() => {
                            button.textContent = 'üîä Listen';
                        }, 3000);
                    }
                }
            } else {
                // Generic error handling
                if (messageElement) {
                    const button = messageElement.querySelector('.message-tts-button');
                    if (button) {
                        button.disabled = false;
                        button.classList.remove('loading');
                        button.textContent = '‚ùå Error';
                        setTimeout(() => {
                            button.textContent = 'üîä Listen';
                        }, 2000);
                    }
                }
            }
        }
    }

    function addTTSButtonToMessage(messageDiv, text) {
        const contentDiv = messageDiv.querySelector('.message-content');
        if (!contentDiv) return;

        const ttsButton = document.createElement('button');
        ttsButton.className = 'message-tts-button';
        ttsButton.textContent = 'üîä Listen';
        ttsButton.onclick = function() {
            if (currentAudio && !currentAudio.paused) {
                currentAudio.pause();
                currentAudio = null;
                this.classList.remove('playing');
                this.textContent = 'üîä Listen';
            } else {
                // Remove formatting tags for cleaner TTS
                const plainText = contentDiv.innerText || contentDiv.textContent;
                playTextToSpeech(plainText, messageDiv);
            }
        };

        const timeDiv = messageDiv.querySelector('.message-time');
        if (timeDiv) {
            timeDiv.appendChild(ttsButton);
        }
    }

    // ============================================
    // STT (Speech-to-Text) Functions
    // ============================================

    async function toggleMicrophone() {
        if (isRecording) {
            stopRecording();
        } else {
            await startRecording();
        }
    }

    async function startRecording() {
        try {
            const stream = await navigator.mediaDevices.getUserMedia({ audio: true });

            mediaRecorder = new MediaRecorder(stream);
            audioChunks = [];

            mediaRecorder.ondataavailable = (event) => {
                audioChunks.push(event.data);
            };

            mediaRecorder.onstop = async () => {
                const audioBlob = new Blob(audioChunks, { type: 'audio/webm' });
                await transcribeAudio(audioBlob);

                // Stop all tracks
                stream.getTracks().forEach(track => track.stop());
            };

            mediaRecorder.start();
            isRecording = true;

            // Update UI
            const micButton = document.getElementById('micButton');
            micButton.classList.add('recording');
            micButton.textContent = '‚èπÔ∏è';

        } catch (error) {
            console.error('Error accessing microphone:', error);
            alert('Could not access microphone. Please check your permissions.');
        }
    }

    function stopRecording() {
        if (mediaRecorder && isRecording) {
            mediaRecorder.stop();
            isRecording = false;

            // Update UI
            const micButton = document.getElementById('micButton');
            micButton.classList.remove('recording');
            micButton.textContent = 'üé§';
        }
    }

    async function transcribeAudio(audioBlob) {
        try {
            const formData = new FormData();
            formData.append('audio', audioBlob, 'recording.webm');
            formData.append('language', 'en');

            const response = await fetch(`http://localhost:9500/api/v1/stt/session/${SESSION_ID}/player-action?player_id=${PLAYER_ID}`, {
                method: 'POST',
                body: formData
            });

            if (!response.ok) {
                console.error('STT transcription failed:', response.statusText);
                return;
            }

            const result = await response.json();

            if (result.success && result.text) {
                // Fill the text area with transcribed text
                document.getElementById('playerInput').value = result.text;
                console.log('Transcribed:', result.text);
            }

        } catch (error) {
            console.error('Error transcribing audio:', error);
            alert('Failed to transcribe audio. Please try again.');
        }
    }

    // ============================================
    // Settings Modal Functions
    // ============================================

    function openSettingsModal() {
        const modal = document.getElementById('settingsModal');

        // Load current settings
        document.getElementById('voiceTypeSelect').value = voiceType;
        document.getElementById('playbackSpeedRange').value = playbackSpeed;
        document.getElementById('speedValue').textContent = playbackSpeed + 'x';
        document.getElementById('autoPlayCheckbox').checked = autoPlayEnabled;

        modal.classList.add('show');
    }

    function closeSettingsModal() {
        const modal = document.getElementById('settingsModal');
        modal.classList.remove('show');
    }

    function saveSettings() {
        // Save settings
        voiceType = document.getElementById('voiceTypeSelect').value;
        playbackSpeed = parseFloat(document.getElementById('playbackSpeedRange').value);
        autoPlayEnabled = document.getElementById('autoPlayCheckbox').checked;

        // Update auto-play button
        const button = document.getElementById('autoPlayToggle');
        if (autoPlayEnabled) {
            button.textContent = 'üîä Auto-Play';
            button.classList.add('playing');
        } else {
            button.textContent = 'üîá Auto-Play';
            button.classList.remove('playing');
        }

        // Save to localStorage
        localStorage.setItem('tts_voice_type', voiceType);
        localStorage.setItem('tts_playback_speed', playbackSpeed);
        localStorage.setItem('tts_autoplay', autoPlayEnabled);

        closeSettingsModal();
    }

    function updateAutoPlayFromCheckbox() {
        autoPlayEnabled = document.getElementById('autoPlayCheckbox').checked;
    }

    function loadSettings() {
        // Load settings from localStorage
        const savedVoiceType = localStorage.getItem('tts_voice_type');
        const savedSpeed = localStorage.getItem('tts_playback_speed');
        const savedAutoPlay = localStorage.getItem('tts_autoplay');

        if (savedVoiceType) voiceType = savedVoiceType;
        if (savedSpeed) playbackSpeed = parseFloat(savedSpeed);
        if (savedAutoPlay) autoPlayEnabled = savedAutoPlay === 'true';

        // Update auto-play button
        const button = document.getElementById('autoPlayToggle');
        if (autoPlayEnabled) {
            button.textContent = 'üîä Auto-Play';
            button.classList.add('playing');
        }
    }

    // Initialize settings on page load
    document.addEventListener('DOMContentLoaded', function() {
        loadSettings();
    });

    // ============================================
    // Enhanced addChatMessage to support TTS
    // ============================================

    const originalAddChatMessage = addChatMessage;
    addChatMessage = function(message) {
        originalAddChatMessage(message);

        // Add TTS button to DM narration messages
        if (message.message_type === 'DM_NARRATIVE') {
            const chatMessages = document.getElementById('chatMessages');
            const lastMessage = chatMessages.lastElementChild;

            if (lastMessage) {
                const contentDiv = lastMessage.querySelector('.message-content');
                if (contentDiv) {
                    const plainText = contentDiv.innerText || contentDiv.textContent;
                    addTTSButtonToMessage(lastMessage, plainText);

                    // Auto-play if enabled (skip if text is too long to avoid timeouts)
                    if (autoPlayEnabled && !isFirstSceneLoad && plainText.length < 5000) {
                        setTimeout(() => {
                            playTextToSpeech(plainText, lastMessage);
                        }, 500);
                    } else if (autoPlayEnabled && plainText.length >= 5000) {
                        console.log('Skipping auto-play: text too long (' + plainText.length + ' chars)');
                    }
                }
            }
        }
    };

    // Enable mic button when connected
    const originalEnableInput = enableInput;
    enableInput = function() {
        originalEnableInput();
        document.getElementById('micButton').disabled = false;
    };
</script>
{% endblock %}
