{% extends 'base.html' %}
{% load static %}

{% block title %}Game Session - SkillForge{% endblock %}

{% block extra_css %}
<style>
    /* Cache buster v2.9 - Full width layout with base template at 98% 2025-10-21-1802 */
    * {
        box-sizing: border-box;
    }

    body {
        margin: 0;
        overflow-x: hidden; /* Prevent horizontal scroll only */
    }

    /* Remove container padding for game page to use full width */
    main .container {
        padding: 0 !important;
        max-width: 100% !important;
    }

    .game-container {
        height: calc(100vh - 64px); /* Subtract header height */
        display: flex;
        flex-direction: column;
        background: #f5f5f5;
        position: relative;
    }

    /* Game Session Wrapper - container for header + content */
    .game-session-wrapper {
        position: absolute;
        top: 6px;
        left: 6px;
        right: 6px;
        bottom: 20px;
        display: flex;
        flex-direction: column;
        border-radius: 8px;
        box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        overflow: hidden;
        transition: left 0.3s ease-in-out, right 0.3s ease-in-out;
        z-index: 50;
    }

    .game-session-wrapper.left-pinned {
        left: calc(320px + 6px);
    }

    .game-session-wrapper.right-pinned {
        right: calc(320px + 6px);
    }

    .game-session-wrapper.left-pinned.right-pinned {
        left: calc(320px + 6px);
        right: calc(320px + 6px);
    }

    /* Header */
    .game-header {
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        color: white;
        padding: 1rem 2rem;
        display: flex;
        justify-content: space-between;
        align-items: center;
        flex-shrink: 0;
        z-index: 100;
    }

    .game-title {
        font-size: 1.3rem;
        font-weight: bold;
    }

    .game-status {
        display: flex;
        gap: 2rem;
        font-size: 0.9rem;
    }

    #connectionStatus {
        text-shadow: 0 0 10px rgba(255, 255, 255, 0.6);
    }

    /* Main Content Area */
    .game-content {
        flex: 1;
        display: flex;
        overflow: hidden;
        box-sizing: border-box;
        padding: 0;
        background: white;
    }

    /* Main Scene Area */
    .main-content {
        width: 100%;
        max-width: 100%;
        height: 100%;
        display: flex;
        flex-direction: column;
        gap: 0;
        overflow: hidden;
        box-sizing: border-box;
        flex: 1;
        min-width: 0; /* Allow flexbox to shrink */
    }

    /* Drawer Styles - RPG Fantasy Theme */
    .drawer {
        position: fixed;
        top: 64px;
        bottom: 0;
        width: 320px;
        background: linear-gradient(180deg, #16213e 0%, #1a1a2e 100%);
        color: #e0e0e0;
        box-shadow: 4px 0 12px rgba(0, 0, 0, 0.5);
        transition: transform 0.3s ease-in-out;
        z-index: 110;
        display: flex;
        flex-direction: column;
        overflow: hidden;
    }

    .drawer-left {
        left: 0;
        transform: translateX(-100%);
        border-right: 2px solid rgba(212, 175, 55, 0.2);
    }

    .drawer-left.open {
        transform: translateX(0);
    }

    .drawer-left.anchored {
        transform: translateX(0);
        box-shadow: -4px 0 12px rgba(0, 0, 0, 0.5); /* Flip shadow to go left when anchored */
        border-right: none; /* Remove border when anchored to prevent overlap */
    }

    .drawer-right {
        right: 0;
        transform: translateX(100%);
        border-left: 2px solid rgba(212, 175, 55, 0.2);
    }

    .drawer-right.open {
        transform: translateX(0);
    }

    .drawer-right.anchored {
        transform: translateX(0);
        box-shadow: 4px 0 12px rgba(0, 0, 0, 0.5); /* Flip shadow to go right when anchored */
        border-left: none; /* Remove border when anchored to prevent overlap */
    }

    .drawer-header {
        background: linear-gradient(135deg, #2d1b69 0%, #1a1a2e 100%);
        color: white;
        padding: 0.6rem 0.8rem;
        display: flex;
        justify-content: space-between;
        align-items: center;
        flex-shrink: 0;
        border-bottom: 2px solid #d4af37;
        box-shadow: 0 2px 8px rgba(212, 175, 55, 0.3);
    }

    .drawer-title {
        font-size: 0.95rem;
        font-weight: 700;
        letter-spacing: 0.5px;
        color: #d4af37;
        text-shadow: 0 0 10px rgba(212, 175, 55, 0.5);
    }

    .drawer-controls {
        display: flex;
        gap: 0.5rem;
    }

    .drawer-btn {
        background: rgba(255, 255, 255, 0.2);
        border: 1px solid rgba(255, 255, 255, 0.3);
        color: white;
        cursor: pointer;
        padding: 0.25rem 0.5rem;
        border-radius: 4px;
        font-size: 1rem;
        transition: all 0.2s;
    }

    .drawer-btn:hover {
        background: rgba(255, 255, 255, 0.3);
    }

    .drawer-btn.active {
        background: rgba(212, 175, 55, 0.4);
        border-color: #d4af37;
    }

    .drawer-content {
        flex: 1;
        padding: 0.6rem;
        overflow-y: auto;
        background: linear-gradient(180deg, #16213e 0%, #1a1a2e 100%);
    }

    .drawer-content h3 {
        color: #d4af37;
        font-size: 1rem;
        font-weight: bold;
        margin: 0 0 0.6rem 0;
        text-shadow: 0 0 10px rgba(212, 175, 55, 0.3);
    }

    .drawer-content h4 {
        color: #c0c0c0;
        font-size: 0.85rem;
        font-weight: bold;
        margin: 0.6rem 0 0.3rem 0;
        letter-spacing: 0.3px;
    }

    .drawer-content p {
        color: #d0d0e0;
    }

    /* RPG-themed scrollbar */
    .drawer-content::-webkit-scrollbar {
        width: 12px;
    }

    .drawer-content::-webkit-scrollbar-track {
        background: #0f0f1e;
    }

    .drawer-content::-webkit-scrollbar-thumb {
        background: linear-gradient(180deg, #d4af37 0%, #cd7f32 100%);
        border-radius: 6px;
        border: 2px solid #0f0f1e;
    }

    .drawer-content::-webkit-scrollbar-thumb:hover {
        background: #d4af37;
    }

    /* Quest Tracker Styles */
    .quest-section {
        margin-bottom: 1.25rem;
        background: rgba(255,255,255,0.03);
        border-radius: 8px;
        overflow: hidden;
        border: 1px solid rgba(212,175,55,0.2);
    }

    .quest-section-header {
        padding: 0.75rem;
        background: linear-gradient(135deg, rgba(102,126,234,0.15) 0%, rgba(118,75,162,0.15) 100%);
        cursor: pointer;
        display: flex;
        justify-content: space-between;
        align-items: center;
        border-bottom: 1px solid rgba(212,175,55,0.2);
    }

    .quest-section-header:hover {
        background: linear-gradient(135deg, rgba(102,126,234,0.25) 0%, rgba(118,75,162,0.25) 100%);
    }

    .quest-section-title {
        display: flex;
        align-items: center;
        gap: 0.5rem;
        font-size: 0.95rem;
        font-weight: 600;
        color: #d4af37;
    }

    .collapse-icon {
        font-size: 0.75rem;
        transition: transform 0.2s;
        color: #94a3b8;
    }

    .quest-section-progress {
        font-size: 0.85rem;
        color: #94a3b8;
        font-weight: 500;
    }

    .quest-section-body {
        padding: 0.75rem;
    }

    .quest-section-body.collapsed {
        display: none;
    }

    .progress-bar-container {
        background: rgba(0,0,0,0.3);
        height: 6px;
        border-radius: 3px;
        overflow: hidden;
        margin: 0.5rem 0;
    }

    .progress-bar-fill {
        height: 100%;
        background: linear-gradient(90deg, #667eea 0%, #764ba2 100%);
        transition: width 0.3s ease;
        border-radius: 3px;
    }

    .objective-item {
        padding: 0.5rem;
        margin-bottom: 0.5rem;
        background: rgba(255,255,255,0.05);
        border-radius: 6px;
        cursor: pointer;
        transition: all 0.2s;
        border-left: 3px solid transparent;
    }

    .objective-item:hover {
        background: rgba(255,255,255,0.1);
        border-left-color: #667eea;
        transform: translateX(2px);
    }

    .objective-item.completed {
        opacity: 0.7;
        border-left-color: #10b981;
    }

    .objective-header {
        display: flex;
        align-items: start;
        gap: 0.5rem;
        margin-bottom: 0.25rem;
    }

    .objective-icon {
        flex-shrink: 0;
        font-size: 1rem;
        margin-top: 1px;
    }

    .objective-text {
        flex: 1;
        font-size: 0.85rem;
        color: #e2e8f0;
        line-height: 1.4;
    }

    .objective-meta {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-top: 0.25rem;
        font-size: 0.75rem;
        color: #94a3b8;
    }

    .objective-progress-text {
        font-weight: 500;
    }

    .objective-click-hint {
        opacity: 0;
        transition: opacity 0.2s;
    }

    .objective-item:hover .objective-click-hint {
        opacity: 1;
    }

    /* Campaign Overview Styles */
    .campaign-header {
        padding: 0.75rem;
        background: linear-gradient(135deg, rgba(212,175,55,0.15) 0%, rgba(205,127,50,0.15) 100%);
        border-radius: 6px;
        margin-bottom: 1rem;
        border: 1px solid rgba(212,175,55,0.3);
    }

    .campaign-title {
        font-size: 1rem;
        font-weight: 700;
        color: #d4af37;
        margin-bottom: 0.25rem;
    }

    .campaign-subtitle {
        font-size: 0.75rem;
        color: #94a3b8;
        line-height: 1.3;
    }

    /* Modal Styles */
    .objective-modal {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0,0,0,0.8);
        z-index: 1000;
        display: flex;
        align-items: center;
        justify-content: center;
        backdrop-filter: blur(4px);
    }

    .objective-modal-content {
        background: linear-gradient(180deg, #1a1a2e 0%, #16213e 100%);
        border-radius: 12px;
        max-width: 600px;
        width: 90%;
        max-height: 80vh;
        overflow: hidden;
        box-shadow: 0 20px 60px rgba(0,0,0,0.5);
        border: 2px solid rgba(212,175,55,0.3);
    }

    .objective-modal-header {
        padding: 1.25rem;
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        display: flex;
        justify-content: space-between;
        align-items: center;
        border-bottom: 2px solid rgba(212,175,55,0.3);
    }

    .objective-modal-header h2 {
        margin: 0;
        font-size: 1.25rem;
        color: white;
        font-weight: 600;
    }

    .objective-modal-close {
        background: none;
        border: none;
        color: white;
        font-size: 2rem;
        cursor: pointer;
        padding: 0;
        width: 32px;
        height: 32px;
        display: flex;
        align-items: center;
        justify-content: center;
        border-radius: 4px;
        transition: background 0.2s;
    }

    .objective-modal-close:hover {
        background: rgba(255,255,255,0.2);
    }

    .objective-modal-body {
        padding: 1.25rem;
        max-height: calc(80vh - 100px);
        overflow-y: auto;
        color: #e2e8f0;
    }

    .objective-progress-summary {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 1rem;
        margin-bottom: 1rem;
    }

    .progress-stat {
        background: rgba(255,255,255,0.05);
        padding: 0.75rem;
        border-radius: 6px;
        border-left: 3px solid #667eea;
    }

    .stat-label {
        display: block;
        font-size: 0.75rem;
        color: #94a3b8;
        margin-bottom: 0.25rem;
        font-weight: 500;
        text-transform: uppercase;
    }

    .stat-value {
        display: block;
        font-size: 1.1rem;
        color: #d4af37;
        font-weight: 600;
    }

    .objective-description {
        margin-bottom: 1.5rem;
    }

    .objective-description h3 {
        font-size: 0.9rem;
        color: #d4af37;
        margin: 0 0 0.5rem 0;
        font-weight: 600;
        text-transform: uppercase;
    }

    .objective-description p {
        font-size: 0.9rem;
        color: #cbd5e1;
        line-height: 1.6;
        margin: 0;
    }

    .objective-acquisitions {
        margin-top: 1.5rem;
    }

    .objective-acquisitions h3 {
        font-size: 0.9rem;
        color: #d4af37;
        margin: 0 0 0.75rem 0;
        font-weight: 600;
        text-transform: uppercase;
    }

    .acquisitions-list {
        display: flex;
        flex-direction: column;
        gap: 0.75rem;
    }

    .acquisition-item {
        background: rgba(255,255,255,0.05);
        padding: 0.75rem;
        border-radius: 6px;
        border-left: 3px solid #10b981;
    }

    .acquisition-header {
        display: flex;
        justify-content: space-between;
        align-items: start;
        margin-bottom: 0.5rem;
    }

    .acquisition-name {
        font-weight: 600;
        color: #e2e8f0;
        font-size: 0.9rem;
    }

    .acquisition-time {
        font-size: 0.75rem;
        color: #94a3b8;
    }

    .acquisition-details {
        font-size: 0.85rem;
        color: #cbd5e1;
        line-height: 1.4;
        margin-bottom: 0.5rem;
    }

    .acquisition-purpose {
        font-size: 0.8rem;
        color: #94a3b8;
        font-style: italic;
        padding-top: 0.5rem;
        border-top: 1px solid rgba(255,255,255,0.1);
    }

    /* Empty State */
    .empty-acquisitions {
        text-align: center;
        padding: 2rem 1rem;
        color: #94a3b8;
        font-size: 0.9rem;
    }

    /* Acquisition Items in Drawer */
    .acquisition-card {
        padding: 0.65rem;
        margin-bottom: 0.5rem;
        background: rgba(255,255,255,0.05);
        border-radius: 6px;
        cursor: pointer;
        transition: all 0.2s;
        border-left: 3px solid transparent;
        display: flex;
        align-items: center;
        gap: 0.65rem;
    }

    .acquisition-card:hover {
        background: rgba(255,255,255,0.1);
        transform: translateX(2px);
    }

    .acquisition-card.knowledge {
        border-left-color: #3b82f6;
    }

    .acquisition-card.item {
        border-left-color: #10b981;
    }

    .acquisition-card.event {
        border-left-color: #f59e0b;
    }

    .acquisition-card.challenge {
        border-left-color: #ef4444;
    }

    .acquisition-card-icon {
        font-size: 1.5rem;
        flex-shrink: 0;
    }

    .acquisition-card-content {
        flex: 1;
        min-width: 0;
    }

    .acquisition-card-name {
        font-size: 0.85rem;
        font-weight: 600;
        color: #e2e8f0;
        margin-bottom: 0.15rem;
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
    }

    .acquisition-card-desc {
        font-size: 0.75rem;
        color: #94a3b8;
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
    }

    .acquisition-card-badge {
        font-size: 0.7rem;
        padding: 0.15rem 0.4rem;
        border-radius: 3px;
        background: rgba(59,130,246,0.2);
        color: #60a5fa;
        font-weight: 500;
    }

    .acquisition-section-count {
        font-size: 0.75rem;
        padding: 0.15rem 0.5rem;
        border-radius: 12px;
        background: rgba(102,126,234,0.2);
        color: #a5b4fc;
        font-weight: 600;
    }

    /* Acquisition Detail Modal Specific Styles */
    .acquisition-detail-header {
        display: flex;
        align-items: center;
        gap: 1rem;
        margin-bottom: 1.5rem;
        padding-bottom: 1rem;
        border-bottom: 1px solid rgba(255,255,255,0.1);
    }

    .acquisition-icon-large {
        font-size: 3rem;
        width: 4rem;
        height: 4rem;
        display: flex;
        align-items: center;
        justify-content: center;
        background: rgba(102,126,234,0.1);
        border-radius: 12px;
        border: 2px solid rgba(102,126,234,0.3);
    }

    .acquisition-meta-info {
        flex: 1;
    }

    .acquisition-type {
        font-size: 0.75rem;
        text-transform: uppercase;
        color: #94a3b8;
        font-weight: 600;
        margin-bottom: 0.25rem;
    }

    .acquisition-acquired-time {
        font-size: 0.85rem;
        color: #cbd5e1;
    }

    .acquisition-detail-description {
        margin-bottom: 1.5rem;
    }

    .acquisition-detail-description h3,
    .acquisition-detail-purpose h3,
    .acquisition-detail-source h3 {
        font-size: 0.9rem;
        color: #d4af37;
        margin: 0 0 0.5rem 0;
        font-weight: 600;
        text-transform: uppercase;
    }

    .acquisition-detail-description p,
    .acquisition-detail-purpose p,
    .acquisition-detail-source p {
        font-size: 0.9rem;
        color: #cbd5e1;
        line-height: 1.6;
        margin: 0;
    }

    .acquisition-detail-purpose,
    .acquisition-detail-source {
        margin-top: 1.5rem;
        padding-top: 1.5rem;
        border-top: 1px solid rgba(255,255,255,0.1);
    }

    #acquisitionObjectives {
        margin-top: 0.75rem;
    }

    .acquisition-objective-link {
        display: inline-block;
        padding: 0.4rem 0.75rem;
        background: rgba(102,126,234,0.15);
        border-radius: 6px;
        border-left: 3px solid #667eea;
        margin: 0.25rem 0.25rem 0.25rem 0;
        font-size: 0.8rem;
        color: #a5b4fc;
    }

    /* Toggle Buttons */
    .drawer-toggle {
        position: fixed;
        top: 50%;
        transform: translateY(-50%);
        background: #667eea;
        color: white;
        border: none;
        padding: 1rem 0.5rem;
        cursor: pointer;
        z-index: 85;
        font-size: 1rem;
        border-radius: 0 8px 8px 0;
        box-shadow: 2px 0 8px rgba(0,0,0,0.2);
        transition: all 0.2s;
    }

    .drawer-toggle:hover {
        background: #5a67d8;
        transform: translateY(-50%) scale(1.05);
    }

    .drawer-toggle-left {
        left: 0;
    }

    .drawer-toggle-left.hidden {
        left: 320px;
    }

    .drawer-toggle-right {
        right: 0;
        border-radius: 8px 0 0 8px;
        box-shadow: -2px 0 8px rgba(0,0,0,0.2);
    }

    .drawer-toggle-right.hidden {
        right: 320px;
    }

    /* Quest Panel Content */
    .objective-item {
        padding: 0.75rem;
        display: flex;
        align-items: center;
        gap: 0.75rem;
        border-bottom: 1px solid rgba(212, 175, 55, 0.2);
        background: rgba(255, 255, 255, 0.05);
        margin-bottom: 0.5rem;
        border-radius: 4px;
    }

    .objective-item:last-child {
        border-bottom: none;
    }

    /* Custom checkbox using div - no Materialize interference */
    .objective-checkbox-wrapper {
        flex-shrink: 0;
    }

    .custom-checkbox {
        width: 28px;
        height: 28px;
        border: 3px solid #d4af37;
        background-color: rgba(22, 33, 62, 0.5);
        border-radius: 8px;
        position: relative;
        transition: all 0.3s ease;
        box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
        display: flex;
        align-items: center;
        justify-content: center;
    }

    .custom-checkbox:hover {
        transform: scale(1.05);
        border-color: #e0c050;
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4), 0 0 12px rgba(212, 175, 55, 0.3);
    }

    .custom-checkbox.checked {
        background: linear-gradient(135deg, #d4af37 0%, #c9a030 100%);
        border-color: #d4af37;
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4), 0 0 20px rgba(212, 175, 55, 0.5);
        animation: checkBounce 0.4s ease;
    }

    @keyframes checkBounce {
        0% { transform: scale(1); }
        50% { transform: scale(1.15); }
        100% { transform: scale(1); }
    }

    .custom-checkbox.checked::after {
        content: '‚úì';
        color: #0f0f1e;
        font-size: 20px;
        font-weight: 900;
        line-height: 1;
        animation: checkAppear 0.3s ease;
    }

    @keyframes checkAppear {
        0% {
            transform: scale(0);
            opacity: 0;
        }
        100% {
            transform: scale(1);
            opacity: 1;
        }
    }

    .objective-item span {
        color: #f0f0f0;
        font-size: 0.95rem;
    }

    /* Remove any pseudo-elements from span */
    .objective-item span::before,
    .objective-item span::after {
        display: none !important;
        content: none !important;
    }

    /* Party Panel Content */
    .player-item {
        padding: 1rem;
        border-radius: 6px;
        margin-bottom: 0.5rem;
        background: rgba(255, 255, 255, 0.05);
        border: 1px solid rgba(212, 175, 55, 0.2);
    }

    .player-item:last-child {
        margin-bottom: 0;
    }

    .player-name {
        font-weight: bold;
        margin-bottom: 0.5rem;
        font-size: 1rem;
        color: #d4af37;
    }

    .player-status {
        font-size: 0.85rem;
        color: #b8b8d1;
        display: flex;
        align-items: center;
        gap: 0.5rem;
    }

    .status-online {
        color: #4ade80;
    }

    .status-offline {
        color: #94a3b8;
    }

    /* Scene Viewer - Conversation Style */
    .scene-viewer {
        width: 100%;
        height: 100%;
        display: flex;
        flex-direction: column;
        background: white;
        border-radius: 0;
        box-shadow: none;
        overflow: hidden;
        box-sizing: border-box;
        flex: 1;
    }

    .scene-content {
        width: 100%;
        flex: 1;
        padding: 1rem 2rem;
        overflow-y: auto !important; /* Always show vertical scroll */
        overflow-x: hidden;
        background: linear-gradient(to bottom, #f8f9fa 0%, #ffffff 100%);
        box-sizing: border-box;
    }

    .narrative-text {
        font-size: 0.9rem;
        line-height: 1.5;
        color: #333;
        margin-bottom: 1rem;
    }

    .narrative-text h1 {
        font-size: 1.1rem;
        margin: 0.75rem 0 0.4rem 0;
        color: #2d3748;
        font-weight: 700;
    }

    .narrative-text h2 {
        font-size: 1rem;
        margin: 0.6rem 0 0.3rem 0;
        color: #2d3748;
        font-weight: 600;
    }

    .narrative-text h3 {
        font-size: 0.95rem;
        margin: 0.5rem 0 0.3rem 0;
        color: #4a5568;
        font-weight: 600;
    }

    .narrative-text p {
        margin: 0.25rem 0;
    }

    .narrative-text ul, .narrative-text ol {
        margin: 0.5rem 0;
        padding-left: 2rem;
    }

    .narrative-text li {
        margin: 0.25rem 0;
    }

    .narrative-text strong {
        font-weight: 600;
        color: #1a202c;
    }

    .narrative-text em {
        font-style: italic;
        color: #4a5568;
    }

    .scene-action {
        margin-bottom: 1rem;
        padding: 1rem;
        background: #f8f9fa;
        border-left: 4px solid #667eea;
        border-radius: 4px;
    }

    .action-label {
        font-weight: bold;
        color: #667eea;
        margin-bottom: 0.5rem;
    }

    .action-result {
        color: #666;
    }

    /* Conversation Messages */
    .conversation-message {
        margin-bottom: 1.5rem;
        animation: fadeIn 0.3s ease-in;
    }

    @keyframes fadeIn {
        from { opacity: 0; transform: translateY(10px); }
        to { opacity: 1; transform: translateY(0); }
    }

    .player-message {
        margin-bottom: 0.75rem;
        padding: 0.75rem 1rem;
        background: #e3f2fd;
        border-left: 4px solid #2196f3;
        border-radius: 4px;
        font-weight: 500;
        color: #1565c0;
    }

    .player-message::before {
        content: "You: ";
        font-weight: 700;
        color: #1565c0;
    }

    .gm-response {
        padding: 0.75rem 1rem;
        background: #f8f9fa;
        border-left: 4px solid #667eea;
        border-radius: 4px;
        color: #2d3748;
        line-height: 1.5;
        font-size: 0.9rem;
    }

    .gm-response::before {
        content: "GM: ";
        font-weight: 700;
        color: #667eea;
        display: block;
        margin-bottom: 0.4rem;
        font-size: 0.85rem;
    }

    /* Style headers within GM responses */
    .gm-response h1 {
        font-size: 1.1rem;
        margin: 0.75rem 0 0.4rem 0;
        color: #2d3748;
        font-weight: 700;
    }

    .gm-response h2 {
        font-size: 1rem;
        margin: 0.6rem 0 0.3rem 0;
        color: #2d3748;
        font-weight: 600;
    }

    .gm-response h3 {
        font-size: 0.95rem;
        margin: 0.5rem 0 0.3rem 0;
        color: #4a5568;
        font-weight: 600;
    }

    .gm-response p {
        margin: 0.1rem 0;
    }

    /* Better list formatting in GM responses */
    .gm-response ul,
    .gm-response ol {
        margin: 0.5rem 0;
        padding-left: 1.5rem;
    }

    .gm-response li {
        margin: 0.2rem 0;
        line-height: 1.4;
    }

    .gm-response ul li {
        list-style-type: disc;
    }

    .gm-response ol li {
        list-style-type: decimal;
    }

    /* Nested lists */
    .gm-response ul ul,
    .gm-response ol ul {
        margin: 0.2rem 0;
        padding-left: 1.2rem;
    }

    .gm-response ul ul li {
        list-style-type: circle;
    }

    .gm-response strong {
        font-weight: 600;
        color: #1a202c;
    }

    .gm-response em {
        font-style: italic;
        color: #4a5568;
    }

    /* Action Input */
    .action-input-area {
        width: 100%;
        padding: 1rem 2rem;
        background: white;
        border-top: 1px solid #ddd;
        box-sizing: border-box;
    }

    .suggested-actions {
        display: flex;
        gap: 0.5rem;
        margin-bottom: 1rem;
        flex-wrap: wrap;
    }

    .suggested-action {
        padding: 0.5rem 1rem;
        background: #e3f2fd;
        border: 1px solid #2196f3;
        border-radius: 16px;
        cursor: pointer;
        font-size: 0.9rem;
        transition: all 0.2s;
    }

    .suggested-action:hover {
        background: #2196f3;
        color: white;
    }

    .action-input-form {
        display: flex;
        gap: 0.5rem;
    }

    .action-input {
        flex: 1;
        padding: 0.75rem;
        border: 2px solid #ddd;
        border-radius: 4px;
        font-size: 1rem;
        color: #1a1a1a !important;
        background: #ffffff !important;
    }

    /* Override base template's light gray text color for action input */
    #actionInput {
        color: #1a1a1a !important;
        background: #ffffff !important;
    }

    .action-input:focus {
        outline: none;
        border-color: #667eea;
    }

    .btn-submit-action {
        padding: 0.75rem 2rem;
        background: #667eea;
        color: white;
        border: none;
        border-radius: 4px;
        cursor: pointer;
        font-size: 1rem;
        font-weight: 600;
    }

    .btn-submit-action:hover {
        background: #5568d3;
    }

    .btn-submit-action:disabled {
        background: #ccc;
        cursor: not-allowed;
    }

    /* Chat Panel */
    .chat-panel {
        width: 100%;
        background: white;
        border-radius: 8px;
        max-height: 200px;
        display: flex;
        flex-direction: column;
        box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        box-sizing: border-box;
    }

    .chat-tabs {
        display: flex;
        border-bottom: 1px solid #ddd;
    }

    .chat-tab {
        padding: 0.75rem 1.5rem;
        cursor: pointer;
        border-bottom: 2px solid transparent;
        transition: all 0.2s;
        color: #4a5568;
        font-weight: 500;
    }

    .chat-tab.active {
        border-bottom-color: #667eea;
        color: #667eea;
        font-weight: 600;
    }

    .chat-messages {
        flex: 1;
        padding: 1rem;
        overflow-y: auto;
        max-height: 150px;
    }

    .chat-message {
        margin-bottom: 0.75rem;
        padding: 1rem;
        border-radius: 6px;
        background: #ffffff;
        border: 1px solid #e0e0e0;
        color: #1a1a1a;
        font-size: 0.95rem;
        line-height: 1.5;
    }

    .message-sender {
        font-weight: 700;
        margin-bottom: 0.5rem;
        color: #1a1a1a;
        font-size: 0.9rem;
    }

    .message-gm {
        background: #f0f7ff;
        border-left: 4px solid #2196f3;
        border: 1px solid #bbdefb;
    }

    .message-gm .message-sender {
        color: #1565c0;
    }

    .message-npc {
        background: #fff8e1;
        border-left: 4px solid #ff9800;
        border: 1px solid #ffe0b2;
    }

    .message-npc .message-sender {
        color: #e65100;
    }

    .message-system {
        background: #fce4ec;
        border-left: 4px solid #9c27b0;
        border: 1px solid #f8bbd0;
        font-style: italic;
    }

    .message-system .message-sender {
        color: #6a1b9a;
    }

    .connection-status {
        position: fixed;
        top: 80px;
        right: 20px;
        padding: 1rem;
        background: white;
        border-radius: 8px;
        box-shadow: 0 2px 10px rgba(0,0,0,0.2);
        z-index: 1000;
        display: none;
    }

    .connection-status.connected {
        border-left: 4px solid #28a745;
    }

    .connection-status.disconnected {
        border-left: 4px solid #dc3545;
        display: block;
    }

    .connection-status.connecting {
        border-left: 4px solid #ffc107;
        display: block;
    }
</style>
{% endblock %}

{% block content %}
<div class="game-container">
    <!-- Game Session Wrapper -->
    <div class="game-session-wrapper">
        <!-- Header -->
        <div class="game-header">
        <div class="game-title">
            üéÆ {{ session_data.campaign_name|default:"Game Session" }}
        </div>
        <div class="game-status">
            <div id="connectionStatus">‚óè Connecting...</div>
            <div><a href="{% url 'games:lobby' %}" style="color: white;">‚Üê Back to Lobby</a></div>
        </div>
    </div>

    <!-- Left Drawer Toggle -->
    <button class="drawer-toggle drawer-toggle-left" id="questToggle" title="Toggle Quest Panel">
        üìã
    </button>

    <!-- Right Drawer Toggle -->
    <button class="drawer-toggle drawer-toggle-right" id="partyToggle" title="Toggle Party Panel">
        üë•
    </button>

    <!-- Left Drawer - Quest Panel -->
    <div class="drawer drawer-left" id="questDrawer">
        <div class="drawer-header">
            <div class="drawer-title">üìã Game Status</div>
            <div class="drawer-controls">
                <button class="drawer-btn" id="questPin" title="Pin drawer">üìå</button>
                <button class="drawer-btn" id="questClose" title="Close">‚úï</button>
            </div>
        </div>
        <div class="drawer-content" id="questObjectives">
            <p style="color: #b8b8d1;">Waiting for quest data...</p>
        </div>
    </div>

    <!-- Right Drawer - Progress & Acquisitions -->
    <div class="drawer drawer-right" id="partyDrawer">
        <div class="drawer-header">
            <div class="drawer-title">üéí Game Inventory</div>
            <div class="drawer-controls">
                <button class="drawer-btn" id="partyPin" title="Pin drawer">üìå</button>
                <button class="drawer-btn" id="partyClose" title="Close">‚úï</button>
            </div>
        </div>
        <div class="drawer-content" id="acquisitionsContent">
            <p style="color: #b8b8d1;">Loading acquisitions...</p>
        </div>
    </div>

    <!-- Acquisition Detail Modal -->
    <div id="acquisitionModal" class="objective-modal" style="display: none;">
        <div class="objective-modal-content">
            <div class="objective-modal-header">
                <h2 id="acquisitionModalTitle"></h2>
                <button class="objective-modal-close" onclick="document.getElementById('acquisitionModal').style.display='none'">&times;</button>
            </div>
            <div class="objective-modal-body">
                <div class="acquisition-detail-header">
                    <div class="acquisition-icon-large" id="acquisitionIcon"></div>
                    <div class="acquisition-meta-info">
                        <div class="acquisition-type" id="acquisitionType"></div>
                        <div class="acquisition-acquired-time" id="acquisitionTime"></div>
                    </div>
                </div>
                <div class="acquisition-detail-description">
                    <h3>Description</h3>
                    <p id="acquisitionDescription"></p>
                </div>
                <div class="acquisition-detail-purpose" id="acquisitionPurposeSection" style="display: none;">
                    <h3>Purpose & Objectives</h3>
                    <p id="acquisitionPurpose"></p>
                    <div id="acquisitionObjectives"></div>
                </div>
                <div class="acquisition-detail-source" id="acquisitionSourceSection" style="display: none;">
                    <h3>How Acquired</h3>
                    <p id="acquisitionSource"></p>
                </div>
            </div>
        </div>
    </div>

    <!-- Objective Detail Modal -->
    <div id="objectiveModal" class="objective-modal" style="display: none;">
        <div class="objective-modal-content">
            <div class="objective-modal-header">
                <h2 id="modalObjectiveTitle"></h2>
                <button class="objective-modal-close">&times;</button>
            </div>
            <div class="objective-modal-body">
                <div class="objective-progress-summary">
                    <div class="progress-stat">
                        <span class="stat-label">Progress:</span>
                        <span id="modalProgress" class="stat-value"></span>
                    </div>
                    <div class="progress-stat">
                        <span class="stat-label">Status:</span>
                        <span id="modalStatus" class="stat-value"></span>
                    </div>
                </div>
                <div class="progress-bar-container">
                    <div id="modalProgressBar" class="progress-bar-fill"></div>
                </div>
                <div class="objective-description">
                    <h3>Objective Details</h3>
                    <p id="modalDescription"></p>
                </div>
                <div class="objective-acquisitions">
                    <h3>Progress History</h3>
                    <div id="modalAcquisitions" class="acquisitions-list"></div>
                </div>
            </div>
        </div>
    </div>

    <!-- Main Content -->
    <div class="game-content" id="gameContent">
        <div class="main-content">
            <!-- Scene Viewer -->
            <div class="scene-viewer">
                <div class="scene-content" id="sceneContent">
                    <div class="conversation-message">
                        <div class="gm-response">
                            üé¨ Initializing game session...<br>
                            Connecting to game server...
                        </div>
                    </div>
                </div>
                <div class="action-input-area">
                    <div class="suggested-actions" id="suggestedActions">
                        <!-- Suggested actions will be populated here -->
                    </div>
                    <form class="action-input-form" id="actionForm">
                        <input
                            type="text"
                            class="action-input"
                            id="actionInput"
                            placeholder="What do you want to do?"
                            autocomplete="off"
                            disabled
                        >
                        <button type="submit" class="btn-submit-action" id="submitAction" disabled>
                            Send ‚Üí
                        </button>
                    </form>
                </div>
            </div>
        </div>
    </div>
    </div> <!-- Close game-session-wrapper -->

    <!-- Connection Status -->
    <div id="connectionStatusBox" class="connection-status connecting">
        <strong>Connection Status:</strong> <span id="statusText">Connecting...</span>
    </div>
</div>

<script>
// Configuration
const SESSION_ID = '{{ session_id }}';
const PLAYER_ID = '{{ player_id }}';
const WS_URL = '{{ ws_gateway_url|default:"ws://localhost:9600" }}';

// Game Client
class GameClient {
    constructor() {
        this.ws = null;
        this.isConnected = false;
        this.reconnectAttempts = 0;
        this.maxReconnectAttempts = 5;
    }

    connect() {
        const wsPath = `${WS_URL}/ws/game/${SESSION_ID}/player/${PLAYER_ID}`;
        console.log('Connecting to:', wsPath);

        this.updateConnectionStatus('connecting', 'Connecting...');

        this.ws = new WebSocket(wsPath);

        this.ws.onopen = () => {
            console.log('WebSocket connected');
            this.isConnected = true;
            this.reconnectAttempts = 0;
            this.updateConnectionStatus('connected', 'Connected');
            document.getElementById('actionInput').disabled = false;
            document.getElementById('submitAction').disabled = false;
        };

        this.ws.onmessage = (event) => {
            try {
                const data = JSON.parse(event.data);
                this.handleMessage(data);
            } catch (e) {
                console.error('Error parsing message:', e);
            }
        };

        this.ws.onerror = (error) => {
            console.error('WebSocket error:', error);
        };

        this.ws.onclose = () => {
            console.log('WebSocket closed');
            this.isConnected = false;
            this.updateConnectionStatus('disconnected', 'Disconnected');
            document.getElementById('actionInput').disabled = true;
            document.getElementById('submitAction').disabled = true;
            this.attemptReconnect();
        };
    }

    handleMessage(data) {
        console.log('Received message:', data);

        switch(data.type) {
            case 'connection':
                console.log('Connection confirmed');
                break;
            case 'event':
                this.handleEvent(data);
                break;
            case 'ack':
                console.log('Action acknowledged');
                break;
            case 'pong':
                console.log('Pong received');
                break;
            default:
                console.log('Unknown message type:', data.type);
        }
    }

    handleEvent(data) {
        const eventType = data.event_type;

        switch(eventType) {
            case 'scene_update':
                this.updateScene(data.payload);
                break;
            case 'scene_chunk':
                this.handleSceneChunk(data.payload);
                break;
            case 'quest_progress':
                this.updateQuestProgress(data.payload);
                break;
            case 'chat_message':
                this.addChatMessage(data.payload);
                break;
            case 'notification':
                this.showNotification(data.payload);
                break;
            case 'player_status':
                this.updatePlayerStatus(data.payload);
                break;
            case 'party_update':
                // Party updates can be safely ignored or logged
                console.log('Party update:', data.payload);
                break;
            case 'acquisitions_update':
                this.updateAcquisitions(data.payload);
                break;
            case 'knowledge_acquired':
            case 'item_acquired':
            case 'event_completed':
            case 'challenge_completed':
                // Individual acquisition events - trigger a full refresh
                console.log('Acquisition event:', eventType, data.payload);
                // TODO: Request full acquisitions update from server
                break;
            default:
                console.log('Unhandled event type:', eventType);
        }
    }

    sendPlayerAction(action) {
        if (!this.isConnected) {
            console.error('Not connected to server');
            return;
        }

        const message = {
            type: 'command',
            command_type: 'player_action',
            payload: {
                action: action
            },
            request_id: this.generateRequestId()
        };

        this.ws.send(JSON.stringify(message));

        // Add to scene
        this.addActionToScene(action);
    }

    addActionToScene(action) {
        const sceneContent = document.getElementById('sceneContent');

        // Create conversation message container
        const messageContainer = document.createElement('div');
        messageContainer.className = 'conversation-message';

        // Add player message
        const playerMsg = document.createElement('div');
        playerMsg.className = 'player-message';
        playerMsg.textContent = action;

        messageContainer.appendChild(playerMsg);

        // Add loading indicator
        const loadingMsg = document.createElement('div');
        loadingMsg.className = 'gm-response gm-loading';
        loadingMsg.innerHTML = '<em>üé≤ GM is thinking...</em>';
        loadingMsg.id = 'gm-loading-indicator';
        messageContainer.appendChild(loadingMsg);

        sceneContent.appendChild(messageContainer);
        sceneContent.scrollTop = sceneContent.scrollHeight;

        return messageContainer; // Return for adding GM response later
    }

    handleSceneChunk(chunkData) {
        const sceneContent = document.getElementById('sceneContent');

        // Remove loading indicator if present
        const loadingIndicator = document.getElementById('gm-loading-indicator');
        if (loadingIndicator && !this.currentStreamingDiv) {
            loadingIndicator.remove();
        }

        // If this is the first chunk, create a new conversation message with GM response
        if (!this.currentStreamingDiv) {
            // Get or create conversation message container
            let messageContainer = sceneContent.querySelector('.conversation-message:last-child');
            if (!messageContainer || (messageContainer.querySelector('.gm-response') && !messageContainer.querySelector('.gm-loading'))) {
                messageContainer = document.createElement('div');
                messageContainer.className = 'conversation-message';
                sceneContent.appendChild(messageContainer);
            }

            this.currentStreamingDiv = document.createElement('div');
            this.currentStreamingDiv.className = 'gm-response streaming';
            messageContainer.appendChild(this.currentStreamingDiv);
            this.streamingText = ''; // Accumulate raw text
        }

        if (chunkData.is_complete) {
            // Streaming is complete, parse accumulated text
            if (this.currentStreamingDiv) {
                this.currentStreamingDiv.innerHTML = this.parseMarkdown(this.streamingText);
                this.currentStreamingDiv.classList.remove('streaming');
                this.currentStreamingDiv = null;
                this.streamingText = '';

                // Smooth scroll to bottom with delay for rendering
                setTimeout(() => {
                    sceneContent.scrollTo({
                        top: sceneContent.scrollHeight,
                        behavior: 'smooth'
                    });
                }, 100);
            }
        } else {
            // Accumulate chunk and display with simple formatting
            this.streamingText += chunkData.chunk;

            // Simple formatting for streaming (headers, bold, italic, paragraphs)
            const displayText = this.streamingText
                .replace(/^### (.*$)/gim, '<h3>$1</h3>')
                .replace(/^## (.*$)/gim, '<h2>$1</h2>')
                .replace(/^# (.*$)/gim, '<h1>$1</h1>')
                .replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>')
                .replace(/\*(.*?)\*/g, '<em>$1</em>')
                .replace(/\n\n+/g, '</p><p>')
                .replace(/\n/g, ' ');

            this.currentStreamingDiv.innerHTML = '<p>' + displayText + '</p>';

            // Auto-scroll during streaming
            sceneContent.scrollTop = sceneContent.scrollHeight;
        }
    }

    parseMarkdown(text) {
        if (!text) return '';

        // Split into lines for better processing
        const lines = text.split('\n');
        let html = '';
        let inList = false;
        let listType = null;

        for (let i = 0; i < lines.length; i++) {
            const line = lines[i];
            const trimmedLine = line.trim();

            // Check for unordered list (-, *, ‚Ä¢)
            const ulMatch = trimmedLine.match(/^[-*‚Ä¢]\s+(.+)$/);
            // Check for ordered list (1., 2., etc.)
            const olMatch = trimmedLine.match(/^\d+\.\s+(.+)$/);

            if (ulMatch) {
                if (!inList || listType !== 'ul') {
                    if (inList) html += listType === 'ol' ? '</ol>' : '</ul>';
                    html += '<ul>';
                    listType = 'ul';
                    inList = true;
                }
                html += `<li>${this.parseInline(ulMatch[1])}</li>`;
            } else if (olMatch) {
                if (!inList || listType !== 'ol') {
                    if (inList) html += listType === 'ol' ? '</ol>' : '</ul>';
                    html += '<ol>';
                    listType = 'ol';
                    inList = true;
                }
                html += `<li>${this.parseInline(olMatch[1])}</li>`;
            } else {
                if (inList) {
                    html += listType === 'ol' ? '</ol>' : '</ul>';
                    inList = false;
                    listType = null;
                }

                if (trimmedLine === '') {
                    html += '<br>';
                } else if (trimmedLine.startsWith('###')) {
                    html += `<h3>${this.parseInline(trimmedLine.substring(3).trim())}</h3>`;
                } else if (trimmedLine.startsWith('##')) {
                    html += `<h2>${this.parseInline(trimmedLine.substring(2).trim())}</h2>`;
                } else if (trimmedLine.startsWith('#')) {
                    html += `<h1>${this.parseInline(trimmedLine.substring(1).trim())}</h1>`;
                } else {
                    html += `<p>${this.parseInline(trimmedLine)}</p>`;
                }
            }
        }

        // Close any open lists
        if (inList) {
            html += listType === 'ol' ? '</ol>' : '</ul>';
        }

        return html;
    }

    parseInline(text) {
        return text
            .replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>')
            .replace(/\*(.*?)\*/g, '<em>$1</em>');
    }

    updateScene(sceneData) {
        // Scene updates now only update available actions
        // GM responses come via chat_message events to avoid duplication

        // Update suggested actions
        if (sceneData.available_actions) {
            this.updateSuggestedActions(sceneData.available_actions);
        }
    }

    updateSuggestedActions(actions) {
        const container = document.getElementById('suggestedActions');
        container.innerHTML = '';

        actions.slice(0, 4).forEach(action => {
            const btn = document.createElement('button');
            btn.className = 'suggested-action';
            btn.textContent = action;
            btn.onclick = () => {
                document.getElementById('actionInput').value = action;
            };
            container.appendChild(btn);
        });
    }

    updateQuestProgress(questData) {
        const container = document.getElementById('questObjectives');

        // Store quest data for modal access
        this.currentQuestData = questData;

        if (!questData) {
            container.innerHTML = '<p style="color: #b8b8d1;">Waiting for quest data...</p>';
            return;
        }

        // Load collapsed state from localStorage
        const campaignCollapsed = localStorage.getItem('campaignSectionCollapsed') === 'true';
        const questCollapsed = localStorage.getItem('questSectionCollapsed') === 'true';

        // Build the new comprehensive quest tracker UI
        let html = '';

        // Quest name header
        if (questData.quest_name) {
            html += `
                <div style="margin-bottom: 0.75rem;">
                    <div style="color: #d4af37; font-size: 0.95rem; font-weight: 600;">Quest: ${questData.quest_name}</div>
                </div>
            `;
        }

        // Progress badges (without campaign title since it's in main section)
        html += `
            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 0.5rem; font-size: 0.85rem; margin-bottom: 1.5rem;">
                <div style="padding: 0.5rem; background: rgba(74, 222, 128, 0.1); border-radius: 4px; text-align: center;">
                    <div style="color: #4ade80; font-size: 1.2rem; font-weight: 600;">${questData.knowledge_count || 0}</div>
                    <div style="color: #94a3b8;">Knowledge</div>
                </div>
                <div style="padding: 0.5rem; background: rgba(147, 197, 253, 0.1); border-radius: 4px; text-align: center;">
                    <div style="color: #93c5fd; font-size: 1.2rem; font-weight: 600;">${questData.items_count || 0}</div>
                    <div style="color: #94a3b8;">Items</div>
                </div>
            </div>
        `;

        // Campaign Objectives Section
        if (questData.campaign_objectives && questData.campaign_objectives.length > 0) {
            const campaignProgress = questData.campaign_overall_progress || 0;
            const toggleIcon = campaignCollapsed ? '‚ñ∂' : '‚ñº';

            html += `
                <div class="quest-section">
                    <div class="quest-section-header" data-section="campaign">
                        <div class="quest-section-title">
                            <span class="collapse-icon">${toggleIcon}</span>
                            <span>üéØ Campaign Objectives</span>
                        </div>
                        <div class="quest-section-progress">${Math.round(campaignProgress)}%</div>
                    </div>
                    <div class="quest-section-body ${campaignCollapsed ? 'collapsed' : ''}">
                        <div class="progress-bar-container">
                            <div class="progress-bar-fill" style="width: ${campaignProgress}%"></div>
                        </div>
            `;

            questData.campaign_objectives.forEach((obj, index) => {
                const progress = obj.percent || obj.completion_percentage || 0;
                const completed = obj.completed || progress === 100;
                const icon = completed ? '‚úÖ' : progress > 0 ? 'üîÑ' : '‚¨ú';

                html += `
                    <div class="objective-item ${completed ? 'completed' : ''}" data-objective-type="campaign" data-objective-index="${index}">
                        <div class="objective-header">
                            <span class="objective-icon">${icon}</span>
                            <span class="objective-text">${obj.description || 'Unknown objective'}</span>
                        </div>
                        <div class="objective-meta">
                            <span class="objective-progress-text">${Math.round(progress)}%</span>
                            <span class="objective-click-hint">üìã Click for details</span>
                        </div>
                        <div class="progress-bar-container">
                            <div class="progress-bar-fill" style="width: ${progress}%"></div>
                        </div>
                    </div>
                `;
            });

            html += `
                    </div>
                </div>
            `;
        }

        // Quest Objectives Section
        if (questData.objectives && questData.objectives.length > 0) {
            const questProgress = questData.overall_progress || 0;
            const toggleIcon = questCollapsed ? '‚ñ∂' : '‚ñº';

            html += `
                <div class="quest-section">
                    <div class="quest-section-header" data-section="quest">
                        <div class="quest-section-title">
                            <span class="collapse-icon">${toggleIcon}</span>
                            <span>‚öîÔ∏è ${questData.quest_name || 'Current Quest'}</span>
                        </div>
                        <div class="quest-section-progress">${Math.round(questProgress)}%</div>
                    </div>
                    <div class="quest-section-body ${questCollapsed ? 'collapsed' : ''}">
                        <div class="progress-bar-container">
                            <div class="progress-bar-fill" style="width: ${questProgress}%"></div>
                        </div>
            `;

            questData.objectives.forEach((obj, index) => {
                const progress = obj.percent || 0;
                const completed = obj.completed || progress === 100;
                const icon = completed ? '‚úÖ' : progress > 0 ? 'üîÑ' : '‚¨ú';

                html += `
                    <div class="objective-item ${completed ? 'completed' : ''}" data-objective-type="quest" data-objective-index="${index}">
                        <div class="objective-header">
                            <span class="objective-icon">${icon}</span>
                            <span class="objective-text">${obj.description || 'Unknown objective'}</span>
                        </div>
                        <div class="objective-meta">
                            <span class="objective-progress-text">${Math.round(progress)}%</span>
                            <span class="objective-click-hint">üìã Click for details</span>
                        </div>
                        <div class="progress-bar-container">
                            <div class="progress-bar-fill" style="width: ${progress}%"></div>
                        </div>
                    </div>
                `;
            });

            html += `
                    </div>
                </div>
            `;
        }

        // If no objectives at all
        if ((!questData.campaign_objectives || questData.campaign_objectives.length === 0) &&
            (!questData.objectives || questData.objectives.length === 0)) {
            html = '<p style="color: #b8b8d1;">No objectives available</p>';
        }

        container.innerHTML = html;

        // Add collapse/expand handlers to section headers
        container.querySelectorAll('.quest-section-header').forEach(header => {
            header.addEventListener('click', (e) => {
                const section = e.currentTarget.getAttribute('data-section');
                const body = e.currentTarget.nextElementSibling;
                const icon = e.currentTarget.querySelector('.collapse-icon');

                body.classList.toggle('collapsed');
                const isCollapsed = body.classList.contains('collapsed');
                icon.textContent = isCollapsed ? '‚ñ∂' : '‚ñº';

                // Save state to localStorage
                localStorage.setItem(`${section}SectionCollapsed`, isCollapsed);
            });
        });

        // Add click handlers to objectives
        container.querySelectorAll('.objective-item').forEach(item => {
            item.addEventListener('click', (e) => {
                const type = e.currentTarget.getAttribute('data-objective-type');
                const index = parseInt(e.currentTarget.getAttribute('data-objective-index'));
                const objective = type === 'campaign'
                    ? questData.campaign_objectives[index]
                    : questData.objectives[index];
                this.showObjectiveDetails(objective, index, type);
            });
        });
    }

    showObjectiveDetails(objective, index, type = 'quest') {
        const modal = document.getElementById('objectiveModal');
        const title = document.getElementById('modalObjectiveTitle');
        const progress = document.getElementById('modalProgress');
        const status = document.getElementById('modalStatus');
        const progressBar = document.getElementById('modalProgressBar');
        const description = document.getElementById('modalDescription');
        const acquisitions = document.getElementById('modalAcquisitions');

        // Get progress value (different field names for campaign vs quest)
        const progressValue = objective.percent || objective.completion_percentage || 0;

        // Populate modal
        const objectiveType = type === 'campaign' ? 'üéØ Campaign' : '‚öîÔ∏è Quest';
        title.textContent = `${objectiveType}: ${objective.description || 'Objective Details'}`;
        progress.textContent = `${Math.round(progressValue)}%`;
        status.textContent = objective.completed || progressValue === 100 ? 'Completed ‚úÖ' : progressValue > 0 ? 'In Progress üîÑ' : 'Not Started ‚¨ú';
        progressBar.style.width = `${progressValue}%`;
        description.textContent = objective.description || 'No additional details available.';

        // Show acquisitions (knowledge, items, events acquired for this objective)
        if (objective.acquisitions && objective.acquisitions.length > 0) {
            let acquisitionsHtml = '';
            objective.acquisitions.forEach(acq => {
                acquisitionsHtml += `
                    <div class="acquisition-item">
                        <div class="acquisition-header">
                            <span class="acquisition-name">${acq.name || 'Unknown item'}</span>
                            <span class="acquisition-time">${this.formatTime(acq.timestamp)}</span>
                        </div>
                        <div class="acquisition-details">
                            ${acq.how || 'Acquired through gameplay'}
                        </div>
                        ${acq.purpose ? `<div class="acquisition-purpose">Purpose: ${acq.purpose}</div>` : ''}
                    </div>
                `;
            });
            acquisitions.innerHTML = acquisitionsHtml;
        } else {
            acquisitions.innerHTML = '<div class="empty-acquisitions">No progress recorded yet.<br>Complete actions to make progress on this objective.</div>';
        }

        // Show modal
        modal.style.display = 'flex';
    }

    formatTime(timestamp) {
        if (!timestamp) return 'Recently';
        const date = new Date(timestamp);
        const now = new Date();
        const diff = now - date;
        const minutes = Math.floor(diff / 60000);
        const hours = Math.floor(minutes / 60);
        const days = Math.floor(hours / 24);

        if (days > 0) return `${days}d ago`;
        if (hours > 0) return `${hours}h ago`;
        if (minutes > 0) return `${minutes}m ago`;
        return 'Just now';
    }

    updateAcquisitions(acquisitionsData) {
        const container = document.getElementById('acquisitionsContent');

        // Store for modal access
        this.acquisitionsData = acquisitionsData;

        if (!acquisitionsData) {
            container.innerHTML = '<p style="color: #b8b8d1;">No acquisitions yet. Start exploring!</p>';
            return;
        }

        // Load collapsed states
        const knowledgeCollapsed = localStorage.getItem('knowledgeSectionCollapsed') === 'true';
        const itemsCollapsed = localStorage.getItem('itemsSectionCollapsed') === 'true';
        const eventsCollapsed = localStorage.getItem('eventsSectionCollapsed') === 'true';
        const challengesCollapsed = localStorage.getItem('challengesSectionCollapsed') === 'true';

        let html = '';

        // Knowledge Section
        const knowledge = acquisitionsData.knowledge || [];
        html += this.renderAcquisitionSection('knowledge', 'üìö Knowledge', knowledge, knowledgeCollapsed, '3b82f6');

        // Items Section
        const items = acquisitionsData.items || [];
        html += this.renderAcquisitionSection('items', 'üéí Items', items, itemsCollapsed, '10b981');

        // Events Section
        const events = acquisitionsData.events || [];
        html += this.renderAcquisitionSection('events', 'üé≠ Events', events, eventsCollapsed, 'f59e0b');

        // Challenges Section
        const challenges = acquisitionsData.challenges || [];
        html += this.renderAcquisitionSection('challenges', '‚öîÔ∏è Challenges', challenges, challengesCollapsed, 'ef4444');

        container.innerHTML = html;

        // Add collapse handlers
        container.querySelectorAll('.quest-section-header').forEach(header => {
            header.addEventListener('click', (e) => {
                const section = e.currentTarget.getAttribute('data-section');
                const body = e.currentTarget.nextElementSibling;
                const icon = e.currentTarget.querySelector('.collapse-icon');

                body.classList.toggle('collapsed');
                const isCollapsed = body.classList.contains('collapsed');
                icon.textContent = isCollapsed ? '‚ñ∂' : '‚ñº';

                localStorage.setItem(`${section}SectionCollapsed`, isCollapsed);
            });
        });

        // Add click handlers to acquisition cards
        container.querySelectorAll('.acquisition-card').forEach(card => {
            card.addEventListener('click', (e) => {
                const type = e.currentTarget.getAttribute('data-type');
                const id = e.currentTarget.getAttribute('data-id');
                this.showAcquisitionDetails(type, id);
            });
        });
    }

    renderAcquisitionSection(sectionId, title, items, collapsed, color) {
        const toggleIcon = collapsed ? '‚ñ∂' : '‚ñº';
        const count = items.length;

        let html = `
            <div class="quest-section">
                <div class="quest-section-header" data-section="${sectionId}">
                    <div class="quest-section-title">
                        <span class="collapse-icon">${toggleIcon}</span>
                        <span>${title}</span>
                    </div>
                    <div class="acquisition-section-count">${count}</div>
                </div>
                <div class="quest-section-body ${collapsed ? 'collapsed' : ''}">
        `;

        if (items.length === 0) {
            html += `<p style="color: #94a3b8; font-size: 0.85rem; text-align: center; padding: 1rem;">None acquired yet</p>`;
        } else {
            items.forEach(item => {
                const icon = this.getAcquisitionIcon(sectionId);
                html += `
                    <div class="acquisition-card ${sectionId}" data-type="${sectionId}" data-id="${item.id || item.name}">
                        <div class="acquisition-card-icon">${icon}</div>
                        <div class="acquisition-card-content">
                            <div class="acquisition-card-name">${item.name || 'Unknown'}</div>
                            <div class="acquisition-card-desc">${item.description || 'No description'}</div>
                        </div>
                    </div>
                `;
            });
        }

        html += `
                </div>
            </div>
        `;

        return html;
    }

    getAcquisitionIcon(type) {
        const icons = {
            'knowledge': 'üìö',
            'items': 'üéí',
            'events': 'üé≠',
            'challenges': '‚öîÔ∏è'
        };
        return icons[type] || 'üì¶';
    }

    showAcquisitionDetails(type, id) {
        const modal = document.getElementById('acquisitionModal');
        const data = this.acquisitionsData[type];
        const item = data ? data.find(i => (i.id || i.name) === id) : null;

        if (!item) return;

        // Populate modal
        document.getElementById('acquisitionModalTitle').textContent = item.name || 'Unknown';
        document.getElementById('acquisitionIcon').textContent = this.getAcquisitionIcon(type);
        document.getElementById('acquisitionType').textContent = type.toUpperCase();
        document.getElementById('acquisitionTime').textContent = item.acquired_at ?
            `Acquired ${this.formatTime(item.acquired_at)}` : 'Recently acquired';
        document.getElementById('acquisitionDescription').textContent = item.description || 'No description available.';

        // Show/hide optional sections
        const purposeSection = document.getElementById('acquisitionPurposeSection');
        const sourceSection = document.getElementById('acquisitionSourceSection');

        if (item.purpose || item.objectives) {
            purposeSection.style.display = 'block';
            document.getElementById('acquisitionPurpose').textContent = item.purpose || '';

            if (item.objectives && item.objectives.length > 0) {
                let objectivesHtml = '';
                item.objectives.forEach(obj => {
                    objectivesHtml += `<div class="acquisition-objective-link">${obj}</div>`;
                });
                document.getElementById('acquisitionObjectives').innerHTML = objectivesHtml;
            } else {
                document.getElementById('acquisitionObjectives').innerHTML = '';
            }
        } else {
            purposeSection.style.display = 'none';
        }

        if (item.source || item.how_acquired) {
            sourceSection.style.display = 'block';
            document.getElementById('acquisitionSource').textContent = item.source || item.how_acquired || '';
        } else {
            sourceSection.style.display = 'none';
        }

        // Show modal
        modal.style.display = 'flex';
    }

    addChatMessage(messageData) {
        // Display GM narrative messages as conversation responses
        if (messageData.message_type === 'DM_NARRATIVE' || messageData.sender === 'Game Master') {
            const sceneContent = document.getElementById('sceneContent');

            // Remove loading indicator if present
            const loadingIndicator = document.getElementById('gm-loading-indicator');
            if (loadingIndicator) {
                loadingIndicator.remove();
            }

            // Get or create the last conversation message container
            let messageContainer = sceneContent.querySelector('.conversation-message:last-child');

            // If there's already a GM response (not loading), create a new one
            if (!messageContainer || (messageContainer.querySelector('.gm-response') && !messageContainer.querySelector('.gm-loading'))) {
                messageContainer = document.createElement('div');
                messageContainer.className = 'conversation-message';
                sceneContent.appendChild(messageContainer);
            }

            // Add GM response
            const gmResponse = document.createElement('div');
            gmResponse.className = 'gm-response';
            gmResponse.innerHTML = this.parseMarkdown(messageData.content);

            messageContainer.appendChild(gmResponse);

            // Smooth scroll to bottom with delay for rendering
            setTimeout(() => {
                sceneContent.scrollTo({
                    top: sceneContent.scrollHeight,
                    behavior: 'smooth'
                });
            }, 100);
        } else {
            console.log('Chat message received:', messageData);
        }
    }

    showNotification(notificationData) {
        alert(notificationData.message);
    }

    updatePlayerStatus(statusData) {
        console.log('Player status updated:', statusData);
    }

    updateConnectionStatus(status, text) {
        const statusBox = document.getElementById('connectionStatusBox');
        const statusText = document.getElementById('statusText');
        const headerStatus = document.getElementById('connectionStatus');

        statusBox.className = `connection-status ${status}`;
        statusText.textContent = text;

        if (status === 'connected') {
            headerStatus.innerHTML = '‚óè Connected';
            headerStatus.style.color = '#4ade80'; // Bright green
            setTimeout(() => {
                statusBox.style.display = 'none';
            }, 3000);
        } else {
            headerStatus.innerHTML = `‚óè ${text}`;
            headerStatus.style.color = status === 'connecting' ? '#fbbf24' : '#f87171'; // Bright yellow/red
        }
    }

    attemptReconnect() {
        if (this.reconnectAttempts < this.maxReconnectAttempts) {
            this.reconnectAttempts++;
            console.log(`Reconnecting (attempt ${this.reconnectAttempts})...`);
            setTimeout(() => this.connect(), 2000 * this.reconnectAttempts);
        } else {
            console.error('Max reconnect attempts reached');
            this.updateConnectionStatus('disconnected', 'Connection failed. Please refresh.');
        }
    }

    generateRequestId() {
        return Math.random().toString(36).substring(7);
    }
}

// Initialize game client
const gameClient = new GameClient();

// Drawer Management
class DrawerManager {
    constructor() {
        this.questOpen = false;
        this.questAnchored = false;
        this.partyOpen = false;
        this.partyAnchored = false;

        // Load saved states from localStorage
        this.loadState();
    }

    loadState() {
        try {
            const savedState = localStorage.getItem('gameDrawerState');
            if (savedState) {
                const state = JSON.parse(savedState);

                // Restore quest drawer
                if (state.questAnchored) {
                    this.questAnchored = true;
                    this.questOpen = true;
                    const drawer = document.getElementById('questDrawer');
                    const content = document.getElementById('gameContent');
                    const toggle = document.getElementById('questToggle');
                    const pinBtn = document.getElementById('questPin');

                    drawer.classList.add('open', 'anchored');
                    document.querySelector('.game-session-wrapper').classList.add('left-pinned');
                    toggle.classList.add('hidden');
                    pinBtn.classList.add('active');
                }

                // Restore party drawer
                if (state.partyAnchored) {
                    this.partyAnchored = true;
                    this.partyOpen = true;
                    const drawer = document.getElementById('partyDrawer');
                    const content = document.getElementById('gameContent');
                    const toggle = document.getElementById('partyToggle');
                    const pinBtn = document.getElementById('partyPin');

                    drawer.classList.add('open', 'anchored');
                    document.querySelector('.game-session-wrapper').classList.add('right-pinned');
                    toggle.classList.add('hidden');
                    pinBtn.classList.add('active');
                }
            }
        } catch (e) {
            console.error('Error loading drawer state:', e);
        }
    }

    saveState() {
        try {
            const state = {
                questAnchored: this.questAnchored,
                partyAnchored: this.partyAnchored
            };
            localStorage.setItem('gameDrawerState', JSON.stringify(state));
        } catch (e) {
            console.error('Error saving drawer state:', e);
        }
    }

    toggleQuest() {
        this.questOpen = !this.questOpen;
        const drawer = document.getElementById('questDrawer');
        const toggle = document.getElementById('questToggle');
        const content = document.getElementById('gameContent');

        if (this.questOpen) {
            drawer.classList.add('open');
        } else {
            drawer.classList.remove('open');
            if (this.questAnchored) {
                this.questAnchored = false;
                drawer.classList.remove('anchored');
                document.getElementById('questPin').classList.remove('active');
                content.classList.remove('left-pinned');
                toggle.classList.remove('hidden');
            }
        }
    }

    toggleParty() {
        this.partyOpen = !this.partyOpen;
        const drawer = document.getElementById('partyDrawer');
        const toggle = document.getElementById('partyToggle');
        const content = document.getElementById('gameContent');

        if (this.partyOpen) {
            drawer.classList.add('open');
        } else {
            drawer.classList.remove('open');
            if (this.partyAnchored) {
                this.partyAnchored = false;
                drawer.classList.remove('anchored');
                document.getElementById('partyPin').classList.remove('active');
                content.classList.remove('right-pinned');
                toggle.classList.remove('hidden');
            }
        }
    }

    pinQuest() {
        if (!this.questOpen) return;

        this.questAnchored = !this.questAnchored;
        const drawer = document.getElementById('questDrawer');
        const content = document.getElementById('gameContent');
        const toggle = document.getElementById('questToggle');
        const pinBtn = document.getElementById('questPin');

        if (this.questAnchored) {
            drawer.classList.add('anchored');
            document.querySelector('.game-session-wrapper').classList.add('left-pinned');
            toggle.classList.add('hidden');
            pinBtn.classList.add('active');
        } else {
            drawer.classList.remove('anchored');
            document.querySelector('.game-session-wrapper').classList.remove('left-pinned');
            toggle.classList.remove('hidden');
            pinBtn.classList.remove('active');
        }

        this.saveState();
    }

    pinParty() {
        if (!this.partyOpen) return;

        this.partyAnchored = !this.partyAnchored;
        const drawer = document.getElementById('partyDrawer');
        const content = document.getElementById('gameContent');
        const toggle = document.getElementById('partyToggle');
        const pinBtn = document.getElementById('partyPin');

        if (this.partyAnchored) {
            drawer.classList.add('anchored');
            document.querySelector('.game-session-wrapper').classList.add('right-pinned');
            toggle.classList.add('hidden');
            pinBtn.classList.add('active');
        } else {
            drawer.classList.remove('anchored');
            document.querySelector('.game-session-wrapper').classList.remove('right-pinned');
            toggle.classList.remove('hidden');
            pinBtn.classList.remove('active');
        }

        this.saveState();
    }
}

const drawerManager = new DrawerManager();

// Load initial scene from saved state
async function loadInitialScene() {
    try {
        const sessionId = '{{ session_data.session_id }}';
        const response = await fetch(`http://localhost:9500/api/v1/session/${sessionId}/state`);

        if (response.ok) {
            const state = await response.json();
            const sceneContent = document.getElementById('sceneContent');
            sceneContent.innerHTML = ''; // Clear loading message

            // Load conversation from chat_messages
            if (state.chat_messages && state.chat_messages.length > 0) {
                state.chat_messages.forEach(msg => {
                    const messageContainer = document.createElement('div');
                    messageContainer.className = 'conversation-message';

                    if (msg.message_type === 'PLAYER_ACTION') {
                        const playerMsg = document.createElement('div');
                        playerMsg.className = 'player-message';
                        playerMsg.textContent = msg.content;
                        messageContainer.appendChild(playerMsg);
                    } else if (msg.message_type === 'DM_NARRATIVE' || msg.sender === 'Game Master') {
                        const gmMsg = document.createElement('div');
                        gmMsg.className = 'gm-response';
                        gmMsg.innerHTML = gameClient.parseMarkdown(msg.content);
                        messageContainer.appendChild(gmMsg);
                    }

                    sceneContent.appendChild(messageContainer);
                });
            }

            // If no conversation, show current scene description
            if (state.scene_description && (!state.chat_messages || state.chat_messages.length === 0)) {
                const messageContainer = document.createElement('div');
                messageContainer.className = 'conversation-message';

                const gmResponse = document.createElement('div');
                gmResponse.className = 'gm-response';
                gmResponse.innerHTML = gameClient.parseMarkdown(state.scene_description);

                messageContainer.appendChild(gmResponse);
                sceneContent.appendChild(messageContainer);
            }

            // Update suggested actions if available
            if (state.available_actions && state.available_actions.length > 0) {
                gameClient.updateSuggestedActions(state.available_actions);
            }

            // Enable action input
            const actionInput = document.getElementById('actionInput');
            const submitBtn = document.getElementById('submitAction');
            actionInput.disabled = false;
            submitBtn.disabled = false;

            // Scroll to bottom (with delay to ensure content is rendered)
            setTimeout(() => {
                sceneContent.scrollTop = sceneContent.scrollHeight;
            }, 100);

            // Load quest progress
            if (state.quest_progress) {
                gameClient.updateQuestProgress(state.quest_progress);
            } else {
                // Fetch quest progress from API if not in state
                try {
                    const questResponse = await fetch(`http://localhost:9500/api/v1/session/${sessionId}/quest-progress`);
                    if (questResponse.ok) {
                        const questProgress = await questResponse.json();
                        gameClient.updateQuestProgress(questProgress);
                    }
                } catch (error) {
                    console.error('Error fetching quest progress:', error);
                }
            }

            // Load acquisitions (knowledge, items, events, challenges)
            if (state.player_knowledge_full || state.player_inventories_full) {
                const playerId = state.players && state.players[0] ? state.players[0].player_id : null;
                if (playerId) {
                    const acquisitionsData = {
                        knowledge: state.player_knowledge_full?.[playerId] || [],
                        items: state.player_inventories_full?.[playerId] || [],
                        events: state.completed_events || [],
                        challenges: state.completed_challenges || []
                    };
                    gameClient.updateAcquisitions(acquisitionsData);
                }
            }

            // Note: loadCampaignInfo() is no longer needed - updateQuestProgress() now handles everything
        }
    } catch (error) {
        console.error('Error loading initial scene:', error);
    }
}

// Load campaign and quest information
function loadCampaignInfo(state) {
    const container = document.getElementById('questObjectives');
    let html = '';

    // Campaign header
    if (state.campaign_name) {
        html += `
            <div style="margin-bottom: 1.5rem; padding-bottom: 1rem; border-bottom: 2px solid rgba(212, 175, 55, 0.3);">
                <h3 style="color: #d4af37; margin: 0 0 0.5rem 0; font-size: 1.1rem;">üìú ${state.campaign_name}</h3>
                ${state.campaign_plot ? `<p style="font-size: 0.85rem; color: #b8b8d1; margin: 0;">${state.campaign_plot}</p>` : ''}
            </div>
        `;
    }

    // Current quest
    if (state.quest_progress) {
        const quest = state.quest_progress;
        html += `
            <div style="margin-bottom: 1rem;">
                <h4 style="color: #d4af37; margin: 0 0 0.5rem 0; font-size: 1rem;">‚öîÔ∏è ${quest.quest_name || 'Current Quest'}</h4>
                <div style="font-size: 0.8rem; color: #94a3b8; margin-bottom: 0.5rem;">
                    Progress: ${quest.overall_progress || 0}%
                </div>
            </div>
        `;

        // Objectives
        if (quest.objectives && quest.objectives.length > 0) {
            html += '<div style="margin-top: 1rem;">';
            html += '<div style="font-size: 0.9rem; color: #d4af37; margin-bottom: 0.5rem; font-weight: 600;">Objectives:</div>';

            quest.objectives.forEach((obj, index) => {
                const completed = obj.completed || obj.percent === 100;
                const progress = obj.percent || 0;

                html += `
                    <div class="objective-item" style="margin-bottom: 0.75rem; padding: 0.5rem; background: rgba(255,255,255,0.05); border-radius: 4px;">
                        <div style="display: flex; align-items: start; gap: 0.5rem;">
                            <div style="flex-shrink: 0; margin-top: 2px;">
                                ${completed ? '‚úÖ' : '‚¨ú'}
                            </div>
                            <div style="flex: 1;">
                                <div style="font-size: 0.85rem; color: ${completed ? '#4ade80' : '#e0e0e0'}; margin-bottom: 0.25rem;">
                                    ${obj.description}
                                </div>
                                ${progress > 0 ? `
                                    <div style="background: rgba(0,0,0,0.3); height: 6px; border-radius: 3px; overflow: hidden;">
                                        <div style="width: ${progress}%; height: 100%; background: linear-gradient(90deg, #4ade80 0%, #22c55e 100%); transition: width 0.3s;"></div>
                                    </div>
                                ` : ''}
                            </div>
                        </div>
                    </div>
                `;
            });
            html += '</div>';
        }
    }

    // Player achievements section
    const knowledge = state.player_knowledge_full || state.player_knowledge || {};
    const inventory = state.player_inventories_full || state.player_inventories || {};

    const knowledgeCount = Object.keys(knowledge).length;
    const itemCount = Object.keys(inventory).length;

    if (knowledgeCount > 0 || itemCount > 0) {
        html += `
            <div style="margin-top: 1.5rem; padding-top: 1rem; border-top: 2px solid rgba(212, 175, 55, 0.3);">
                <h4 style="color: #d4af37; margin: 0 0 0.75rem 0; font-size: 0.95rem;">üìä Progress</h4>
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 0.5rem; font-size: 0.85rem;">
                    <div style="padding: 0.5rem; background: rgba(74, 222, 128, 0.1); border-radius: 4px; text-align: center;">
                        <div style="color: #4ade80; font-size: 1.2rem; font-weight: 600;">${knowledgeCount}</div>
                        <div style="color: #94a3b8;">Knowledge</div>
                    </div>
                    <div style="padding: 0.5rem; background: rgba(147, 197, 253, 0.1); border-radius: 4px; text-align: center;">
                        <div style="color: #93c5fd; font-size: 1.2rem; font-weight: 600;">${itemCount}</div>
                        <div style="color: #94a3b8;">Items</div>
                    </div>
                </div>
            </div>
        `;
    }

    container.innerHTML = html || '<p style="color: #b8b8d1;">No active quests</p>';
}

// Connect on page load
document.addEventListener('DOMContentLoaded', async () => {
    // Load initial scene from state
    await loadInitialScene();

    gameClient.connect();

    // Drawer controls
    document.getElementById('questToggle').addEventListener('click', () => {
        drawerManager.toggleQuest();
    });

    document.getElementById('questClose').addEventListener('click', () => {
        drawerManager.toggleQuest();
    });

    document.getElementById('questPin').addEventListener('click', () => {
        drawerManager.pinQuest();
    });

    // Objective Modal Handlers
    const modal = document.getElementById('objectiveModal');
    const modalClose = document.querySelector('.objective-modal-close');

    // Close modal when clicking the X button
    if (modalClose) {
        modalClose.addEventListener('click', () => {
            modal.style.display = 'none';
        });
    }

    // Close modal when clicking outside the modal content
    modal.addEventListener('click', (e) => {
        if (e.target === modal) {
            modal.style.display = 'none';
        }
    });

    // Close modal with Escape key
    document.addEventListener('keydown', (e) => {
        if (e.key === 'Escape' && modal.style.display === 'flex') {
            modal.style.display = 'none';
        }
    });

    document.getElementById('partyToggle').addEventListener('click', () => {
        drawerManager.toggleParty();
    });

    document.getElementById('partyClose').addEventListener('click', () => {
        drawerManager.toggleParty();
    });

    document.getElementById('partyPin').addEventListener('click', () => {
        drawerManager.pinParty();
    });

    // Handle action form submission
    document.getElementById('actionForm').addEventListener('submit', (e) => {
        e.preventDefault();
        const input = document.getElementById('actionInput');
        const action = input.value.trim();

        if (action) {
            gameClient.sendPlayerAction(action);
            input.value = '';
        }
    });

    // Chat tabs
    document.querySelectorAll('.chat-tab').forEach(tab => {
        tab.addEventListener('click', () => {
            document.querySelectorAll('.chat-tab').forEach(t => t.classList.remove('active'));
            tab.classList.add('active');
        });
    });
});
</script>
{% endblock %}
