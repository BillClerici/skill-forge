{% extends 'base.html' %}
{% load static %}

{% block title %}Game Session - SkillForge{% endblock %}

{% block extra_css %}
<style>
    /* Cache buster v2.9 - Full width layout with base template at 98% 2025-10-21-1802 */
    * {
        box-sizing: border-box;
    }

    body {
        margin: 0;
        overflow-x: hidden; /* Prevent horizontal scroll only */
    }

    /* Remove container padding for game page to use full width */
    main .container {
        padding: 0 !important;
        max-width: 100% !important;
    }

    .game-container {
        height: 100vh;
        display: flex;
        flex-direction: column;
        background: #f5f5f5;
        position: relative;
    }

    /* Game Session Wrapper - container for header + content */
    .game-session-wrapper {
        position: absolute;
        top: 6px;
        left: 6px;
        right: 6px;
        bottom: 6px;
        display: flex;
        flex-direction: column;
        border-radius: 8px;
        box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        overflow: hidden;
        transition: left 0.3s ease-in-out, right 0.3s ease-in-out;
        z-index: 50;
    }

    .game-session-wrapper.left-pinned {
        left: calc(320px + 6px);
    }

    .game-session-wrapper.right-pinned {
        right: calc(320px + 6px);
    }

    .game-session-wrapper.left-pinned.right-pinned {
        left: calc(320px + 6px);
        right: calc(320px + 6px);
    }

    /* Header */
    .game-header {
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        color: white;
        padding: 1rem 2rem;
        display: flex;
        justify-content: space-between;
        align-items: center;
        flex-shrink: 0;
        z-index: 100;
    }

    .game-title {
        font-size: 1.3rem;
        font-weight: bold;
    }

    .game-status {
        display: flex;
        gap: 2rem;
        font-size: 0.9rem;
    }

    #connectionStatus {
        text-shadow: 0 0 10px rgba(255, 255, 255, 0.6);
    }

    /* Main Content Area */
    .game-content {
        flex: 1;
        display: flex;
        overflow: hidden;
        box-sizing: border-box;
        padding: 0;
        background: white;
    }

    /* Main Scene Area */
    .main-content {
        width: 100%;
        max-width: 100%;
        height: 100%;
        display: grid;
        grid-template-rows: 60% 40%;
        gap: 0;
        overflow: hidden;
        box-sizing: border-box;
        flex: 1;
        min-width: 0; /* Allow flexbox to shrink */
    }

    /* Drawer Styles - RPG Fantasy Theme */
    .drawer {
        position: fixed;
        top: 64px;
        bottom: 0;
        width: 320px;
        background: linear-gradient(180deg, #16213e 0%, #1a1a2e 100%);
        color: #e0e0e0;
        box-shadow: 4px 0 12px rgba(0, 0, 0, 0.5);
        transition: transform 0.3s ease-in-out;
        z-index: 110;
        display: flex;
        flex-direction: column;
        overflow: hidden;
    }

    .drawer-left {
        left: 0;
        transform: translateX(-100%);
        border-right: 2px solid rgba(212, 175, 55, 0.2);
    }

    .drawer-left.open {
        transform: translateX(0);
    }

    .drawer-left.anchored {
        transform: translateX(0);
        box-shadow: -4px 0 12px rgba(0, 0, 0, 0.5); /* Flip shadow to go left when anchored */
        border-right: none; /* Remove border when anchored to prevent overlap */
    }

    .drawer-right {
        right: 0;
        transform: translateX(100%);
        border-left: 2px solid rgba(212, 175, 55, 0.2);
    }

    .drawer-right.open {
        transform: translateX(0);
    }

    .drawer-right.anchored {
        transform: translateX(0);
        box-shadow: 4px 0 12px rgba(0, 0, 0, 0.5); /* Flip shadow to go right when anchored */
        border-left: none; /* Remove border when anchored to prevent overlap */
    }

    .drawer-header {
        background: linear-gradient(135deg, #2d1b69 0%, #1a1a2e 100%);
        color: white;
        padding: 0.6rem 0.8rem;
        display: flex;
        justify-content: space-between;
        align-items: center;
        flex-shrink: 0;
        border-bottom: 2px solid #d4af37;
        box-shadow: 0 2px 8px rgba(212, 175, 55, 0.3);
    }

    .drawer-title {
        font-size: 0.95rem;
        font-weight: 700;
        letter-spacing: 0.5px;
        color: #d4af37;
        text-shadow: 0 0 10px rgba(212, 175, 55, 0.5);
    }

    .drawer-controls {
        display: flex;
        gap: 0.5rem;
    }

    .drawer-btn {
        background: rgba(255, 255, 255, 0.2);
        border: 1px solid rgba(255, 255, 255, 0.3);
        color: white;
        cursor: pointer;
        padding: 0.25rem 0.5rem;
        border-radius: 4px;
        font-size: 1rem;
        transition: all 0.2s;
    }

    .drawer-btn:hover {
        background: rgba(255, 255, 255, 0.3);
    }

    .drawer-btn.active {
        background: rgba(212, 175, 55, 0.4);
        border-color: #d4af37;
    }

    .drawer-content {
        flex: 1;
        padding: 0.6rem;
        overflow-y: auto;
        background: linear-gradient(180deg, #16213e 0%, #1a1a2e 100%);
    }

    .drawer-content h3 {
        color: #d4af37;
        font-size: 1rem;
        font-weight: bold;
        margin: 0 0 0.6rem 0;
        text-shadow: 0 0 10px rgba(212, 175, 55, 0.3);
    }

    .drawer-content h4 {
        color: #c0c0c0;
        font-size: 0.85rem;
        font-weight: bold;
        margin: 0.6rem 0 0.3rem 0;
        letter-spacing: 0.3px;
    }

    .drawer-content p {
        color: #d0d0e0;
    }

    /* RPG-themed scrollbar */
    .drawer-content::-webkit-scrollbar {
        width: 12px;
    }

    .drawer-content::-webkit-scrollbar-track {
        background: #0f0f1e;
    }

    .drawer-content::-webkit-scrollbar-thumb {
        background: linear-gradient(180deg, #d4af37 0%, #cd7f32 100%);
        border-radius: 6px;
        border: 2px solid #0f0f1e;
    }

    .drawer-content::-webkit-scrollbar-thumb:hover {
        background: #d4af37;
    }

    /* Toggle Buttons */
    .drawer-toggle {
        position: fixed;
        top: 50%;
        transform: translateY(-50%);
        background: #667eea;
        color: white;
        border: none;
        padding: 1rem 0.5rem;
        cursor: pointer;
        z-index: 85;
        font-size: 1rem;
        border-radius: 0 8px 8px 0;
        box-shadow: 2px 0 8px rgba(0,0,0,0.2);
        transition: all 0.2s;
    }

    .drawer-toggle:hover {
        background: #5a67d8;
        transform: translateY(-50%) scale(1.05);
    }

    .drawer-toggle-left {
        left: 0;
    }

    .drawer-toggle-left.hidden {
        left: 320px;
    }

    .drawer-toggle-right {
        right: 0;
        border-radius: 8px 0 0 8px;
        box-shadow: -2px 0 8px rgba(0,0,0,0.2);
    }

    .drawer-toggle-right.hidden {
        right: 320px;
    }

    /* Quest Panel Content */
    .objective-item {
        padding: 0.75rem;
        display: flex;
        align-items: center;
        gap: 0.75rem;
        border-bottom: 1px solid rgba(212, 175, 55, 0.2);
        background: rgba(255, 255, 255, 0.05);
        margin-bottom: 0.5rem;
        border-radius: 4px;
    }

    .objective-item:last-child {
        border-bottom: none;
    }

    /* Custom checkbox using div - no Materialize interference */
    .objective-checkbox-wrapper {
        flex-shrink: 0;
    }

    .custom-checkbox {
        width: 28px;
        height: 28px;
        border: 3px solid #d4af37;
        background-color: rgba(22, 33, 62, 0.5);
        border-radius: 8px;
        position: relative;
        transition: all 0.3s ease;
        box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
        display: flex;
        align-items: center;
        justify-content: center;
    }

    .custom-checkbox:hover {
        transform: scale(1.05);
        border-color: #e0c050;
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4), 0 0 12px rgba(212, 175, 55, 0.3);
    }

    .custom-checkbox.checked {
        background: linear-gradient(135deg, #d4af37 0%, #c9a030 100%);
        border-color: #d4af37;
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4), 0 0 20px rgba(212, 175, 55, 0.5);
        animation: checkBounce 0.4s ease;
    }

    @keyframes checkBounce {
        0% { transform: scale(1); }
        50% { transform: scale(1.15); }
        100% { transform: scale(1); }
    }

    .custom-checkbox.checked::after {
        content: '✓';
        color: #0f0f1e;
        font-size: 20px;
        font-weight: 900;
        line-height: 1;
        animation: checkAppear 0.3s ease;
    }

    @keyframes checkAppear {
        0% {
            transform: scale(0);
            opacity: 0;
        }
        100% {
            transform: scale(1);
            opacity: 1;
        }
    }

    .objective-item span {
        color: #f0f0f0;
        font-size: 0.95rem;
    }

    /* Remove any pseudo-elements from span */
    .objective-item span::before,
    .objective-item span::after {
        display: none !important;
        content: none !important;
    }

    /* Party Panel Content */
    .player-item {
        padding: 1rem;
        border-radius: 6px;
        margin-bottom: 0.5rem;
        background: rgba(255, 255, 255, 0.05);
        border: 1px solid rgba(212, 175, 55, 0.2);
    }

    .player-item:last-child {
        margin-bottom: 0;
    }

    .player-name {
        font-weight: bold;
        margin-bottom: 0.5rem;
        font-size: 1rem;
        color: #d4af37;
    }

    .player-status {
        font-size: 0.85rem;
        color: #b8b8d1;
        display: flex;
        align-items: center;
        gap: 0.5rem;
    }

    .status-online {
        color: #4ade80;
    }

    .status-offline {
        color: #94a3b8;
    }

    /* Scene Viewer */
    .scene-viewer {
        width: 100%;
        display: flex;
        flex-direction: column;
        background: white;
        border-radius: 0;
        box-shadow: none;
        overflow: hidden;
        box-sizing: border-box;
        border-bottom: 1px solid #e2e8f0;
    }

    .scene-content {
        width: 100%;
        flex: 1;
        padding: 1rem 2rem;
        overflow-y: auto !important; /* Always show vertical scroll */
        overflow-x: hidden;
        background: linear-gradient(to bottom, #f8f9fa 0%, #ffffff 100%);
        box-sizing: border-box;
    }

    .narrative-text {
        font-size: 0.95rem;
        line-height: 1.6;
        color: #333;
        margin-bottom: 1rem;
    }

    .narrative-text h1 {
        font-size: 1.5rem;
        margin: 1rem 0 0.5rem 0;
        color: #2d3748;
    }

    .narrative-text h2 {
        font-size: 1.25rem;
        margin: 1rem 0 0.5rem 0;
        color: #2d3748;
    }

    .narrative-text h3 {
        font-size: 1.1rem;
        margin: 0.75rem 0 0.5rem 0;
        color: #4a5568;
    }

    .narrative-text p {
        margin: 0.25rem 0;
    }

    .narrative-text ul, .narrative-text ol {
        margin: 0.5rem 0;
        padding-left: 2rem;
    }

    .narrative-text li {
        margin: 0.25rem 0;
    }

    .narrative-text strong {
        font-weight: 600;
        color: #1a202c;
    }

    .narrative-text em {
        font-style: italic;
        color: #4a5568;
    }

    .scene-action {
        margin-bottom: 1rem;
        padding: 1rem;
        background: #f8f9fa;
        border-left: 4px solid #667eea;
        border-radius: 4px;
    }

    .action-label {
        font-weight: bold;
        color: #667eea;
        margin-bottom: 0.5rem;
    }

    .action-result {
        color: #666;
    }

    /* Action Input */
    .action-input-area {
        width: 100%;
        padding: 1rem 2rem;
        background: white;
        border-top: 1px solid #ddd;
        box-sizing: border-box;
    }

    .suggested-actions {
        display: flex;
        gap: 0.5rem;
        margin-bottom: 1rem;
        flex-wrap: wrap;
    }

    .suggested-action {
        padding: 0.5rem 1rem;
        background: #e3f2fd;
        border: 1px solid #2196f3;
        border-radius: 16px;
        cursor: pointer;
        font-size: 0.9rem;
        transition: all 0.2s;
    }

    .suggested-action:hover {
        background: #2196f3;
        color: white;
    }

    .action-input-form {
        display: flex;
        gap: 0.5rem;
    }

    .action-input {
        flex: 1;
        padding: 0.75rem;
        border: 2px solid #ddd;
        border-radius: 4px;
        font-size: 1rem;
    }

    .action-input:focus {
        outline: none;
        border-color: #667eea;
    }

    .btn-submit-action {
        padding: 0.75rem 2rem;
        background: #667eea;
        color: white;
        border: none;
        border-radius: 4px;
        cursor: pointer;
        font-size: 1rem;
        font-weight: 600;
    }

    .btn-submit-action:hover {
        background: #5568d3;
    }

    .btn-submit-action:disabled {
        background: #ccc;
        cursor: not-allowed;
    }

    /* Chat Panel */
    .chat-panel {
        width: 100%;
        background: white;
        border-radius: 8px;
        max-height: 200px;
        display: flex;
        flex-direction: column;
        box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        box-sizing: border-box;
    }

    .chat-tabs {
        display: flex;
        border-bottom: 1px solid #ddd;
    }

    .chat-tab {
        padding: 0.75rem 1.5rem;
        cursor: pointer;
        border-bottom: 2px solid transparent;
        transition: all 0.2s;
    }

    .chat-tab.active {
        border-bottom-color: #667eea;
        color: #667eea;
        font-weight: 600;
    }

    .chat-messages {
        flex: 1;
        padding: 1rem;
        overflow-y: auto;
        max-height: 150px;
    }

    .chat-message {
        margin-bottom: 0.75rem;
        padding: 1rem;
        border-radius: 6px;
        background: #ffffff;
        border: 1px solid #e0e0e0;
        color: #1a1a1a;
        font-size: 0.95rem;
        line-height: 1.5;
    }

    .message-sender {
        font-weight: 700;
        margin-bottom: 0.5rem;
        color: #1a1a1a;
        font-size: 0.9rem;
    }

    .message-gm {
        background: #f0f7ff;
        border-left: 4px solid #2196f3;
        border: 1px solid #bbdefb;
    }

    .message-gm .message-sender {
        color: #1565c0;
    }

    .message-npc {
        background: #fff8e1;
        border-left: 4px solid #ff9800;
        border: 1px solid #ffe0b2;
    }

    .message-npc .message-sender {
        color: #e65100;
    }

    .message-system {
        background: #fce4ec;
        border-left: 4px solid #9c27b0;
        border: 1px solid #f8bbd0;
        font-style: italic;
    }

    .message-system .message-sender {
        color: #6a1b9a;
    }

    .connection-status {
        position: fixed;
        top: 80px;
        right: 20px;
        padding: 1rem;
        background: white;
        border-radius: 8px;
        box-shadow: 0 2px 10px rgba(0,0,0,0.2);
        z-index: 1000;
        display: none;
    }

    .connection-status.connected {
        border-left: 4px solid #28a745;
    }

    .connection-status.disconnected {
        border-left: 4px solid #dc3545;
        display: block;
    }

    .connection-status.connecting {
        border-left: 4px solid #ffc107;
        display: block;
    }
</style>
{% endblock %}

{% block content %}
<div class="game-container">
    <!-- Game Session Wrapper -->
    <div class="game-session-wrapper">
        <!-- Header -->
        <div class="game-header">
        <div class="game-title">
            🎮 {{ session_data.campaign_name|default:"Game Session" }}
        </div>
        <div class="game-status">
            <div id="connectionStatus">● Connecting...</div>
            <div><a href="{% url 'games:lobby' %}" style="color: white;">← Back to Lobby</a></div>
        </div>
    </div>

    <!-- Left Drawer Toggle -->
    <button class="drawer-toggle drawer-toggle-left" id="questToggle" title="Toggle Quest Panel">
        📋
    </button>

    <!-- Right Drawer Toggle -->
    <button class="drawer-toggle drawer-toggle-right" id="partyToggle" title="Toggle Party Panel">
        👥
    </button>

    <!-- Left Drawer - Quest Panel -->
    <div class="drawer drawer-left" id="questDrawer">
        <div class="drawer-header">
            <div class="drawer-title">📋 Current Quest</div>
            <div class="drawer-controls">
                <button class="drawer-btn" id="questPin" title="Pin drawer">📌</button>
                <button class="drawer-btn" id="questClose" title="Close">✕</button>
            </div>
        </div>
        <div class="drawer-content" id="questObjectives">
            <p style="color: #b8b8d1;">Waiting for quest data...</p>
        </div>
    </div>

    <!-- Right Drawer - Party Panel -->
    <div class="drawer drawer-right" id="partyDrawer">
        <div class="drawer-header">
            <div class="drawer-title">👥 Party</div>
            <div class="drawer-controls">
                <button class="drawer-btn" id="partyPin" title="Pin drawer">📌</button>
                <button class="drawer-btn" id="partyClose" title="Close">✕</button>
            </div>
        </div>
        <div class="drawer-content" id="partyList">
            <div class="player-item">
                <div class="player-name">You</div>
                <div class="player-status status-online">● Online</div>
            </div>
        </div>
    </div>

    <!-- Main Content -->
    <div class="game-content" id="gameContent">
        <div class="main-content">
            <!-- Scene Viewer -->
            <div class="scene-viewer">
                <div class="scene-content" id="sceneContent">
                    <div class="narrative-text">
                        <p>🎬 Initializing game session...</p>
                        <p>Connecting to game server...</p>
                    </div>
                </div>
                <div class="action-input-area">
                    <div class="suggested-actions" id="suggestedActions">
                        <!-- Suggested actions will be populated here -->
                    </div>
                    <form class="action-input-form" id="actionForm">
                        <input
                            type="text"
                            class="action-input"
                            id="actionInput"
                            placeholder="What do you want to do?"
                            autocomplete="off"
                            disabled
                        >
                        <button type="submit" class="btn-submit-action" id="submitAction" disabled>
                            Send →
                        </button>
                    </form>
                </div>
            </div>

            <!-- Chat Panel -->
            <div class="chat-panel">
                <div class="chat-tabs">
                    <div class="chat-tab active" data-tab="gm">GM Narrative</div>
                    <div class="chat-tab" data-tab="team">Team Chat</div>
                </div>
                <div class="chat-messages" id="chatMessages">
                    <div class="chat-message message-system">
                        <div class="message-sender">System</div>
                        <div>Game session starting...</div>
                    </div>
                </div>
            </div>
        </div>
    </div>
    </div> <!-- Close game-session-wrapper -->

    <!-- Connection Status -->
    <div id="connectionStatusBox" class="connection-status connecting">
        <strong>Connection Status:</strong> <span id="statusText">Connecting...</span>
    </div>
</div>

<script>
// Configuration
const SESSION_ID = '{{ session_id }}';
const PLAYER_ID = '{{ player_id }}';
const WS_URL = '{{ ws_gateway_url|default:"ws://localhost:9600" }}';

// Game Client
class GameClient {
    constructor() {
        this.ws = null;
        this.isConnected = false;
        this.reconnectAttempts = 0;
        this.maxReconnectAttempts = 5;
    }

    connect() {
        const wsPath = `${WS_URL}/ws/game/${SESSION_ID}/player/${PLAYER_ID}`;
        console.log('Connecting to:', wsPath);

        this.updateConnectionStatus('connecting', 'Connecting...');

        this.ws = new WebSocket(wsPath);

        this.ws.onopen = () => {
            console.log('WebSocket connected');
            this.isConnected = true;
            this.reconnectAttempts = 0;
            this.updateConnectionStatus('connected', 'Connected');
            document.getElementById('actionInput').disabled = false;
            document.getElementById('submitAction').disabled = false;
        };

        this.ws.onmessage = (event) => {
            try {
                const data = JSON.parse(event.data);
                this.handleMessage(data);
            } catch (e) {
                console.error('Error parsing message:', e);
            }
        };

        this.ws.onerror = (error) => {
            console.error('WebSocket error:', error);
        };

        this.ws.onclose = () => {
            console.log('WebSocket closed');
            this.isConnected = false;
            this.updateConnectionStatus('disconnected', 'Disconnected');
            document.getElementById('actionInput').disabled = true;
            document.getElementById('submitAction').disabled = true;
            this.attemptReconnect();
        };
    }

    handleMessage(data) {
        console.log('Received message:', data);

        switch(data.type) {
            case 'connection':
                console.log('Connection confirmed');
                break;
            case 'event':
                this.handleEvent(data);
                break;
            case 'ack':
                console.log('Action acknowledged');
                break;
            case 'pong':
                console.log('Pong received');
                break;
            default:
                console.log('Unknown message type:', data.type);
        }
    }

    handleEvent(data) {
        const eventType = data.event_type;

        switch(eventType) {
            case 'scene_update':
                this.updateScene(data.payload);
                break;
            case 'scene_chunk':
                this.handleSceneChunk(data.payload);
                break;
            case 'quest_progress':
                this.updateQuestProgress(data.payload);
                break;
            case 'chat_message':
                this.addChatMessage(data.payload);
                break;
            case 'notification':
                this.showNotification(data.payload);
                break;
            case 'player_status':
                this.updatePlayerStatus(data.payload);
                break;
            default:
                console.log('Unhandled event type:', eventType);
        }
    }

    sendPlayerAction(action) {
        if (!this.isConnected) {
            console.error('Not connected to server');
            return;
        }

        const message = {
            type: 'command',
            command_type: 'player_action',
            payload: {
                action: action
            },
            request_id: this.generateRequestId()
        };

        this.ws.send(JSON.stringify(message));

        // Add to scene
        this.addActionToScene(action);
    }

    addActionToScene(action) {
        const sceneContent = document.getElementById('sceneContent');
        const actionDiv = document.createElement('div');
        actionDiv.className = 'scene-action';
        actionDiv.innerHTML = `
            <div class="action-label">You:</div>
            <div class="action-result">${action}</div>
        `;
        sceneContent.appendChild(actionDiv);
        sceneContent.scrollTop = sceneContent.scrollHeight;
    }

    handleSceneChunk(chunkData) {
        const sceneContent = document.getElementById('sceneContent');

        // If this is the first chunk, create a new streaming narrative div
        if (!this.currentStreamingDiv) {
            this.currentStreamingDiv = document.createElement('div');
            this.currentStreamingDiv.className = 'narrative-text streaming';
            this.currentStreamingDiv.innerHTML = '<p></p>';
            sceneContent.appendChild(this.currentStreamingDiv);
        }

        if (chunkData.is_complete) {
            // Streaming is complete, clean up
            if (this.currentStreamingDiv) {
                this.currentStreamingDiv.classList.remove('streaming');
                this.currentStreamingDiv = null;
            }
        } else {
            // Append the chunk
            const paragraph = this.currentStreamingDiv.querySelector('p');
            // Convert markdown to HTML (basic conversion)
            const htmlChunk = chunkData.chunk
                .replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>')  // Bold
                .replace(/^## (.*?)$/gm, '<h2>$1</h2>')             // Headers
                .replace(/^- (.*?)$/gm, '<li>$1</li>')              // List items
                .replace(/\n\n/g, '</p><p>')                        // Paragraphs
                .replace(/\n/g, '<br>');                            // Line breaks

            paragraph.innerHTML += htmlChunk;
            sceneContent.scrollTop = sceneContent.scrollHeight;
        }
    }

    parseMarkdown(text) {
        if (!text) return '';

        // Convert markdown to HTML
        let html = text
            // Headers
            .replace(/^### (.*$)/gim, '<h3>$1</h3>')
            .replace(/^## (.*$)/gim, '<h2>$1</h2>')
            .replace(/^# (.*$)/gim, '<h1>$1</h1>')
            // Bold
            .replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>')
            // Italic
            .replace(/\*(.*?)\*/g, '<em>$1</em>')
            // Lists
            .replace(/^\- (.*$)/gim, '<li>$1</li>')
            // Paragraphs
            .replace(/\n\n/g, '</p><p>')
            .replace(/\n/g, '<br>');

        // Wrap in paragraph if not already wrapped
        if (!html.startsWith('<h') && !html.startsWith('<li')) {
            html = '<p>' + html + '</p>';
        }

        // Wrap list items in ul
        html = html.replace(/(<li>.*?<\/li>)/gs, '<ul>$1</ul>');

        return html;
    }

    updateScene(sceneData) {
        const sceneContent = document.getElementById('sceneContent');

        const narrativeDiv = document.createElement('div');
        narrativeDiv.className = 'narrative-text';
        const rawText = sceneData.scene_description || sceneData.description;
        narrativeDiv.innerHTML = this.parseMarkdown(rawText);
        sceneContent.appendChild(narrativeDiv);

        sceneContent.scrollTop = sceneContent.scrollHeight;

        // Update suggested actions
        if (sceneData.available_actions) {
            this.updateSuggestedActions(sceneData.available_actions);
        }
    }

    updateSuggestedActions(actions) {
        const container = document.getElementById('suggestedActions');
        container.innerHTML = '';

        actions.slice(0, 4).forEach(action => {
            const btn = document.createElement('button');
            btn.className = 'suggested-action';
            btn.textContent = action;
            btn.onclick = () => {
                document.getElementById('actionInput').value = action;
            };
            container.appendChild(btn);
        });
    }

    updateQuestProgress(questData) {
        const container = document.getElementById('questObjectives');
        container.innerHTML = '';

        if (questData.objectives && questData.objectives.length > 0) {
            questData.objectives.forEach(obj => {
                const div = document.createElement('div');
                div.className = 'objective-item';

                // Create checkbox wrapper to avoid Materialize interference
                const checkboxWrapper = document.createElement('div');
                checkboxWrapper.className = 'objective-checkbox-wrapper';
                checkboxWrapper.innerHTML = `<div class="custom-checkbox ${obj.completed ? 'checked' : ''}"></div>`;

                const textSpan = document.createElement('span');
                textSpan.textContent = obj.description;

                div.appendChild(checkboxWrapper);
                div.appendChild(textSpan);
                container.appendChild(div);
            });
        } else {
            container.innerHTML = '<p style="color: #b8b8d1;">No active quests</p>';
        }
    }

    addChatMessage(messageData) {
        const container = document.getElementById('chatMessages');

        const messageDiv = document.createElement('div');
        messageDiv.className = `chat-message message-${messageData.message_type || 'gm'}`;
        messageDiv.innerHTML = `
            <div class="message-sender">${messageData.sender || 'Game Master'}</div>
            <div>${messageData.content || messageData.text}</div>
        `;

        container.appendChild(messageDiv);
        container.scrollTop = container.scrollHeight;
    }

    showNotification(notificationData) {
        alert(notificationData.message);
    }

    updatePlayerStatus(statusData) {
        console.log('Player status updated:', statusData);
    }

    updateConnectionStatus(status, text) {
        const statusBox = document.getElementById('connectionStatusBox');
        const statusText = document.getElementById('statusText');
        const headerStatus = document.getElementById('connectionStatus');

        statusBox.className = `connection-status ${status}`;
        statusText.textContent = text;

        if (status === 'connected') {
            headerStatus.innerHTML = '● Connected';
            headerStatus.style.color = '#4ade80'; // Bright green
            setTimeout(() => {
                statusBox.style.display = 'none';
            }, 3000);
        } else {
            headerStatus.innerHTML = `● ${text}`;
            headerStatus.style.color = status === 'connecting' ? '#fbbf24' : '#f87171'; // Bright yellow/red
        }
    }

    attemptReconnect() {
        if (this.reconnectAttempts < this.maxReconnectAttempts) {
            this.reconnectAttempts++;
            console.log(`Reconnecting (attempt ${this.reconnectAttempts})...`);
            setTimeout(() => this.connect(), 2000 * this.reconnectAttempts);
        } else {
            console.error('Max reconnect attempts reached');
            this.updateConnectionStatus('disconnected', 'Connection failed. Please refresh.');
        }
    }

    generateRequestId() {
        return Math.random().toString(36).substring(7);
    }
}

// Initialize game client
const gameClient = new GameClient();

// Drawer Management
class DrawerManager {
    constructor() {
        this.questOpen = false;
        this.questAnchored = false;
        this.partyOpen = false;
        this.partyAnchored = false;

        // Load saved states from localStorage
        this.loadState();
    }

    loadState() {
        try {
            const savedState = localStorage.getItem('gameDrawerState');
            if (savedState) {
                const state = JSON.parse(savedState);

                // Restore quest drawer
                if (state.questAnchored) {
                    this.questAnchored = true;
                    this.questOpen = true;
                    const drawer = document.getElementById('questDrawer');
                    const content = document.getElementById('gameContent');
                    const toggle = document.getElementById('questToggle');
                    const pinBtn = document.getElementById('questPin');

                    drawer.classList.add('open', 'anchored');
                    document.querySelector('.game-session-wrapper').classList.add('left-pinned');
                    toggle.classList.add('hidden');
                    pinBtn.classList.add('active');
                }

                // Restore party drawer
                if (state.partyAnchored) {
                    this.partyAnchored = true;
                    this.partyOpen = true;
                    const drawer = document.getElementById('partyDrawer');
                    const content = document.getElementById('gameContent');
                    const toggle = document.getElementById('partyToggle');
                    const pinBtn = document.getElementById('partyPin');

                    drawer.classList.add('open', 'anchored');
                    document.querySelector('.game-session-wrapper').classList.add('right-pinned');
                    toggle.classList.add('hidden');
                    pinBtn.classList.add('active');
                }
            }
        } catch (e) {
            console.error('Error loading drawer state:', e);
        }
    }

    saveState() {
        try {
            const state = {
                questAnchored: this.questAnchored,
                partyAnchored: this.partyAnchored
            };
            localStorage.setItem('gameDrawerState', JSON.stringify(state));
        } catch (e) {
            console.error('Error saving drawer state:', e);
        }
    }

    toggleQuest() {
        this.questOpen = !this.questOpen;
        const drawer = document.getElementById('questDrawer');
        const toggle = document.getElementById('questToggle');
        const content = document.getElementById('gameContent');

        if (this.questOpen) {
            drawer.classList.add('open');
        } else {
            drawer.classList.remove('open');
            if (this.questAnchored) {
                this.questAnchored = false;
                drawer.classList.remove('anchored');
                document.getElementById('questPin').classList.remove('active');
                content.classList.remove('left-pinned');
                toggle.classList.remove('hidden');
            }
        }
    }

    toggleParty() {
        this.partyOpen = !this.partyOpen;
        const drawer = document.getElementById('partyDrawer');
        const toggle = document.getElementById('partyToggle');
        const content = document.getElementById('gameContent');

        if (this.partyOpen) {
            drawer.classList.add('open');
        } else {
            drawer.classList.remove('open');
            if (this.partyAnchored) {
                this.partyAnchored = false;
                drawer.classList.remove('anchored');
                document.getElementById('partyPin').classList.remove('active');
                content.classList.remove('right-pinned');
                toggle.classList.remove('hidden');
            }
        }
    }

    pinQuest() {
        if (!this.questOpen) return;

        this.questAnchored = !this.questAnchored;
        const drawer = document.getElementById('questDrawer');
        const content = document.getElementById('gameContent');
        const toggle = document.getElementById('questToggle');
        const pinBtn = document.getElementById('questPin');

        if (this.questAnchored) {
            drawer.classList.add('anchored');
            document.querySelector('.game-session-wrapper').classList.add('left-pinned');
            toggle.classList.add('hidden');
            pinBtn.classList.add('active');
        } else {
            drawer.classList.remove('anchored');
            document.querySelector('.game-session-wrapper').classList.remove('left-pinned');
            toggle.classList.remove('hidden');
            pinBtn.classList.remove('active');
        }

        this.saveState();
    }

    pinParty() {
        if (!this.partyOpen) return;

        this.partyAnchored = !this.partyAnchored;
        const drawer = document.getElementById('partyDrawer');
        const content = document.getElementById('gameContent');
        const toggle = document.getElementById('partyToggle');
        const pinBtn = document.getElementById('partyPin');

        if (this.partyAnchored) {
            drawer.classList.add('anchored');
            document.querySelector('.game-session-wrapper').classList.add('right-pinned');
            toggle.classList.add('hidden');
            pinBtn.classList.add('active');
        } else {
            drawer.classList.remove('anchored');
            document.querySelector('.game-session-wrapper').classList.remove('right-pinned');
            toggle.classList.remove('hidden');
            pinBtn.classList.remove('active');
        }

        this.saveState();
    }
}

const drawerManager = new DrawerManager();

// Load initial scene from saved state
async function loadInitialScene() {
    try {
        const sessionId = '{{ session_data.session_id }}';
        const response = await fetch(`http://localhost:9500/api/v1/session/${sessionId}/state`);

        if (response.ok) {
            const state = await response.json();

            // Load scene description
            if (state.scene_description) {
                const sceneContent = document.getElementById('sceneContent');
                sceneContent.innerHTML = ''; // Clear loading message

                const narrativeDiv = document.createElement('div');
                narrativeDiv.className = 'narrative-text';
                narrativeDiv.innerHTML = gameClient.parseMarkdown(state.scene_description);
                sceneContent.appendChild(narrativeDiv);

                // Update suggested actions if available
                if (state.available_actions && state.available_actions.length > 0) {
                    gameClient.updateSuggestedActions(state.available_actions);
                }

                // Enable action input
                const actionInput = document.getElementById('actionInput');
                const submitBtn = document.getElementById('submitAction');
                actionInput.disabled = false;
                submitBtn.disabled = false;
            }

            // Load quest progress
            if (state.quest_progress) {
                gameClient.updateQuestProgress(state.quest_progress);
            }

            // Load campaign info (for display in quest drawer)
            if (state.campaign_name) {
                loadCampaignInfo(state);
            }
        }
    } catch (error) {
        console.error('Error loading initial scene:', error);
    }
}

// Load campaign and quest information
function loadCampaignInfo(state) {
    const container = document.getElementById('questObjectives');
    let html = '';

    // Campaign header
    if (state.campaign_name) {
        html += `
            <div style="margin-bottom: 1.5rem; padding-bottom: 1rem; border-bottom: 2px solid rgba(212, 175, 55, 0.3);">
                <h3 style="color: #d4af37; margin: 0 0 0.5rem 0; font-size: 1.1rem;">📜 ${state.campaign_name}</h3>
                ${state.campaign_plot ? `<p style="font-size: 0.85rem; color: #b8b8d1; margin: 0;">${state.campaign_plot}</p>` : ''}
            </div>
        `;
    }

    // Current quest
    if (state.quest_progress) {
        const quest = state.quest_progress;
        html += `
            <div style="margin-bottom: 1rem;">
                <h4 style="color: #d4af37; margin: 0 0 0.5rem 0; font-size: 1rem;">⚔️ ${quest.quest_name || 'Current Quest'}</h4>
                <div style="font-size: 0.8rem; color: #94a3b8; margin-bottom: 0.5rem;">
                    Progress: ${quest.overall_progress || 0}%
                </div>
            </div>
        `;

        // Objectives
        if (quest.objectives && quest.objectives.length > 0) {
            html += '<div style="margin-top: 1rem;">';
            html += '<div style="font-size: 0.9rem; color: #d4af37; margin-bottom: 0.5rem; font-weight: 600;">Objectives:</div>';

            quest.objectives.forEach((obj, index) => {
                const completed = obj.completed || obj.percent === 100;
                const progress = obj.percent || 0;

                html += `
                    <div class="objective-item" style="margin-bottom: 0.75rem; padding: 0.5rem; background: rgba(255,255,255,0.05); border-radius: 4px;">
                        <div style="display: flex; align-items: start; gap: 0.5rem;">
                            <div style="flex-shrink: 0; margin-top: 2px;">
                                ${completed ? '✅' : '⬜'}
                            </div>
                            <div style="flex: 1;">
                                <div style="font-size: 0.85rem; color: ${completed ? '#4ade80' : '#e0e0e0'}; margin-bottom: 0.25rem;">
                                    ${obj.description}
                                </div>
                                ${progress > 0 ? `
                                    <div style="background: rgba(0,0,0,0.3); height: 6px; border-radius: 3px; overflow: hidden;">
                                        <div style="width: ${progress}%; height: 100%; background: linear-gradient(90deg, #4ade80 0%, #22c55e 100%); transition: width 0.3s;"></div>
                                    </div>
                                ` : ''}
                            </div>
                        </div>
                    </div>
                `;
            });
            html += '</div>';
        }
    }

    // Player achievements section
    const knowledge = state.player_knowledge_full || state.player_knowledge || {};
    const inventory = state.player_inventories_full || state.player_inventories || {};

    const knowledgeCount = Object.keys(knowledge).length;
    const itemCount = Object.keys(inventory).length;

    if (knowledgeCount > 0 || itemCount > 0) {
        html += `
            <div style="margin-top: 1.5rem; padding-top: 1rem; border-top: 2px solid rgba(212, 175, 55, 0.3);">
                <h4 style="color: #d4af37; margin: 0 0 0.75rem 0; font-size: 0.95rem;">📊 Progress</h4>
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 0.5rem; font-size: 0.85rem;">
                    <div style="padding: 0.5rem; background: rgba(74, 222, 128, 0.1); border-radius: 4px; text-align: center;">
                        <div style="color: #4ade80; font-size: 1.2rem; font-weight: 600;">${knowledgeCount}</div>
                        <div style="color: #94a3b8;">Knowledge</div>
                    </div>
                    <div style="padding: 0.5rem; background: rgba(147, 197, 253, 0.1); border-radius: 4px; text-align: center;">
                        <div style="color: #93c5fd; font-size: 1.2rem; font-weight: 600;">${itemCount}</div>
                        <div style="color: #94a3b8;">Items</div>
                    </div>
                </div>
            </div>
        `;
    }

    container.innerHTML = html || '<p style="color: #b8b8d1;">No active quests</p>';
}

// Connect on page load
document.addEventListener('DOMContentLoaded', async () => {
    // Load initial scene from state
    await loadInitialScene();

    gameClient.connect();

    // Drawer controls
    document.getElementById('questToggle').addEventListener('click', () => {
        drawerManager.toggleQuest();
    });

    document.getElementById('questClose').addEventListener('click', () => {
        drawerManager.toggleQuest();
    });

    document.getElementById('questPin').addEventListener('click', () => {
        drawerManager.pinQuest();
    });

    document.getElementById('partyToggle').addEventListener('click', () => {
        drawerManager.toggleParty();
    });

    document.getElementById('partyClose').addEventListener('click', () => {
        drawerManager.toggleParty();
    });

    document.getElementById('partyPin').addEventListener('click', () => {
        drawerManager.pinParty();
    });

    // Handle action form submission
    document.getElementById('actionForm').addEventListener('submit', (e) => {
        e.preventDefault();
        const input = document.getElementById('actionInput');
        const action = input.value.trim();

        if (action) {
            gameClient.sendPlayerAction(action);
            input.value = '';
        }
    });

    // Chat tabs
    document.querySelectorAll('.chat-tab').forEach(tab => {
        tab.addEventListener('click', () => {
            document.querySelectorAll('.chat-tab').forEach(t => t.classList.remove('active'));
            tab.classList.add('active');
        });
    });
});
</script>
{% endblock %}
